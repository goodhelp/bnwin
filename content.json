{"meta":{"title":"百脑问+ 知止而后有定","subtitle":"人非草木,可语于冰。春可种,夏可耕,秋可收,冬可享。四季就是前路，理该上下而求索!","description":"百脑问提供原创软件,源码及编程技巧","author":"百脑问","url":"https://goodhelp.gitee.io","root":"/"},"pages":[{"title":"404","date":"2021-09-14T15:16:07.677Z","updated":"2021-09-14T15:16:07.677Z","comments":false,"path":"/404.html","permalink":"https://goodhelp.gitee.io/404","excerpt":"","text":"404 Not Found 404 网站已改版，链接已变 请到首页查看!"},{"title":"","date":"2021-09-14T15:06:17.518Z","updated":"2021-09-14T15:06:17.518Z","comments":true,"path":"404/404.css","permalink":"https://goodhelp.gitee.io/404/404.css","excerpt":"","text":":root { box-sizing: border-box; cursor: default; } ::-moz-selection { color: #11111b; background-color: #c0dc67; } ::selection { color: #11111b; background-color: #c0dc67; } html, body { width: 100%; height: 100%; background-color: #11111b; color: #afd33d; font-size: calc(6.4px + 0.8125vw); overflow: hidden; } .error-body { position: relative; width: 99%; height: 99%; overflow: hidden; } .error-body:before { content: \"\"; position: fixed; top: 0; left: 0; width: 99%; height: 99%; background-color: #afd33d; mix-blend-mode: overlay; z-index: 1; } .error-body:after { content: \"\"; position: fixed; top: 0; left: 0; width: 99%; height: 99%; background: linear-gradient(90deg, #11111b 21px, transparent 1%) center, linear-gradient(#11111b 21px, transparent 1%) center, white; background-size: 22px 22px; background-position: center; opacity: 0.2; z-index: 1; } .error-body .background { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; filter: grayscale(1); mix-blend-mode: luminosity; } .error-body .message { position: relative; width: 100%; height: 100%; text-align: center; z-index: 3; } .error-body .message h1 { position: absolute; top: 10%; left: 0%; width: 100%; font-size: 10em; margin: 0; -webkit-animation: shake 600ms ease-in-out infinite alternate; animation: shake 600ms ease-in-out infinite alternate; text-shadow: 0 0 0.07em #afd33d, -0.2em 0 2em rgba(175, 211, 61, 0.3), 0.2em 0 2em rgba(175, 211, 61, 0.3); -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .error-body .message h1:before { content: attr(t); position: absolute; left: 50%; transform: translate(-50%, 0.34em); height: 0.1em; line-height: 0.5em; width: 100%; -webkit-animation: scan 500ms ease-in-out infinite alternate 128ms, glitch-anim 300ms ease-in-out infinite alternate; animation: scan 500ms ease-in-out infinite alternate 128ms, glitch-anim 300ms ease-in-out infinite alternate; overflow: hidden; opacity: 0.7; } .error-body .message h1:after { content: attr(t); position: absolute; top: -16px; left: 50%; transform: translate(-50%, 0.34em); height: 0.5em; line-height: 0.1em; width: 100%; -webkit-animation: scan 665ms ease-in-out infinite alternate 527ms, glitch-anim 300ms ease-in-out infinite alternate; animation: scan 665ms ease-in-out infinite alternate 527ms, glitch-anim 300ms ease-in-out infinite alternate; overflow: hidden; opacity: 0.8; } .error-body .message .bottom { position: absolute; top: 65%; left: 0; width: 100%; } .error-body .message p, .error-body .message a { font-size: 2em; font-family: monospace; text-shadow: 0 0 5px #afd33d; filter: blur(0.8px); } .error-body .message a { position: relative; color: #afd33d; text-decoration: none; font-weight: 700; border: 2px solid #afd33d; text-transform: uppercase; padding: 5px 30px; box-shadow: inset 0 0 0 0 rgba(175, 211, 61, 0.2); transition: 25ms ease-in-out all 0ms; overflow: hidden; -webkit-animation: attn 3s ease-in-out infinite; animation: attn 3s ease-in-out infinite; } .error-body .message a:hover { cursor: crosshair; box-shadow: inset 0 -2em 0 0 rgba(175, 211, 61, 0.2); transition: 225ms ease-in-out all 225ms; -webkit-animation: none; animation: none; } .error-body .message a:hover:before, .error-body .message a:hover:after { transform: translate(-50%, 0) scale(0, 1); } .error-body .message a:active { box-shadow: inset 0 -2em 0 0 rgba(175, 211, 61, 0.5); transition: 225ms ease-in-out all 225ms; } .error-body .message a:before, .error-body .message a:after { content: \"\"; position: absolute; left: 50%; transform: translate(-50%, 0) scale(1, 1); transform-origin: center; background-color: #11111b; width: 90%; height: 5px; transition: 225ms ease-in-out all; mix-blend-mode: hard-light; } .error-body .message a:before { top: -4px; } .error-body .message a:after { bottom: -4px; } @-webkit-keyframes scan { from, 20%, 100% { height: 0; transform: translate(-50%, 0.44em); } 10%, 15% { height: 1em; line-height: 0.2em; transform: translate(-55%, 0.21em); } } @keyframes scan { from, 20%, 100% { height: 0; transform: translate(-50%, 0.44em); } 10%, 15% { height: 1em; line-height: 0.2em; transform: translate(-55%, 0.21em); } } @keyframe pulse { from { text-shadow: 0 0 0 #afd33d, 0 0 0 rgba(175, 211, 61, 0.3), 0 0 0 rgba(175, 211, 61, 0.3); } to { text-shadow: 0 0 0.07em #afd33d, -0.2em 0 2em rgba(175, 211, 61, 0.3), 0.2em 0 2em rgba(175, 211, 61, 0.3); } } @-webkit-keyframes attn { 0%, 100% { opacity: 1; } 30%, 35% { opacity: 0.4; } } @keyframes attn { 0%, 100% { opacity: 1; } 30%, 35% { opacity: 0.4; } } @-webkit-keyframes shake { 0%, 100% { transform: translate(-1px, 0); } 10% { transform: translate(2px, 1px); } 30% { transform: translate(-3px, 2px); } 35% { transform: translate(2px, -3px); filter: blur(4px); } 45% { transform: translate(2px, 2px) skewY(-8deg) scale(0.96, 1); filter: blur(0); } 50% { transform: translate(-3px, 1px); } } @keyframes shake { 0%, 100% { transform: translate(-1px, 0); } 10% { transform: translate(2px, 1px); } 30% { transform: translate(-3px, 2px); } 35% { transform: translate(2px, -3px); filter: blur(4px); } 45% { transform: translate(2px, 2px) skewY(-8deg) scale(0.96, 1); filter: blur(0); } 50% { transform: translate(-3px, 1px); } } @-webkit-keyframes glitch-anim { 0% { clip: rect(82px, 9999px, 70px, 0); } 10% { clip: rect(58px, 9999px, 3px, 0); } 20% { clip: rect(94px, 9999px, 24px, 0); } 30% { clip: rect(28px, 9999px, 25px, 0); } 40% { clip: rect(24px, 9999px, 82px, 0); } 50% { clip: rect(72px, 9999px, 56px, 0); } 60% { clip: rect(6px, 9999px, 30px, 0); } 70% { clip: rect(80px, 9999px, 89px, 0); } 80% { clip: rect(20px, 9999px, 10px, 0); } 90% { clip: rect(79px, 9999px, 18px, 0); } 100% { clip: rect(20px, 9999px, 53px, 0); } } @keyframes glitch-anim { 0% { clip: rect(82px, 9999px, 70px, 0); } 10% { clip: rect(58px, 9999px, 3px, 0); } 20% { clip: rect(94px, 9999px, 24px, 0); } 30% { clip: rect(28px, 9999px, 25px, 0); } 40% { clip: rect(24px, 9999px, 82px, 0); } 50% { clip: rect(72px, 9999px, 56px, 0); } 60% { clip: rect(6px, 9999px, 30px, 0); } 70% { clip: rect(80px, 9999px, 89px, 0); } 80% { clip: rect(20px, 9999px, 10px, 0); } 90% { clip: rect(79px, 9999px, 18px, 0); } 100% { clip: rect(20px, 9999px, 53px, 0); } }"},{"title":"关于百脑问","date":"2021-09-05T13:37:03.000Z","updated":"2021-09-12T02:42:23.975Z","comments":true,"path":"about/index.html","permalink":"https://goodhelp.gitee.io/about/","excerpt":"","text":""}],"posts":[{"title":"使用croc两网吧之间同步互传文件","slug":"soft/使用croc两网吧之间互传同步文件","date":"2021-09-15T04:15:29.000Z","updated":"2021-09-16T12:34:44.558Z","comments":true,"path":"page/1934957637/","link":"","permalink":"https://goodhelp.gitee.io/page/1934957637/","excerpt":"故事背景网吧A和网吧B之间经常有这样的事情发生:网吧A更新游戏，如pubg，更新量很大，比如40G，网吧A速度很快，已经更新完成，但网吧B速度慢，到游戏开服也只更新了20G。如果把网吧A的游戏同步更新到网吧B呢？一般的做法是用U盘从网吧A拷到网吧B但网吧使用无盘服务器，需要在服务器上插U盘，风险较高！并且比较麻烦，从网吧A拷了游戏还要跑网吧B操作。如果在网吧A开通ftp，再从网吧B下载，速度不敢保证，并且还得映射端口，各种复杂的操作!普通小白做不到！其中直接同步，可以采用syncthing实现两网吧P2P文件同步，syncthing需要双方安装，总之操作不够简单！croc是使用golang 编写的工具，允许任何两台计算机简单和安全地传输文件和文件夹。据我所知，croc 是唯一的 CLI 文件传输工具。对，你没听错，只需要一个文件croc.exe，分别拷到网吧A和网吧B的游戏目录，同时运行就可以互传文件或文件夹!如果网吧A和网吧B的带宽均不高，网吧间互传文件很慢，那么你也可以从网吧A用U盘拷游戏到网吧B，从客户机使用croc和网吧B的服务器同步文件，局域网传文件相当快，比在服务器插U盘相比，中毒风险直接排除！ 功能介绍 croc 的特性：允许任意两台计算机传输数据（使用一个中继） 提供端到端加密（使用 PAKE） 支持方便的跨平台传输，支持 Windows、Linux、Mac 允许多文件传输 允许恢复被中断的传输 不需要本地服务器或端口转发 通过压缩和多路复用比虫洞、rsync、scp 更快（加速 1.5x 到 4x） 支持IPv6和IPv4； 支持使用Tor之类的代理； 简单使用方法 如需发送文件，可以直接运行下列命令： 123$ croc send [file(s)-or-folder]Sending &#x27;file-or-folder&#x27; (X MB)Code is: code-phrase 接下来，在另一台电脑上使用下列命令来进行文件或目录接收： 1$ croc code-phrase 这里的code-phrase即密码短语，用于建立密码认证密钥协议（PAKE），该协议将生成一个密钥供发送方和接收方用于端到端加密。 自定义密码短语我们可以使用下列方式来配置自己的密码短语，必须是4个字符以上：","text":"故事背景网吧A和网吧B之间经常有这样的事情发生:网吧A更新游戏，如pubg，更新量很大，比如40G，网吧A速度很快，已经更新完成，但网吧B速度慢，到游戏开服也只更新了20G。如果把网吧A的游戏同步更新到网吧B呢？一般的做法是用U盘从网吧A拷到网吧B但网吧使用无盘服务器，需要在服务器上插U盘，风险较高！并且比较麻烦，从网吧A拷了游戏还要跑网吧B操作。如果在网吧A开通ftp，再从网吧B下载，速度不敢保证，并且还得映射端口，各种复杂的操作!普通小白做不到！其中直接同步，可以采用syncthing实现两网吧P2P文件同步，syncthing需要双方安装，总之操作不够简单！croc是使用golang 编写的工具，允许任何两台计算机简单和安全地传输文件和文件夹。据我所知，croc 是唯一的 CLI 文件传输工具。对，你没听错，只需要一个文件croc.exe，分别拷到网吧A和网吧B的游戏目录，同时运行就可以互传文件或文件夹!如果网吧A和网吧B的带宽均不高，网吧间互传文件很慢，那么你也可以从网吧A用U盘拷游戏到网吧B，从客户机使用croc和网吧B的服务器同步文件，局域网传文件相当快，比在服务器插U盘相比，中毒风险直接排除！ 功能介绍 croc 的特性：允许任意两台计算机传输数据（使用一个中继） 提供端到端加密（使用 PAKE） 支持方便的跨平台传输，支持 Windows、Linux、Mac 允许多文件传输 允许恢复被中断的传输 不需要本地服务器或端口转发 通过压缩和多路复用比虫洞、rsync、scp 更快（加速 1.5x 到 4x） 支持IPv6和IPv4； 支持使用Tor之类的代理； 简单使用方法 如需发送文件，可以直接运行下列命令： 123$ croc send [file(s)-or-folder]Sending &#x27;file-or-folder&#x27; (X MB)Code is: code-phrase 接下来，在另一台电脑上使用下列命令来进行文件或目录接收： 1$ croc code-phrase 这里的code-phrase即密码短语，用于建立密码认证密钥协议（PAKE），该协议将生成一个密钥供发送方和接收方用于端到端加密。 自定义密码短语我们可以使用下列方式来配置自己的密码短语，必须是4个字符以上： 1$ croc send --code [code-phrase] [file(s)-or-folder] 使用管道-stdin和stdout我们可以通过管道来向Croc传递文件： 1$ cat [filename] | croc send 此时，Croc将会自动使用stdin数据，并发送和分配一个类似“croc-stdin-123456789”的文件名。如需接收stdout，可以直接使用–yes选项来自动接收文件： 1$ croc --yes [code-phrase] &gt; out 发送文字消息有些时候，我们可能只需要发送URL地址或简短的文字消息，此时可以通过下列命令实现发送： 1$ croc send --text &quot;hello world&quot; 使用代理我们还可以使用代理链接来进行传输中继，比如说，我们可以使用下列命令来将Tor作为代理中继： 1$ croc --socks5 &quot;127.0.0.1:9050&quot; send SOMEFILE 网吧同步文件的使用 网吧A与网吧B直接传文件，如要拷贝的目录为pubg，则先把croc.exe拷到pubg同级目录（不是拷在pubg目录，如pubg完整目录为g:\\steam\\pubg,那croc.exe应拷到g:\\steam目录，同步完就可以把croc.exe删除）然后执行1croc send --code mysendname pubg 在网吧B也把croc.exe拷到pubg同级目录，执行1croc mysendname 即实现了把网吧A的pubg文件夹完全拷到网吧B的pubg 网吧客户机拷到网吧服务器。比如用U盘从网吧A拷了游戏，在网吧B任意一台机器拷到网吧B的服务器，同样在要拷贝的同级分别拷贝croc.exe在客户机执行发送端执行先建服务(中转服务器直接在客户机，拷贝速度就看你内网的速度，下面的192.168.10.8的IP就是执行此命令的机器的IP)1croc replay 再传文件夹(IP换成你当前中转服务机器的IP，一般就在当前机器)1croc --relay 192.168.10.8:9009 send --code mysendtask pubg 接收端执行(IP换成你当前中转服务机器的IP)1croc --relay 192.168.10.8:9009 mysendtask 下载地址github下载地址github开源如果github的下载速度太慢，你也可以尝试搜索国内的下载地址","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"精品软件","slug":"精品软件","permalink":"https://goodhelp.gitee.io/tags/%E7%B2%BE%E5%93%81%E8%BD%AF%E4%BB%B6/"}]},{"title":"Delphi实现类似Android锁屏的密码锁控件","slug":"article/Delphi实现类似Android锁屏的密码锁控件","date":"2021-09-14T04:07:15.000Z","updated":"2021-09-16T23:41:43.689Z","comments":true,"path":"page/2745266982/","link":"","permalink":"https://goodhelp.gitee.io/page/2745266982/","excerpt":"手机锁屏之后，开屏的时候，要求咱们输入密码的那个滑动效果输入的控件。 Android的那个锁屏的效果，用过的人应该都知道是个什么效果，也就是横竖各3行，排列成九宫格的效果，然后由用户在上面滑动以此来达到密码输入进而进行解锁和加密的效果。那么首先，俺们可以分析一下，他的具体形成思路，实际上是很简单的，就是一个排列，然后根据滑动产生的内容形成密码来达到解密的目的，那么最主要的就是这个密码和他本身的密码是如何对应解密的，实际上很简单，咱们给他排列的九宫格，都固定好位置 1 2 34 5 67 8 9 就像这样，排列的给他的位置固定好，然后每一个格子表示一个字符或者说字符串，进而用户滑动的时候，将对应的位置序列进入到一个列表中去保存，然后鼠标放开的时候，那么入队的选择位置进行组合，那么就是对应的密码了，比如 这样的输入就是表示123，如此顺序记录，就可以形成密码了，然后用户进行滑屏录入之后和以前的进行比较就可以知道密码是否正确了，当然我这个组合是相当简单的，如果想要整的复杂，可以给每个顺序位置给定复杂的字符串，这样形成的密码就足够的复杂了！给一般人去看，也是看不明白的。 那么分析清楚了，思路也就简单了，鼠标按下的时候，开始可以滑动形成密码，鼠标按下的第一个点，作为队列的第一个，然后再滑过的就顺序的一一的记录到队列中，鼠标放开的时候，从队列中获取各个顺序位置，组合形成密码然后和原密码比对，判断密码是否正确！源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313&#123; Delphi实现的类似Android鼠标锁屏效果的控件 作者：不得闲 2012-7-23&#125;unit AndroidLockControl;interfaceuses Windows,Classes,SysUtils,Graphics,Controls;type TDxLockItem = class private r: TRect; IsEnter: Boolean; IsChecked: Boolean; Value: AnsiChar; FRadio: TPoint; public constructor Create; end; TInPutPwdEvent = procedure(Sender: TObject;InputPwd: string) of object; TDxAndroidLock = class(TGraphicControl) private FItemSpace: Integer; FRowCount: Integer; FColCount: Integer; FItemRaidio: Integer; Items: TList; FUseNum: Boolean; FPassword: string; IsDown: Boolean; LastInItem: TDxLockItem; PwdItems: TList; FOnInputPwd: TInPutPwdEvent; procedure SetItemSpace(const Value: Integer); procedure SetItemRaidio(const Value: Integer); procedure SetUseNum(const Value: Boolean); protected procedure paint;override; procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override; procedure MouseMove(Shift: TShiftState; X, Y: Integer); override; procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override; procedure CalcItemRects; public constructor Create(AOwner: TComponent);override; destructor Destroy;override; property Password: string read FPassword write FPassWord; published property ItemSpace: Integer read FItemSpace write SetItemSpace default 10; property OnInputPwd: TInPutPwdEvent read FOnInputPwd write FOnInputPwd; property ItemRaidio: Integer read FItemRaidio write SetItemRaidio default 20; property UseNum: Boolean read FUseNum write SetUseNum; end;implementationuses pngimage;&#123;$R LockRc.RES&#125;var PngIn,PngOut: TPngImage;&#123; TDxAndroidLock &#125;procedure TDxAndroidLock.CalcItemRects;var i,j: Integer; p: TPoint; r: TRect; item: TDxLockItem;begin p.Y := FItemRaidio; for i := 1 to 3 do begin p.X := FItemRaidio; r.Left := p.X - FItemRaidio;r.Top := p.Y - FItemRaidio; r.Right := p.x + FItemRaidio;r.Bottom := p.Y + FItemRaidio; for j := 1 to 3 do begin item := Items[3*(i-1)+j - 1]; item.Value := AnsiChar(3*(i-1)+j+48); item.FRadio := p; item.r := r; p.X := p.X + FItemRaidio * 2 + FItemSpace; r.Left := p.X - FItemRaidio;r.Right := p.X + FItemRaidio; end; p.Y := p.Y + FItemRaidio * 2 + FItemSpace; end;end;constructor TDxAndroidLock.create(AOwner: TComponent);var i: Integer;begin inherited; LastInItem := nil; PwdItems := TList.Create; FPassWord := &#x27;&#x27;; Items := TList.Create; FItemSpace := 10; FRowCount := 3; FColCount := 3; FItemRaidio := 20; Width := FItemRaidio * 2 * 3 + FItemSpace * 2; Height := FItemRaidio * 2 * 3 + FItemSpace * 2; for i := 0 to 8 do begin Items.Add(TDxLockItem.Create); end; CalcItemRects;end;destructor TDxAndroidLock.Destroy;begin while Items.Count &gt; 0 do begin TDxLockItem(Items[Items.Count - 1]).Free; Items.Delete(Items.Count - 1); end; PwdItems.Free; inherited;end;procedure TDxAndroidLock.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);begin IsDown := Button = mbLeft; if IsDown then begin if LastInItem &lt;&gt; nil then begin LastInItem.IsChecked := IsDown; PwdItems.Add(LastInItem); end; Invalidate; end;end;procedure TDxAndroidLock.MouseMove(Shift: TShiftState; X, Y: Integer);var i: Integer; p: TPoint; OldInItem,Item: TDxLockItem;begin OldInItem := LastInItem; p := Point(x,y); LastInItem := nil; for i := 0 to items.Count - 1 do begin item := Items[i]; if PtInRect(Item.r,p) then begin LastInItem := Item; LastInItem.IsEnter := True; LastInItem.IsChecked := IsDown; Break; end; end; if LastInItem &lt;&gt; OldInItem then begin if OldInItem &lt;&gt; nil then OldInItem.IsEnter := False; if IsDown then begin if LastInItem &lt;&gt; nil then begin PwdItems.Add(LastInItem); end; Invalidate; end; end;end;procedure TDxAndroidLock.MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);var i: Integer; item: TDxLockItem; Np: string;begin IsDown := False; for i := 0 to items.Count - 1 do begin item := Items[i]; item.IsChecked := False; end; for i := 0 to PwdItems.Count - 1 do Np := Np + TDxLockItem(PwdItems[i]).Value; PwdItems.Clear; Invalidate; if Assigned(FOnInputPwd) then FOnInputPwd(self,Np);end;procedure DrawLineArrow(canvas: TCanvas; p1, p2: TPoint);const l = 6; //箭头长度 w = 4; //箭头宽度var slope, angle: Double; points: array[0..2] of TPoint; Xl,b: Single;begin canvas.Brush.Color := canvas.Pen.Color; canvas.Brush.Style := bsSolid; canvas.MoveTo(p1.X,p1.Y); canvas.LineTo(p2.X,p2.Y); if (p2.Y &lt;&gt; p1.Y) and (P2.X &lt;&gt; p1.X) then begin xl := (P2.Y - p1.Y) / (P2.X - p1.X); b := p2.Y - xl * p2.X; p2.X := (p2.X - p1.X) div 2 + p1.X; p2.Y := Trunc(p2.X * xl + b); end else if p2.Y = p1.Y then p2.X := (p2.X - p1.X) div 2 + p1.X else P2.Y := (p2.Y - p1.Y) div 2 + p1.Y;//画箭头 points[0] := Point(p2.x, p2.y);//箭头顶点 if (p2.x - p1.x = 0) then begin //垂直 if (p2.y - p1.y &gt; 0) then slope := -1 else slope := 1; points[1] := Point(p2.x - w, p2.y + Trunc(l * slope)); points[2] := Point(p2.x + w, p2.y + Trunc(l * slope)); end else begin //倾斜 slope := (p2.y - p1.y) / (p2.x - p1.x); angle := ArcTan(slope); if (p2.x - p1.x &gt; 0) then angle := angle - PI; points[1] := Point(p2.x + trunc(l * cos(angle) - w * sin(angle)), p2.y + trunc(l * sin(angle) + w * cos(angle))); points[2] := Point(p2.x + Trunc(l * cos(angle) + w * sin(angle)), p2.y + Trunc(l * sin(angle) - w * cos(angle))); end; canvas.Polygon(points);end;procedure TDxAndroidLock.paint;var i: Integer; item,item1: TDxLockItem; r: TRect;begin if not IsDown then begin for i := 0 to Items.Count - 1 do begin item := items[i]; r.Left := item.FRadio.X - 5;r.Right := item.FRadio.X + 5; r.Top := item.FRadio.Y - 5;r.Bottom := item.FRadio.Y + 5; Canvas.Draw(r.Left,r.Top,pngIn); end; end else begin //绘制指向线条 Canvas.Pen.Width := 2; Canvas.Pen.Color := clGreen; for i := 0 to PwdItems.Count - 2 do begin item := PwdItems[i]; item1 := PwdItems[i + 1]; Canvas.MoveTo(item.FRadio.X,item.FRadio.Y); Canvas.LineTo(item1.FRadio.X,item1.FRadio.Y); DrawLineArrow(Canvas,item.FRadio,item1.FRadio); end; for i := 0 to Items.Count - 1 do begin item := items[i]; if item.IsChecked then begin Canvas.Draw(item.r.Left,item.r.Top,pngOut); end; r.Left := item.FRadio.X - 5;r.Right := item.FRadio.X + 5; r.Top := item.FRadio.Y - 5;r.Bottom := item.FRadio.Y + 5; Canvas.Draw(r.Left,r.Top,pngIn); end; end;end;procedure TDxAndroidLock.SetItemRaidio(const Value: Integer);begin FItemRaidio := Value;end;procedure TDxAndroidLock.SetItemSpace(const Value: Integer);begin FItemSpace := Value;end;procedure TDxAndroidLock.SetUseNum(const Value: Boolean);begin FUseNum := Value;end;&#123; TDxLockItem &#125;constructor TDxLockItem.Create;begin r := Rect(0,0,0,0); IsEnter := False;end;initialization PngIn := TPngImage.Create; PngIn.LoadFromResourceName(Hinstance,&#x27;InnerGra&#x27;); PngOut := TPngImage.Create; PngOut.LoadFromResourceName(Hinstance,&#x27;Outer&#x27;);finalization PngIn.Free; PngOut.Free;end. 运行之后的效果就是转载自: https://www.cnblogs.com/DxSoft/archive/2012/07/23/2604941.html","text":"手机锁屏之后，开屏的时候，要求咱们输入密码的那个滑动效果输入的控件。 Android的那个锁屏的效果，用过的人应该都知道是个什么效果，也就是横竖各3行，排列成九宫格的效果，然后由用户在上面滑动以此来达到密码输入进而进行解锁和加密的效果。那么首先，俺们可以分析一下，他的具体形成思路，实际上是很简单的，就是一个排列，然后根据滑动产生的内容形成密码来达到解密的目的，那么最主要的就是这个密码和他本身的密码是如何对应解密的，实际上很简单，咱们给他排列的九宫格，都固定好位置 1 2 34 5 67 8 9 就像这样，排列的给他的位置固定好，然后每一个格子表示一个字符或者说字符串，进而用户滑动的时候，将对应的位置序列进入到一个列表中去保存，然后鼠标放开的时候，那么入队的选择位置进行组合，那么就是对应的密码了，比如 这样的输入就是表示123，如此顺序记录，就可以形成密码了，然后用户进行滑屏录入之后和以前的进行比较就可以知道密码是否正确了，当然我这个组合是相当简单的，如果想要整的复杂，可以给每个顺序位置给定复杂的字符串，这样形成的密码就足够的复杂了！给一般人去看，也是看不明白的。 那么分析清楚了，思路也就简单了，鼠标按下的时候，开始可以滑动形成密码，鼠标按下的第一个点，作为队列的第一个，然后再滑过的就顺序的一一的记录到队列中，鼠标放开的时候，从队列中获取各个顺序位置，组合形成密码然后和原密码比对，判断密码是否正确！源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313&#123; Delphi实现的类似Android鼠标锁屏效果的控件 作者：不得闲 2012-7-23&#125;unit AndroidLockControl;interfaceuses Windows,Classes,SysUtils,Graphics,Controls;type TDxLockItem = class private r: TRect; IsEnter: Boolean; IsChecked: Boolean; Value: AnsiChar; FRadio: TPoint; public constructor Create; end; TInPutPwdEvent = procedure(Sender: TObject;InputPwd: string) of object; TDxAndroidLock = class(TGraphicControl) private FItemSpace: Integer; FRowCount: Integer; FColCount: Integer; FItemRaidio: Integer; Items: TList; FUseNum: Boolean; FPassword: string; IsDown: Boolean; LastInItem: TDxLockItem; PwdItems: TList; FOnInputPwd: TInPutPwdEvent; procedure SetItemSpace(const Value: Integer); procedure SetItemRaidio(const Value: Integer); procedure SetUseNum(const Value: Boolean); protected procedure paint;override; procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override; procedure MouseMove(Shift: TShiftState; X, Y: Integer); override; procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override; procedure CalcItemRects; public constructor Create(AOwner: TComponent);override; destructor Destroy;override; property Password: string read FPassword write FPassWord; published property ItemSpace: Integer read FItemSpace write SetItemSpace default 10; property OnInputPwd: TInPutPwdEvent read FOnInputPwd write FOnInputPwd; property ItemRaidio: Integer read FItemRaidio write SetItemRaidio default 20; property UseNum: Boolean read FUseNum write SetUseNum; end;implementationuses pngimage;&#123;$R LockRc.RES&#125;var PngIn,PngOut: TPngImage;&#123; TDxAndroidLock &#125;procedure TDxAndroidLock.CalcItemRects;var i,j: Integer; p: TPoint; r: TRect; item: TDxLockItem;begin p.Y := FItemRaidio; for i := 1 to 3 do begin p.X := FItemRaidio; r.Left := p.X - FItemRaidio;r.Top := p.Y - FItemRaidio; r.Right := p.x + FItemRaidio;r.Bottom := p.Y + FItemRaidio; for j := 1 to 3 do begin item := Items[3*(i-1)+j - 1]; item.Value := AnsiChar(3*(i-1)+j+48); item.FRadio := p; item.r := r; p.X := p.X + FItemRaidio * 2 + FItemSpace; r.Left := p.X - FItemRaidio;r.Right := p.X + FItemRaidio; end; p.Y := p.Y + FItemRaidio * 2 + FItemSpace; end;end;constructor TDxAndroidLock.create(AOwner: TComponent);var i: Integer;begin inherited; LastInItem := nil; PwdItems := TList.Create; FPassWord := &#x27;&#x27;; Items := TList.Create; FItemSpace := 10; FRowCount := 3; FColCount := 3; FItemRaidio := 20; Width := FItemRaidio * 2 * 3 + FItemSpace * 2; Height := FItemRaidio * 2 * 3 + FItemSpace * 2; for i := 0 to 8 do begin Items.Add(TDxLockItem.Create); end; CalcItemRects;end;destructor TDxAndroidLock.Destroy;begin while Items.Count &gt; 0 do begin TDxLockItem(Items[Items.Count - 1]).Free; Items.Delete(Items.Count - 1); end; PwdItems.Free; inherited;end;procedure TDxAndroidLock.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);begin IsDown := Button = mbLeft; if IsDown then begin if LastInItem &lt;&gt; nil then begin LastInItem.IsChecked := IsDown; PwdItems.Add(LastInItem); end; Invalidate; end;end;procedure TDxAndroidLock.MouseMove(Shift: TShiftState; X, Y: Integer);var i: Integer; p: TPoint; OldInItem,Item: TDxLockItem;begin OldInItem := LastInItem; p := Point(x,y); LastInItem := nil; for i := 0 to items.Count - 1 do begin item := Items[i]; if PtInRect(Item.r,p) then begin LastInItem := Item; LastInItem.IsEnter := True; LastInItem.IsChecked := IsDown; Break; end; end; if LastInItem &lt;&gt; OldInItem then begin if OldInItem &lt;&gt; nil then OldInItem.IsEnter := False; if IsDown then begin if LastInItem &lt;&gt; nil then begin PwdItems.Add(LastInItem); end; Invalidate; end; end;end;procedure TDxAndroidLock.MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);var i: Integer; item: TDxLockItem; Np: string;begin IsDown := False; for i := 0 to items.Count - 1 do begin item := Items[i]; item.IsChecked := False; end; for i := 0 to PwdItems.Count - 1 do Np := Np + TDxLockItem(PwdItems[i]).Value; PwdItems.Clear; Invalidate; if Assigned(FOnInputPwd) then FOnInputPwd(self,Np);end;procedure DrawLineArrow(canvas: TCanvas; p1, p2: TPoint);const l = 6; //箭头长度 w = 4; //箭头宽度var slope, angle: Double; points: array[0..2] of TPoint; Xl,b: Single;begin canvas.Brush.Color := canvas.Pen.Color; canvas.Brush.Style := bsSolid; canvas.MoveTo(p1.X,p1.Y); canvas.LineTo(p2.X,p2.Y); if (p2.Y &lt;&gt; p1.Y) and (P2.X &lt;&gt; p1.X) then begin xl := (P2.Y - p1.Y) / (P2.X - p1.X); b := p2.Y - xl * p2.X; p2.X := (p2.X - p1.X) div 2 + p1.X; p2.Y := Trunc(p2.X * xl + b); end else if p2.Y = p1.Y then p2.X := (p2.X - p1.X) div 2 + p1.X else P2.Y := (p2.Y - p1.Y) div 2 + p1.Y;//画箭头 points[0] := Point(p2.x, p2.y);//箭头顶点 if (p2.x - p1.x = 0) then begin //垂直 if (p2.y - p1.y &gt; 0) then slope := -1 else slope := 1; points[1] := Point(p2.x - w, p2.y + Trunc(l * slope)); points[2] := Point(p2.x + w, p2.y + Trunc(l * slope)); end else begin //倾斜 slope := (p2.y - p1.y) / (p2.x - p1.x); angle := ArcTan(slope); if (p2.x - p1.x &gt; 0) then angle := angle - PI; points[1] := Point(p2.x + trunc(l * cos(angle) - w * sin(angle)), p2.y + trunc(l * sin(angle) + w * cos(angle))); points[2] := Point(p2.x + Trunc(l * cos(angle) + w * sin(angle)), p2.y + Trunc(l * sin(angle) - w * cos(angle))); end; canvas.Polygon(points);end;procedure TDxAndroidLock.paint;var i: Integer; item,item1: TDxLockItem; r: TRect;begin if not IsDown then begin for i := 0 to Items.Count - 1 do begin item := items[i]; r.Left := item.FRadio.X - 5;r.Right := item.FRadio.X + 5; r.Top := item.FRadio.Y - 5;r.Bottom := item.FRadio.Y + 5; Canvas.Draw(r.Left,r.Top,pngIn); end; end else begin //绘制指向线条 Canvas.Pen.Width := 2; Canvas.Pen.Color := clGreen; for i := 0 to PwdItems.Count - 2 do begin item := PwdItems[i]; item1 := PwdItems[i + 1]; Canvas.MoveTo(item.FRadio.X,item.FRadio.Y); Canvas.LineTo(item1.FRadio.X,item1.FRadio.Y); DrawLineArrow(Canvas,item.FRadio,item1.FRadio); end; for i := 0 to Items.Count - 1 do begin item := items[i]; if item.IsChecked then begin Canvas.Draw(item.r.Left,item.r.Top,pngOut); end; r.Left := item.FRadio.X - 5;r.Right := item.FRadio.X + 5; r.Top := item.FRadio.Y - 5;r.Bottom := item.FRadio.Y + 5; Canvas.Draw(r.Left,r.Top,pngIn); end; end;end;procedure TDxAndroidLock.SetItemRaidio(const Value: Integer);begin FItemRaidio := Value;end;procedure TDxAndroidLock.SetItemSpace(const Value: Integer);begin FItemSpace := Value;end;procedure TDxAndroidLock.SetUseNum(const Value: Boolean);begin FUseNum := Value;end;&#123; TDxLockItem &#125;constructor TDxLockItem.Create;begin r := Rect(0,0,0,0); IsEnter := False;end;initialization PngIn := TPngImage.Create; PngIn.LoadFromResourceName(Hinstance,&#x27;InnerGra&#x27;); PngOut := TPngImage.Create; PngOut.LoadFromResourceName(Hinstance,&#x27;Outer&#x27;);finalization PngIn.Free; PngOut.Free;end. 运行之后的效果就是转载自: https://www.cnblogs.com/DxSoft/archive/2012/07/23/2604941.html","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"delphi技巧","slug":"delphi技巧","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%8A%80%E5%B7%A7/"},{"name":"密码锁","slug":"密码锁","permalink":"https://goodhelp.gitee.io/tags/%E5%AF%86%E7%A0%81%E9%94%81/"}]},{"title":"实现进程被结束就蓝屏的函数","slug":"article/实现进程被结束就蓝屏的函数","date":"2021-09-14T03:04:04.000Z","updated":"2021-09-16T23:43:38.441Z","comments":true,"path":"page/2848625591/","link":"","permalink":"https://goodhelp.gitee.io/page/2848625591/","excerpt":"1. 保护进程，结束就蓝屏RtlSetProcessIsCritical函数可以启用或关闭开启之后变得和系统进程一样被杀系统直接蓝屏系统进程也是此函数实现的上图可以用于进程保护设置自己为保护进程，这样结束掉就会蓝屏，蓝屏信息翻译就是 重点保护进程。 设置为保护进程：RtlSetProcessIsCritical(True,Null(或Nothing),False) 取消（关闭时记得加上去。）：RtlSetProcessIsCritical(False,Null,False)把进程做crss中止就蓝屏，防止进程被杀这是最不占用CPU的方式了 以下为C代码 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;typedef (NTAPI*Rtl)(ULONG,BOOL,BOOL,PBOOL);typedef (NTAPI*PT1)(BOOL, PBOOLEAN, BOOL);typedef (NTAPI*PT2)(BOOL,PBOOLEAN,BOOL);void Protect()&#123; BOOL B; ULONG SE_DEBUG_PRIVILEGE = 20; Rtl RtlAdjustPrivilege=(Rtl)GetProcAddress(GetModuleHandleW(L&quot;ntdll&quot;),&quot;RtlAdjustPrivilege&quot;); PT1 RtlSetProcessIsCritical=(PT1)GetProcAddress(GetModuleHandleW(L&quot;ntdll&quot;), &quot;RtlSetProcessIsCritical&quot;); PT2 RtlSetThreadIsCritical=(PT2)GetProcAddress(GetModuleHandleW(L&quot;ntdll&quot;), &quot;RtlSetThreadIsCritical&quot;); RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE,TRUE,FALSE,&amp;B); RtlSetProcessIsCritical(TRUE,NULL,FALSE); RtlSetThreadIsCritical(TRUE, NULL, FALSE); //BY 1361784102&#125;void main()&#123; Protect(); getchar(); //BY 1361784102&#125; vb代码如下： 12345678910Option ExplicitPublic Declare Function RtlAdjustPrivilege Lib &quot;ntdll.dll&quot; (ByVal Privilege As Long, ByVal Enable As Boolean, ByVal Client As Boolean, WasEnabled As Long) As LongPublic Declare Function RtlSetProcessIsCritical Lib &quot;ntdll&quot; (Optional ByVal NewValue As Boolean, Optional ByVal Value As Boolean, Optional ByVal WinLogon As Boolean = True)Sub Main() RtlAdjustPrivilege 20, True, False, 0 RtlSetProcessIsCritical False, False, True EndEnd Sub 2. RtlAdjustPrivilege提权后NtRaiseHardError制造系统蓝屏VB代码如下：","text":"1. 保护进程，结束就蓝屏RtlSetProcessIsCritical函数可以启用或关闭开启之后变得和系统进程一样被杀系统直接蓝屏系统进程也是此函数实现的上图可以用于进程保护设置自己为保护进程，这样结束掉就会蓝屏，蓝屏信息翻译就是 重点保护进程。 设置为保护进程：RtlSetProcessIsCritical(True,Null(或Nothing),False) 取消（关闭时记得加上去。）：RtlSetProcessIsCritical(False,Null,False)把进程做crss中止就蓝屏，防止进程被杀这是最不占用CPU的方式了 以下为C代码 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;typedef (NTAPI*Rtl)(ULONG,BOOL,BOOL,PBOOL);typedef (NTAPI*PT1)(BOOL, PBOOLEAN, BOOL);typedef (NTAPI*PT2)(BOOL,PBOOLEAN,BOOL);void Protect()&#123; BOOL B; ULONG SE_DEBUG_PRIVILEGE = 20; Rtl RtlAdjustPrivilege=(Rtl)GetProcAddress(GetModuleHandleW(L&quot;ntdll&quot;),&quot;RtlAdjustPrivilege&quot;); PT1 RtlSetProcessIsCritical=(PT1)GetProcAddress(GetModuleHandleW(L&quot;ntdll&quot;), &quot;RtlSetProcessIsCritical&quot;); PT2 RtlSetThreadIsCritical=(PT2)GetProcAddress(GetModuleHandleW(L&quot;ntdll&quot;), &quot;RtlSetThreadIsCritical&quot;); RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE,TRUE,FALSE,&amp;B); RtlSetProcessIsCritical(TRUE,NULL,FALSE); RtlSetThreadIsCritical(TRUE, NULL, FALSE); //BY 1361784102&#125;void main()&#123; Protect(); getchar(); //BY 1361784102&#125; vb代码如下： 12345678910Option ExplicitPublic Declare Function RtlAdjustPrivilege Lib &quot;ntdll.dll&quot; (ByVal Privilege As Long, ByVal Enable As Boolean, ByVal Client As Boolean, WasEnabled As Long) As LongPublic Declare Function RtlSetProcessIsCritical Lib &quot;ntdll&quot; (Optional ByVal NewValue As Boolean, Optional ByVal Value As Boolean, Optional ByVal WinLogon As Boolean = True)Sub Main() RtlAdjustPrivilege 20, True, False, 0 RtlSetProcessIsCritical False, False, True EndEnd Sub 2. RtlAdjustPrivilege提权后NtRaiseHardError制造系统蓝屏VB代码如下： 12345678910111213141516171819202122Option ExplicitPublic Declare Function NtRaiseHardError Lib &quot;ntdll.dll&quot; (ByVal ErrorStatus As Long, ByVal NumberOfParameters As Long, ByVal UnicodeStringParameterMask As Long, ByRef Parameters As Any, ByVal ValidResponseOptions As Long, ByRef Response As Long) As LongPublic Declare Function RtlAdjustPrivilege Lib &quot;ntdll.dll&quot; (ByVal Privilege As Long, ByVal Enable As Boolean, ByVal Client As Boolean, WasEnabled As Long) As LongPublic Declare Sub RtlInitUnicodeString Lib &quot;ntdll.dll&quot; (DestinationString As UNICODE_STRING, ByVal SourceString As Long)Public Type UNICODE_STRING Length As Long MaximumLength As Long Buffer As LongEnd TypeSub Main() Dim u As UNICODE_STRING, p(3) As Long RtlAdjustPrivilege 19, True, False, 0 RtlInitUnicodeString u, StrPtr(&quot;Session Manager&quot;) p(0) = VarPtr(u) p(1) = u.Length p(2) = VarPtr(u) p(3) = VarPtr(u) NtRaiseHardError &amp;HC000021A, 4, 1, p(0), 6, 0 End Sub vc代码 函数原型NTSTATUS RtlAdjustPrivilege( ULONG Privilege, BOOLEAN Enable, BOOLEAN CurrentThread, PBOOLEAN Enabled);NTSYSAPI NTSTATUS NTAPI NtRaiseHardError( IN NTSTATUS ErrorStatus, IN ULONG NumberOfParameters, IN PUNICODE_STRING UnicodeStringParameterMask OPTIONAL, IN PVOID *Parameters, IN HARDERROR_RESPONSE_OPTION ResponseOption, OUT PHARDERROR_RESPONSE Response); NTHeaders.h（声明相关结构与变量）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//======================================================================//By TiKEY!//E-mail:tyk5555@hotmail.com//QQ:574436201//======================================================================#ifndef _NT_HDRS_#define _NT_HDRS_#include &lt;windows.h&gt;typedef /*__success(return &gt;= 0)*/ LONG NTSTATUS; typedef NTSTATUS *PNTSTATUS; #define STATUS_SUCCESS ((NTSTATUS)0x00000000L)typedef struct _LSA_UNICODE_STRING &#123; USHORT Length; USHORT MaximumLength; PWSTR Buffer;&#125; LSA_UNICODE_STRING, *PLSA_UNICODE_STRING, UNICODE_STRING, *PUNICODE_STRING;typedef enum _HARDERROR_RESPONSE_OPTION &#123; OptionAbortRetryIgnore, OptionOk, OptionOkCancel, OptionRetryCancel, OptionYesNo, OptionYesNoCancel, OptionShutdownSystem&#125; HARDERROR_RESPONSE_OPTION, *PHARDERROR_RESPONSE_OPTION;typedef enum _HARDERROR_RESPONSE &#123; ResponseReturnToCaller, ResponseNotHandled, ResponseAbort, ResponseCancel, ResponseIgnore, ResponseNo, ResponseOk, ResponseRetry, ResponseYes&#125; HARDERROR_RESPONSE, *PHARDERROR_RESPONSE;#endif BlueScreen.cpp: 123456789101112131415161718192021222324252627282930313233343536373839404142//======================================================================//By TiKEY!//E-mail:tyk5555@hotmail.com//QQ:574436201//======================================================================#include &lt;Windows.h&gt;#include &quot;NTHeaders.h&quot;HINSTANCE hInst; // 当前实例typedef UINT (CALLBACK* NTRAISEHARDERROR)(NTSTATUS, ULONG, PUNICODE_STRING, PVOID,HARDERROR_RESPONSE_OPTION, PHARDERROR_RESPONSE);typedef UINT (CALLBACK* RTLADJUSTPRIVILEGE)(ULONG, BOOL, BOOL, PINT);int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)&#123; HINSTANCE hDLL = LoadLibrary(TEXT(&quot;ntdll.dll&quot;)); NTRAISEHARDERROR NtRaiseHardError; RTLADJUSTPRIVILEGE RtlAdjustPrivilege; int nEn = 0; HARDERROR_RESPONSE reResponse; if (hDLL != NULL) &#123; NtRaiseHardError = (NTRAISEHARDERROR)GetProcAddress(hDLL, &quot;NtRaiseHardError&quot;); RtlAdjustPrivilege = (RTLADJUSTPRIVILEGE)GetProcAddress(hDLL, &quot;RtlAdjustPrivilege&quot;); if (!NtRaiseHardError) &#123; // handle the error FreeLibrary(hDLL); return 0; &#125; if (!RtlAdjustPrivilege) &#123; // handle the error FreeLibrary(hDLL); return 0; &#125; RtlAdjustPrivilege(0x13, TRUE, FALSE, &amp;nEn);//0x13 = SeShutdownPrivilege NtRaiseHardError(0xC000021A,0,0,0,OptionShutdownSystem,&amp;reResponse); &#125; return 1;&#125; vc代码在VS2010 SP1编译通过， Win7 SP1测试有效。","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"c++源码","slug":"c-源码","permalink":"https://goodhelp.gitee.io/tags/c-%E6%BA%90%E7%A0%81/"},{"name":"蓝屏使用方法","slug":"蓝屏使用方法","permalink":"https://goodhelp.gitee.io/tags/%E8%93%9D%E5%B1%8F%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"}]},{"title":"可实现维护通道的vbs脚本类","slug":"soft/可实现维护通道的vbs脚本类","date":"2021-09-11T14:19:22.000Z","updated":"2021-09-11T16:45:18.627Z","comments":true,"path":"page/2434381964/","link":"","permalink":"https://goodhelp.gitee.io/page/2434381964/","excerpt":"前言闲来无事，为了方便，用vbs写了一个类！ 别瞧不上vbs脚本语言，其实当你学习的语言越多，发现所有编程语言都是那么一回事，最终的目的都是完成某项功能，vbs的 好处就是可以使用系统的计事本直接编辑，不需要任何语言安装环境，python开源库是多，但却必须安装python的语言环境， c++等语言生成的程序功能是可以足够强大，但要立即增加修改功能却很麻烦(因为需要安装编程环境)！ vbs特别适合拿来即用，代码不对随时可以修改！就好比批处理虽然功能不强，windows却一直保留到现在！也许windows的激活 slmgr.vbs和office的激活ospp.vbs一直保留到现在的原因可能就是说明vbs还是有存在的道理的!如果你仔细看了这个vbs自定义 类，你就会发现vbs也可以实现很多功能！比如这个vbs类中的中止线程函数，所有语言实现，都是取得线程ID，然后发送中止线 程的消息，其实此自定义类就用了三句代码，这就是其他软件中的根据窗口关闭网吧广告的功能，也可以中止那些在任务管理器 中无法结束的进程！ 介绍vbs常用函数代码，包括一些特色函数，杀毒软件可能会报毒，使用notepad++等软件可直接查看源代码，未进行任何加密 最大的特色，可以让vbs使用windows api函数，api能办到的功能，vbs也能做到! 自定义vbs类的函数，见demo\\demo.vbs文件 软件架构lib目录的MyVbsClass.vbs和dynwrapx.dll为核心文件，即vbs自定义类 demo为示例代码， 维护通道是使用vbs自定义类写的网吧开机维护通道 虽然是明文方式写的vbs脚本，一样能实现如深蓝维护通道等类软件中的绝大部份功能，一样可以关闭网吧的广告及广告窗口! 安装教程","text":"前言闲来无事，为了方便，用vbs写了一个类！ 别瞧不上vbs脚本语言，其实当你学习的语言越多，发现所有编程语言都是那么一回事，最终的目的都是完成某项功能，vbs的 好处就是可以使用系统的计事本直接编辑，不需要任何语言安装环境，python开源库是多，但却必须安装python的语言环境， c++等语言生成的程序功能是可以足够强大，但要立即增加修改功能却很麻烦(因为需要安装编程环境)！ vbs特别适合拿来即用，代码不对随时可以修改！就好比批处理虽然功能不强，windows却一直保留到现在！也许windows的激活 slmgr.vbs和office的激活ospp.vbs一直保留到现在的原因可能就是说明vbs还是有存在的道理的!如果你仔细看了这个vbs自定义 类，你就会发现vbs也可以实现很多功能！比如这个vbs类中的中止线程函数，所有语言实现，都是取得线程ID，然后发送中止线 程的消息，其实此自定义类就用了三句代码，这就是其他软件中的根据窗口关闭网吧广告的功能，也可以中止那些在任务管理器 中无法结束的进程！ 介绍vbs常用函数代码，包括一些特色函数，杀毒软件可能会报毒，使用notepad++等软件可直接查看源代码，未进行任何加密 最大的特色，可以让vbs使用windows api函数，api能办到的功能，vbs也能做到! 自定义vbs类的函数，见demo\\demo.vbs文件 软件架构lib目录的MyVbsClass.vbs和dynwrapx.dll为核心文件，即vbs自定义类 demo为示例代码， 维护通道是使用vbs自定义类写的网吧开机维护通道 虽然是明文方式写的vbs脚本，一样能实现如深蓝维护通道等类软件中的绝大部份功能，一样可以关闭网吧的广告及广告窗口! 安装教程把lib目录复制一份新建一目录，引用lib中的MyVbsClass.vbs即可使用其全部函数，引用方法见demo\\demo.vbs仅适用于64位系统 当前实现功能‘call myfun.MakeLink(“罗技鼠标设置”,”G:\\常用软件\\罗技鼠标游戏驱动\\Rungame.exe”,””,”G:\\常用软件\\罗技鼠标游戏驱动\\48731.ico”) ‘创建桌面快捷方式‘call myfun.MakeUrl(“http://www.bnwin.com&quot;,&quot;百脑问&quot;,true) ‘收藏夹栏添加网址‘call myfun.SetHomepage(“https://www.baidu.com&quot;) ‘设置ie主页‘msgbox myfun.GetExePath(“C:\\Program Files\\Internet Explorer\\iexplore.exe”) ‘根据路径取目录‘msgbox myfun.IsExitFile(“c:\\abc.txt”) ‘判断文件是否存在‘msgbox myfun.IsExitDir(“c:\\abc”,true) ‘判断目录是否存在‘call myfun.MyCreateFolder(“c:\\abc\\1233\\dd”) ‘创建目录可多级‘call myfun.XCopy(“D:\\dump”,”d:\\456”,true) ‘拷目录 多级‘call myfun.CopyFile(“C:\\Windows\\win.ini”,”d:\\323\\aaa.txt”,true) ‘拷贝文件‘call myfun.DelFile(“c:\\abd\\123.txt”) ‘删除文件‘call myfun.DelDir(“c:\\abd&quot;) ‘删除目录‘Call myfun.Run(“””C:\\Program Files (x86)\\Internet Explorer\\iexplore.exe”” http://www.bnwin.com&quot;,false) ‘路径带有空格，要用引号把空格路径括起，会检测文件是否存在，不能用于执行dos命令‘msgbox myfun.ping(“192.168.0.1”) ‘ping是否在线‘MsgBox myfun.GetMac ‘取得网卡mac地址‘MsgBox myfun.GetIP ‘取得本机ip地址‘MsgBox myfun.GetComputerName ‘取得机器名‘MsgBox myfun.GetOS ‘取得操作系统是win7还是win10‘MsgBox myfun.X86orX64 ‘系统是64位还是32位‘call myfun.ReadBinary(“c:\\windows\\notepad.exe”,”d:\\123.txt”) ‘把文件生成16进制字符串文本文件‘call myfun.WriteBinary(“d:\\123.exe”,”d:\\123.txt”,true) ‘把16进制文本文件还原为可执行文件‘call myfun.Sleep(5) ‘延时5秒‘call myfun.ImportReg(“.\\reg.reg”) ‘导入注册表‘call myfun.RunBat(“.\\test.bat”) ‘运行批处理文件‘myfun.Runcmd “dir c:\\ &gt;c:\\1.txt” ‘运行dos命令‘call myfun.import(“d:\\abc.vbs”) ‘导入vbs文件‘call myfun.CloseProcess(“SunloginRemote.exe”) ‘关闭指定进程‘call myfun.IsProcess(“qq.exe”) ‘检查指定进程是否存在‘call myfun.IsProcessEx(“qq.exe|notepad.exe”) ‘指定指定列表进程是否存在‘call myfun.CloseProcessEx(“qq.exe|wechat.exe”) ‘结束进程列表‘call myfun.RegExpTest(“sdf|456”,”123456789”) ‘正则判断是否存在指定内容‘call myfun.KillWindow(“”,”计算机”) ‘关闭指定类名或标题的窗口‘call myfun.WriteReg(“HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Internet Explorer\\MAIN\\Start Page”,”https://www.baidu.com&quot;,&quot;&quot;) ‘写注册表值‘MsgBox myfun.ReadReg(“HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Internet Explorer\\MAIN\\Start Page”) ‘读注册表值‘call myfun.HideWindow(“Notepad”,””) ‘按类名或标题隐藏窗口 未关闭‘call myfun.KillThread(“Notepad”,””) ‘按类名或标题中止显示此窗口的线程 如果是单线程，程序则会退出 可用于关闭广告窗口‘call myfun.DownFile(“http://gh.api.99988866.xyz/github.com/Chuyu-Team/Dism-Multi-language/releases/download/v10.1.1001.10/Dism++10.1.1001.10_d4ba4eb035254b3326d6adc6638bc9c8daea7018.zip&quot;,&quot;d:\\dism.zip&quot;) ‘下载远程文件‘call myfun.SyncTime ‘同步时间‘MsgBox myfun.GetSysRunTime() ‘取得系统开机时间 关机时间 返回时间较长，可用于学习查询系统日志‘call myfun.log(“测试”) ‘写日志文件 日志文件在当前脚本下，以日期命名‘MsgBox myfun.IsSuperAdmin() ‘判断无盘是否有超级用户‘MsgBox myfun.FromUnixTime(“1630211522”,8) ‘unix时间转北京时间‘msgbox myfun.ToUnixTime(now, 8) ‘把当前时间转成unix时间‘myfun.WriteIni “节点”,”键名”,”值”,”d:\\123.ini” ‘写INI文件‘msgbox myfun.ReadIni(“节点”,”键名”,”默认值”,”d:\\123.ini”) ‘读ini文件‘call myfun.CreatLink(“d:\\pg”,”C:\\Program Files (x86)”) ‘’把C盘程序目录映射到D盘pg目录,访问D:\\pg相当于访问C:\\Program Files (x86)内容‘msgbox “系统运行了：”&amp;myfun.GetOsRunTime&amp;”分钟”‘call myfun.SysVolme ‘把系统音量调到最大‘call myfun.Depolicy(“禁止常用端口”) ‘创建本机安全策略禁止135 137 139 445 3389端口‘call myfun.CloseMonitor(2) ‘2关闭显示 -1打开显示器‘call myfun.RunAu3(“E:\\软件工程\\vbs\\demo\\monitor.au3”,false) ‘恢复显示器所有设置‘call myfun.RestMonitor() ‘恢复显示器所有设置 开源地址：https://gitee.com/goodhelp/vbs-code","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"原创软件","slug":"原创软件","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%9F%E5%88%9B%E8%BD%AF%E4%BB%B6/"},{"name":"开源项目","slug":"开源项目","permalink":"https://goodhelp.gitee.io/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"}]},{"title":"让电源键关机变重启","slug":"soft/让电源键关机变重启","date":"2021-05-18T13:37:03.000Z","updated":"2021-09-14T15:53:23.007Z","comments":true,"path":"page/1082310208/","link":"","permalink":"https://goodhelp.gitee.io/page/1082310208/","excerpt":"让电源键关机变重启 使用说明 注意：需要关闭无盘的闪电关机，开启闪电关机，本软件无效！ 功能：运行本工具，按电源键，或系统中点关机，会执行重启！总之就是不关机，关机就是重启，关机直接重启，关机会重启，说三遍! 适用范围：息屏挖矿，按电源键会关机，本软件作用就显现了!机器正在挖矿，显示器黑屏，总有顾客以为机器是关了的，去按电源键开机，这时机器就会关机。顾客就会以为这台机器有问题，明明按了开关键，结果机器没开起，有些会立马换一台机器，重复上面的操作。使用了本软件，按了电源键不会关机，直接变成重启，顾客不会置疑了，呼叫网管的次数少了! 下载地址","text":"让电源键关机变重启 使用说明 注意：需要关闭无盘的闪电关机，开启闪电关机，本软件无效！ 功能：运行本工具，按电源键，或系统中点关机，会执行重启！总之就是不关机，关机就是重启，关机直接重启，关机会重启，说三遍! 适用范围：息屏挖矿，按电源键会关机，本软件作用就显现了!机器正在挖矿，显示器黑屏，总有顾客以为机器是关了的，去按电源键开机，这时机器就会关机。顾客就会以为这台机器有问题，明明按了开关键，结果机器没开起，有些会立马换一台机器，重复上面的操作。使用了本软件，按了电源键不会关机，直接变成重启，顾客不会置疑了，呼叫网管的次数少了! 下载地址","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"原创软件","slug":"原创软件","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%9F%E5%88%9B%E8%BD%AF%E4%BB%B6/"},{"name":"关机重启","slug":"关机重启","permalink":"https://goodhelp.gitee.io/tags/%E5%85%B3%E6%9C%BA%E9%87%8D%E5%90%AF/"},{"name":"电源键","slug":"电源键","permalink":"https://goodhelp.gitee.io/tags/%E7%94%B5%E6%BA%90%E9%94%AE/"}]},{"title":"八圈9.5版关闭侧边栏工具","slug":"soft/八圈9-5版关闭侧边栏工具","date":"2019-10-12T13:58:27.000Z","updated":"2021-09-12T00:08:38.418Z","comments":true,"path":"page/3043345977/","link":"","permalink":"https://goodhelp.gitee.io/page/3043345977/","excerpt":"如果说8圈智能场所管理平台等，提高了网吧运营管理的效率，让整个管理流程更加便捷；那么8圈机器人，就是让整个运营管理更加智能化，降低人为因素造成的失误，在原有的基础上提高运营管理的准确性、安全性。 据李金平介绍，8圈机器人能够轻松解决困扰网吧业主的收银员不负责，收银员成本高，招聘难，员工不稳定，财务统计困难，身份证冒用现象频发等系列问题。 不仅如此，8圈机器人优势明显： 设置简单、操作方便，无需专人指导一点就会；全天候24小时工作，节省人工成本开支提高竞争力；在财务管理上，自助收银，机器人收入按班次自动汇总，当班收入掌上8圈随时可查，更安全；AI人脸识别，杜绝人证不一致。 9.5版去侧边栏下载地址: 点击开始下载","text":"如果说8圈智能场所管理平台等，提高了网吧运营管理的效率，让整个管理流程更加便捷；那么8圈机器人，就是让整个运营管理更加智能化，降低人为因素造成的失误，在原有的基础上提高运营管理的准确性、安全性。 据李金平介绍，8圈机器人能够轻松解决困扰网吧业主的收银员不负责，收银员成本高，招聘难，员工不稳定，财务统计困难，身份证冒用现象频发等系列问题。 不仅如此，8圈机器人优势明显： 设置简单、操作方便，无需专人指导一点就会；全天候24小时工作，节省人工成本开支提高竞争力；在财务管理上，自助收银，机器人收入按班次自动汇总，当班收入掌上8圈随时可查，更安全；AI人脸识别，杜绝人证不一致。 9.5版去侧边栏下载地址: 点击开始下载","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"八圈","slug":"八圈","permalink":"https://goodhelp.gitee.io/tags/%E5%85%AB%E5%9C%88/"},{"name":"原创软件","slug":"原创软件","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%9F%E5%88%9B%E8%BD%AF%E4%BB%B6/"}]},{"title":"显示器亮度，对比度，色温缩放调节，笔记本亮度调节AUTOIT源码","slug":"code/显示器亮度，对比度，色温缩放调节，笔记本亮度调节AUTOIT源码","date":"2019-10-11T04:37:00.000Z","updated":"2021-09-16T23:33:59.040Z","comments":true,"path":"page/365528154/","link":"","permalink":"https://goodhelp.gitee.io/page/365528154/","excerpt":"通过调用dxva2.dll文件，修改显示器的设置，和按显示器上的物理按钮效果一样，有效的解决显示器上按钮不好设置，按钮功能不明的问题，有些显示器不支持，如果你使用的无效果，说明你显示器不支持此调节功能!下载地址：源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;WinAPI.au3&gt;#include &lt;WinAPIFiles.au3&gt;#include &lt;WinAPIGdi.au3&gt;#include &lt;GUIConstantsEx.au3&gt;#include &lt;GuiSlider.au3&gt;#include &lt;Array.au3&gt;Opt(&quot;GUIOnEventMode&quot;, 1)$g_szVersion = &quot;RU1Y2-D59U9&quot;If WinExists($g_szVersion) Then ExitAutoItWinSetTitle($g_szVersion)Global Const $Dxva2 = DllOpen(&quot;Dxva2.dll&quot;)If @error Then Exit 1Global Const $tagSTRUCT = &quot;HANDLE hPhysicalMonitor;WCHAR szPhysicalMonitorDescription[128];&quot;Global Const $tag_MC_TIMING_REPORT = &quot;BYTE bTimingStatusByte; DWORD dwHorizontalFrequencyInHZ; DWORD dwVerticalFrequencyInHZ&quot;Global Const $tag_DISPLAY_BRIGHTNESS = &quot;byte ucDisplayPolicy; byte ucACBrightness; byte ucDCBrightness&quot;Global Const $IOCTL_VIDEO_QUERY_SUPPORTED_BRIGHTNESS = _WinAPI_IOCTL($FILE_DEVICE_VIDEO, 0x125, $METHOD_BUFFERED, $FILE_ANY_ACCESS)Global Const $IOCTL_VIDEO_QUERY_DISPLAY_BRIGHTNESS = _WinAPI_IOCTL($FILE_DEVICE_VIDEO, 0x126, $METHOD_BUFFERED, $FILE_ANY_ACCESS)Global Const $IOCTL_VIDEO_SET_DISPLAY_BRIGHTNESS = _WinAPI_IOCTL($FILE_DEVICE_VIDEO, 0x127, $METHOD_BUFFERED, $FILE_ANY_ACCESS)Global $idSlider1, $idSlider2, $idButton1, $idButton2, $idLabel1, $idLabel2Global $hMonitor, $brightness, $contrast, $switch1, $switch2, $VCPReplyGlobal $idLabel3, $idSlider3, $hDevice, $BRIGHTNESS_LCD_Array$hDevice = LCD()If Not @error Then LCD_Set($hDevice) If $hDevice Then _WinAPI_CloseHandle($hDevice) DllClose($Dxva2) ExitEndIf$hMonitor = _WinAPI_MonitorFromWindow(_WinAPI_GetDesktopWindow(), $MONITOR_DEFAULTTOPRIMARY) ;返回主显示器句柄$hMonitor = _GetPhysicalMonitorsFromHMONITOR($hMonitor) ;获取物理显示器句柄$StringLength = CapabilitiesRequestAndCapabilitiesReply($hMonitor)$Gui = GUICreate(&quot;显示器设置&quot;, 262, 220, -1, -1)GUISetOnEvent($GUI_EVENT_CLOSE, &quot;_exit&quot;)$idSlider1 = GUICtrlCreateSlider(10, 30, 240, 20, BitOR($TBS_TOOLTIPS, $TBS_AUTOTICKS))GUICtrlSetOnEvent($idSlider1, &quot;Brightness&quot;)GUICtrlSetLimit($idSlider1, 100)$idSlider2 = GUICtrlCreateSlider(10, 82, 240, 20, BitOR($TBS_TOOLTIPS, $TBS_AUTOTICKS))GUICtrlSetOnEvent($idSlider2, &quot;Contrast&quot;)GUICtrlSetLimit($idSlider2, 100)$idButton1 = GUICtrlCreateButton(&quot;宽屏切换&quot;, 16, 160, 85, 25)GUICtrlSetOnEvent($idButton1, &quot;Button1&quot;)$idButton2 = GUICtrlCreateButton(&quot;恢复默认&quot;, 158, 160, 85, 25)GUICtrlSetOnEvent($idButton2, &quot;Button2&quot;)$idLabel1 = GUICtrlCreateLabel(&quot; 亮度调节:不可用&quot;, 10, 10, 140, 20)$idLabel2 = GUICtrlCreateLabel(&quot;对比度调节:不可用&quot;, 10, 60, 140, 20)$Combo1 = GUICtrlCreateCombo(&quot;&quot;, 102, 120, 100, 25, 0x0003)GUICtrlSetOnEvent($Combo1, &quot;Color&quot;)GUICtrlCreateLabel(&quot;色温调节&quot;, 32, 124, 48, 20)_GUICtrlSlider_SetTipSide($idSlider1, $TBTS_TOP)_GUICtrlSlider_SetTipSide($idSlider2, $TBTS_TOP)If $StringLength &lt;&gt; &quot;&quot; Then $VCP_Array = Manage_vcp($StringLength) $VCPReply = _GetVCPFeatureAndVCPFeatureReply($hMonitor, 0x86) If $VCPReply[0] = 0 Then GUICtrlSetState($idButton1, $GUI_DISABLE) $brightness = _GetMonitorBrightness($hMonitor) ;获取监视器亮度 ConsoleWrite($brightness[1] &amp; @CRLF) $contrast = _GetMonitorContrast($hMonitor) ;获取监视器对比度 If $brightness[2] &lt;&gt; 0 Then $switch1 = True If $contrast[2] &lt;&gt; 0 Then $switch2 = True If $switch1 Then GUICtrlSetData($idSlider1, $brightness[1]) GUICtrlSetData($idLabel1, &quot;设置亮度:&quot; &amp; $brightness[1]) EndIf If $switch2 Then GUICtrlSetData($idSlider2, $contrast[1]) GUICtrlSetData($idLabel2, &quot;设置对比度:&quot; &amp; $contrast[1]) EndIf For $i = 0 To UBound($VCP_Array) - 1 If $VCP_Array[$i][0] = &quot;14&quot; Then If $VCP_Array[$i][1] &lt;&gt; &quot;&quot; Then $Color_Array = StringSplit($VCP_Array[$i][1], &quot; &quot;, 2) $Color_String = &quot;&quot; For $S = 0 To UBound($Color_Array) - 1 $temp = Select_Color($Color_Array[$S]) If $temp &lt;&gt; &quot;&quot; Then $Color_String &amp;= $temp &amp; &quot;|&quot; Next EndIf ExitLoop EndIf Next If $Color_String &lt;&gt; &quot;&quot; Then $VCPCode = _GetVCPFeatureAndVCPFeatureReply($hMonitor, 0x14) GUICtrlSetData($Combo1, $Color_String, Select_Color($VCPCode[1] - 1)) Else GUICtrlSetData($Combo1, &quot;不支持&quot;, &quot;不支持&quot;) GUICtrlSetState($Combo1, $GUI_DISABLE) EndIf GUISetState(@SW_SHOW, $Gui)Else WinSetTitle($Gui, &quot;&quot;, &quot;未发现DDC/CI&quot;) GUICtrlSetData($Combo1, &quot;不支持&quot;, &quot;不支持&quot;) GUICtrlSetState($idSlider1, $GUI_DISABLE) GUICtrlSetState($idSlider2, $GUI_DISABLE) GUICtrlSetState($idButton1, $GUI_DISABLE) GUICtrlSetState($Combo1, $GUI_DISABLE) GUISetState(@SW_SHOW, $Gui)EndIfWhile 1 Sleep(50)WEndFunc LCD() Local $iDevice $iDevice = _WinAPI_CreateFileEx(&quot;\\\\.\\LCD&quot;, $OPEN_EXISTING, $GENERIC_READ + $GENERIC_WRITE, $FILE_ANY_ACCESS, 0) Return (@error) ? (SetError(1, _WinAPI_GetLastErrorMessage(), False)) : ($iDevice)EndFunc ;==&gt;LCDFunc LCD_Set($iDevice) Local $brightness = DllStructCreate(&quot;BYTE[256]&quot;) Local $DISPLAY_BRIGHTNESS = DllStructCreate(&quot;BYTE[3]&quot;) $success = _WinAPI_DeviceIoControl($iDevice, $IOCTL_VIDEO_QUERY_SUPPORTED_BRIGHTNESS, Null, 0, DllStructGetPtr($brightness), 0xff) If $success = False Then Return $BRIGHTNESS_LCD_Array = Brightness_lcd(DllStructGetData($brightness, 1)) $success = _WinAPI_DeviceIoControl($iDevice, $IOCTL_VIDEO_QUERY_DISPLAY_BRIGHTNESS, Null, 0, DllStructGetPtr($DISPLAY_BRIGHTNESS), 0x03) If $success = False Then Return $DISPLAY_BRIGHTNESS_READ = Int(BinaryMid(DllStructGetData($DISPLAY_BRIGHTNESS, 1), 3, 1)) $Gui = GUICreate(&quot;内置LCD显示器&quot;, 262, 80, -1, -1) GUISetOnEvent($GUI_EVENT_CLOSE, &quot;_exit&quot;) $idSlider3 = GUICtrlCreateSlider(10, 30, 240, 20, BitOR($TBS_TOOLTIPS, $TBS_AUTOTICKS)) GUICtrlSetLimit($idSlider3, 100) $idLabel3 = GUICtrlCreateLabel(&quot; 亮度调节:&quot;, 10, 10, 140, 20) GUICtrlSetData($idSlider3, $DISPLAY_BRIGHTNESS_READ) GUICtrlSetData($idLabel3, &quot;设置亮度:&quot; &amp; $DISPLAY_BRIGHTNESS_READ) GUICtrlSetOnEvent($idSlider3, &quot;Brightness_set_lcd&quot;) GUISetState(@SW_SHOW, $Gui) WinSetTitle($Gui, &quot;&quot;, &quot;内置LCD显示器&quot;) While 1 Sleep(50) WEndEndFunc ;==&gt;LCD_SetFunc Brightness_set_lcd() Local $lcd_BRIGHTNESS, $DISPLAY_BRIGHTNESS, $success $lcd_BRIGHTNESS = GUICtrlRead($idSlider3) GUICtrlSetData($idLabel3, &quot;设置亮度:&quot; &amp; $lcd_BRIGHTNESS) For $i = 0 To UBound($BRIGHTNESS_LCD_Array) If $lcd_BRIGHTNESS &lt;= $BRIGHTNESS_LCD_Array[$i] Then $DISPLAY_BRIGHTNESS = DllStructCreate($tag_DISPLAY_BRIGHTNESS) DllStructSetData($DISPLAY_BRIGHTNESS, &quot;ucDisplayPolicy&quot;, 3) DllStructSetData($DISPLAY_BRIGHTNESS, &quot;ucACBrightness&quot;, $BRIGHTNESS_LCD_Array[$i]) DllStructSetData($DISPLAY_BRIGHTNESS, &quot;ucDCBrightness&quot;, $BRIGHTNESS_LCD_Array[$i]) $success = _WinAPI_DeviceIoControl($hDevice, $IOCTL_VIDEO_SET_DISPLAY_BRIGHTNESS, DllStructGetPtr($DISPLAY_BRIGHTNESS), DllStructGetSize($DISPLAY_BRIGHTNESS), Null, 0) If $success = False Then Return ExitLoop EndIf NextEndFunc ;==&gt;Brightness_set_lcdFunc Select_Color($iValue) Local $String If StringIsXDigit($iValue) Then $iValue = Dec($iValue) Switch $iValue Case 1 $String = &quot;sRGB&quot; Case 2 $String = &quot;原生显示&quot; Case 3 $String = &quot;4000K&quot; Case 4 $String = &quot;5000K&quot; Case 5 $String = &quot;6500K&quot; Case 6 $String = &quot;7500K&quot; Case 7 $String = &quot;8200K&quot; Case 8 $String = &quot;9300K&quot; Case 9 $String = &quot;10000K&quot; Case 10 $String = &quot;11500K&quot; Case 11 $String = &quot;User1&quot; Case 12 $String = &quot;User2&quot; Case 13 $String = &quot;User3&quot; Case Else EndSwitch Return $StringEndFunc ;==&gt;Select_ColorFunc Color() Local $iValue = GUICtrlRead($Combo1) Select Case $iValue = &quot;sRGB&quot; _SetVCPFeature($hMonitor, 0x14, 0x01) Case $iValue = &quot;原生显示&quot; _SetVCPFeature($hMonitor, 0x14, 0x02) Case $iValue = &quot;4000K&quot; _SetVCPFeature($hMonitor, 0x14, 0x03) Case $iValue = &quot;5000K&quot; _SetVCPFeature($hMonitor, 0x14, 0x04) Case $iValue = &quot;6500K&quot; _SetVCPFeature($hMonitor, 0x14, 0x05) Case $iValue = &quot;7500K&quot; _SetVCPFeature($hMonitor, 0x14, 0x06) Case $iValue = &quot;8200K&quot; _SetVCPFeature($hMonitor, 0x14, 0x07) Case $iValue = &quot;9300K&quot; _SetVCPFeature($hMonitor, 0x14, 0x08) Case $iValue = &quot;10000K&quot; _SetVCPFeature($hMonitor, 0x14, 0x09) Case $iValue = &quot;11500K&quot; _SetVCPFeature($hMonitor, 0x14, 0x0a) Case $iValue = &quot;User1&quot; _SetVCPFeature($hMonitor, 0x14, 0x0b) Case $iValue = &quot;User2&quot; _SetVCPFeature($hMonitor, 0x14, 0x0c) Case $iValue = &quot;User3&quot; _SetVCPFeature($hMonitor, 0x14, 0x0d) Case Else EndSelectEndFunc ;==&gt;ColorFunc Button1() Local $VCPCode If $switch1 And $switch2 Then $VCPCode = _GetVCPFeatureAndVCPFeatureReply($hMonitor, 0x86) ConsoleWrite($VCPCode[1] &amp; @CRLF) If $VCPCode[1] = 8 Then _SetVCPFeature($hMonitor, 0x86, 0x02) GUICtrlSetData($idButton1, &quot;窄屏&quot;) Else _SetVCPFeature($hMonitor, 0x86, 0x08) GUICtrlSetData($idButton1, &quot;宽屏&quot;) EndIf EndIfEndFunc ;==&gt;Button1Func Button2() GUICtrlSetData($idButton2, &quot;Reset..&quot;) Sleep(250) GUISetState(@SW_HIDE) If $switch1 Or $switch2 Then _RestoreMonitorFactoryDefaults($hMonitor) Sleep(1000) EndIf _DestroyPhysicalMonitor($hMonitor) ;关闭监视器句柄 DllClose($Dxva2) ExitEndFunc ;==&gt;Button2Func Brightness() If Not $switch1 Then Return GUICtrlSetData($idLabel1, &quot;设置亮度:&quot; &amp; GUICtrlRead($idSlider1)) _SetMonitorBrightness($hMonitor, GUICtrlRead($idSlider1))EndFunc ;==&gt;BrightnessFunc Contrast() If Not $switch2 Then Return GUICtrlSetData($idLabel2, &quot;设置对比度:&quot; &amp; GUICtrlRead($idSlider2)) _SetMonitorContrast($hMonitor, GUICtrlRead($idSlider2))EndFunc ;==&gt;ContrastFunc _GetMonitorBrightness(Const $h_monitor) Local Const $MinimumBrightness = DllStructCreate(&quot;dword_ptr&quot;) Local Const $CurrentBrightness = DllStructCreate(&quot;dword_ptr&quot;) Local Const $MaximumBrightness = DllStructCreate(&quot;dword_ptr&quot;) DllCall($Dxva2, &quot;bool&quot;, &quot;GetMonitorBrightness&quot;, _ &quot;handle&quot;, $h_monitor, _ &quot;ptr&quot;, DllStructGetPtr($MinimumBrightness), _ &quot;ptr&quot;, DllStructGetPtr($CurrentBrightness), _ &quot;ptr&quot;, DllStructGetPtr($MaximumBrightness)) If @error Then Return SetError(1, _WinAPI_GetLastErrorMessage(), False) Local Const $brightness[3] = [DllStructGetData($MinimumBrightness, 1), _ DllStructGetData($CurrentBrightness, 1), _ DllStructGetData($MaximumBrightness, 1)] Return $brightnessEndFunc ;==&gt;_GetMonitorBrightnessFunc _GetMonitorContrast(Const $h_monitor) Local Const $MinimumContrast = DllStructCreate(&quot;dword_ptr&quot;) Local Const $CurrentContrast = DllStructCreate(&quot;dword_ptr&quot;) Local Const $MaximumContrast = DllStructCreate(&quot;dword_ptr&quot;) DllCall($Dxva2, &quot;bool&quot;, &quot;GetMonitorContrast&quot;, _ &quot;handle&quot;, $h_monitor, _ &quot;ptr&quot;, DllStructGetPtr($MinimumContrast), _ &quot;ptr&quot;, DllStructGetPtr($CurrentContrast), _ &quot;ptr&quot;, DllStructGetPtr($MaximumContrast)) If @error Then Return SetError(1, _WinAPI_GetLastErrorMessage(), False) Local Const $contrast[3] = [DllStructGetData($MinimumContrast, 1), _ DllStructGetData($CurrentContrast, 1), _ DllStructGetData($MaximumContrast, 1)] Return $contrastEndFunc ;==&gt;_GetMonitorContrastFunc _SetMonitorBrightness(Const $h_monitor, Const $NewBrightness) DllCall($Dxva2, &quot;bool&quot;, &quot;SetMonitorBrightness&quot;, &quot;ptr&quot;, $h_monitor, &quot;dword&quot;, $NewBrightness) Return (@error ? SetError(1, _WinAPI_GetLastErrorMessage(), False) : True)EndFunc ;==&gt;_SetMonitorBrightnessFunc _SetMonitorContrast(Const $h_monitor, Const $contrast) DllCall($Dxva2, &quot;bool&quot;, &quot;SetMonitorContrast&quot;, &quot;ptr&quot;, $h_monitor, &quot;dword&quot;, $contrast) Return (@error ? SetError(1, _WinAPI_GetLastErrorMessage(), False) : True)EndFunc ;==&gt;_SetMonitorContrastFunc _GetPhysicalMonitorsFromHMONITOR(Const $pMonitor) Local $Number = DllStructCreate(&quot;DWORD&quot;) Local $i, $tagPhysical, $M = 1 $Ret = DllCall($Dxva2, &quot;bool&quot;, &quot;GetNumberOfPhysicalMonitorsFromHMONITOR&quot;, _ &quot;handle&quot;, $pMonitor, _ &quot;ptr&quot;, DllStructGetPtr($Number)) $NumberOfMonitors = DllStructGetData($Number, 1) For $i = 1 To $NumberOfMonitors $tagPhysical &amp;= $tagSTRUCT Next $MonitorArray = DllStructCreate($tagSTRUCT) $Ret = DllCall($Dxva2, &quot;bool&quot;, &quot;GetPhysicalMonitorsFromHMONITOR&quot;, _ &quot;handle&quot;, $pMonitor, _ &quot;DWORD&quot;, $NumberOfMonitors, _ &quot;ptr&quot;, DllStructGetPtr($MonitorArray)) Return DllStructGetData($MonitorArray, 1) ;返回第一个显示器句柄EndFunc ;==&gt;_GetPhysicalMonitorsFromHMONITORFunc CapabilitiesRequestAndCapabilitiesReply(Const $h_monitor) Local Const $tagStringLength = DllStructCreate(&quot;dword_ptr&quot;) DllCall($Dxva2, &quot;bool&quot;, &quot;GetCapabilitiesStringLength&quot;, &quot;handle&quot;, $h_monitor, &quot;ptr&quot;, DllStructGetPtr($tagStringLength)) Local Const $CapabilitiesStringLength = DllStructGetData($tagStringLength, 1) Local Const $CapabilitiesString = DllStructCreate(&quot;char[&quot; &amp; $CapabilitiesStringLength &amp; &#x27;]&#x27;) DllCall($Dxva2, &quot;bool&quot;, &quot;CapabilitiesRequestAndCapabilitiesReply&quot;, _ &quot;handle&quot;, $h_monitor, _ &quot;ptr&quot;, DllStructGetPtr($CapabilitiesString), _ &quot;dword&quot;, DllStructGetSize($CapabilitiesString)) Return (@error) ? (SetError(1, _WinAPI_GetLastErrorMessage(), False)) : (DllStructGetData($CapabilitiesString, 1))EndFunc ;==&gt;CapabilitiesRequestAndCapabilitiesReplyFunc _RestoreMonitorFactoryDefaults(Const $h_monitor) DllCall($Dxva2, &quot;bool&quot;, &quot;RestoreMonitorFactoryDefaults&quot;, &quot;ptr&quot;, $h_monitor) Return (@error) ? (SetError(1, _WinAPI_GetLastErrorMessage(), False)) : (True)EndFunc ;==&gt;_RestoreMonitorFactoryDefaultsFunc _SetVCPFeature(Const $h_monitor, Const $VCPCode, Const $NewValue) DllCall($Dxva2, &quot;bool&quot;, &quot;SetVCPFeature&quot;, _ &quot;handle&quot;, $h_monitor, _ &quot;byte&quot;, $VCPCode, _ &quot;dword&quot;, $NewValue) Return (@error) ? (SetError(1, _WinAPI_GetLastErrorMessage(), False)) : (True)EndFunc ;==&gt;_SetVCPFeatureFunc _GetVCPFeatureAndVCPFeatureReply(Const $h_monitor, Const $VCPCode) Local Const $CurrentValue = DllStructCreate(&quot;dword_ptr&quot;) Local Const $MaximumValue = DllStructCreate(&quot;dword_ptr&quot;) Local Const $VCPCodeType = DllStructCreate(&quot;dword_ptr&quot;) DllCall($Dxva2, &quot;bool&quot;, &quot;GetVCPFeatureAndVCPFeatureReply&quot;, _ &quot;handle&quot;, $h_monitor, _ &quot;byte&quot;, $VCPCode, _ &quot;ptr&quot;, DllStructGetPtr($VCPCodeType), _ &quot;ptr&quot;, DllStructGetPtr($CurrentValue), _ &quot;ptr&quot;, DllStructGetPtr($MaximumValue)) If @error Then Return SetError(1, _WinAPI_GetLastErrorMessage(), False) Local Const $VCPFeatureReply[3] = [DllStructGetData($VCPCodeType, 1), DllStructGetData($CurrentValue, 1), DllStructGetData($MaximumValue, 1)] Return $VCPFeatureReplyEndFunc ;==&gt;_GetVCPFeatureAndVCPFeatureReplyFunc Manage_vcp(Const $String) Local $Exp, $i, $tmp, $OUT_String $Exp = StringRegExp($String, &quot;(?&lt;=vcp\\()([A-Za-z0-9]&#123;2&#125;[\\)\\(]?\\s?)*(?=\\))&quot;, 2) If @error Then Return $Exp = StringRegExp($Exp[0], &quot;([0-9A-Fa-f]&#123;2&#125;)(\\(.+?\\))?&quot;, 4) If @error Then Return Local $Array[UBound($Exp)][2] For $i = 0 To UBound($Exp) - 1 $tmp = $Exp[$i] $Array[$i][0] = StringStripWS(StringLeft($tmp[0], 2), 8) $OUT_String = StringStripWS(StringTrimLeft($tmp[0], 2), 3) If $OUT_String &lt;&gt; &quot;&quot; Then $OUT_String = StringTrimLeft(StringTrimRight($OUT_String, 1), 1) $Array[$i][1] = $OUT_String EndIf Next Return $ArrayEndFunc ;==&gt;Manage_vcpFunc _DestroyPhysicalMonitor(Const $h_monitor) DllCall($Dxva2, &quot;bool&quot;, &quot;DestroyPhysicalMonitor&quot;, &quot;ptr&quot;, $h_monitor) Return (@error) ? (SetError(1, _WinAPI_GetLastErrorMessage(), False)) : (True)EndFunc ;==&gt;_DestroyPhysicalMonitorFunc Brightness_lcd(Const $BRIGHTNESS_Lcd) Local $BRIGHTNESS_String, $tmp, $i For $i = 1 To BinaryLen($BRIGHTNESS_Lcd) $tmp = Int(BinaryMid($BRIGHTNESS_Lcd, $i, 1)) If $i = 1 Then $BRIGHTNESS_String &amp;= $tmp &amp; &quot;;&quot; Else If $tmp = 0 Then ExitLoop $BRIGHTNESS_String &amp;= $tmp &amp; &quot;;&quot; EndIf Next Return StringSplit(StringTrimRight($BRIGHTNESS_String, 1), &quot;;&quot;, 2)EndFunc ;==&gt;Brightness_lcdFunc _exit() If $hDevice Then _WinAPI_CloseHandle($hDevice) _DestroyPhysicalMonitor($hMonitor) ;关闭监视器句柄 DllClose($Dxva2) ExitEndFunc ;==&gt;_exit","text":"通过调用dxva2.dll文件，修改显示器的设置，和按显示器上的物理按钮效果一样，有效的解决显示器上按钮不好设置，按钮功能不明的问题，有些显示器不支持，如果你使用的无效果，说明你显示器不支持此调节功能!下载地址：源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;WinAPI.au3&gt;#include &lt;WinAPIFiles.au3&gt;#include &lt;WinAPIGdi.au3&gt;#include &lt;GUIConstantsEx.au3&gt;#include &lt;GuiSlider.au3&gt;#include &lt;Array.au3&gt;Opt(&quot;GUIOnEventMode&quot;, 1)$g_szVersion = &quot;RU1Y2-D59U9&quot;If WinExists($g_szVersion) Then ExitAutoItWinSetTitle($g_szVersion)Global Const $Dxva2 = DllOpen(&quot;Dxva2.dll&quot;)If @error Then Exit 1Global Const $tagSTRUCT = &quot;HANDLE hPhysicalMonitor;WCHAR szPhysicalMonitorDescription[128];&quot;Global Const $tag_MC_TIMING_REPORT = &quot;BYTE bTimingStatusByte; DWORD dwHorizontalFrequencyInHZ; DWORD dwVerticalFrequencyInHZ&quot;Global Const $tag_DISPLAY_BRIGHTNESS = &quot;byte ucDisplayPolicy; byte ucACBrightness; byte ucDCBrightness&quot;Global Const $IOCTL_VIDEO_QUERY_SUPPORTED_BRIGHTNESS = _WinAPI_IOCTL($FILE_DEVICE_VIDEO, 0x125, $METHOD_BUFFERED, $FILE_ANY_ACCESS)Global Const $IOCTL_VIDEO_QUERY_DISPLAY_BRIGHTNESS = _WinAPI_IOCTL($FILE_DEVICE_VIDEO, 0x126, $METHOD_BUFFERED, $FILE_ANY_ACCESS)Global Const $IOCTL_VIDEO_SET_DISPLAY_BRIGHTNESS = _WinAPI_IOCTL($FILE_DEVICE_VIDEO, 0x127, $METHOD_BUFFERED, $FILE_ANY_ACCESS)Global $idSlider1, $idSlider2, $idButton1, $idButton2, $idLabel1, $idLabel2Global $hMonitor, $brightness, $contrast, $switch1, $switch2, $VCPReplyGlobal $idLabel3, $idSlider3, $hDevice, $BRIGHTNESS_LCD_Array$hDevice = LCD()If Not @error Then LCD_Set($hDevice) If $hDevice Then _WinAPI_CloseHandle($hDevice) DllClose($Dxva2) ExitEndIf$hMonitor = _WinAPI_MonitorFromWindow(_WinAPI_GetDesktopWindow(), $MONITOR_DEFAULTTOPRIMARY) ;返回主显示器句柄$hMonitor = _GetPhysicalMonitorsFromHMONITOR($hMonitor) ;获取物理显示器句柄$StringLength = CapabilitiesRequestAndCapabilitiesReply($hMonitor)$Gui = GUICreate(&quot;显示器设置&quot;, 262, 220, -1, -1)GUISetOnEvent($GUI_EVENT_CLOSE, &quot;_exit&quot;)$idSlider1 = GUICtrlCreateSlider(10, 30, 240, 20, BitOR($TBS_TOOLTIPS, $TBS_AUTOTICKS))GUICtrlSetOnEvent($idSlider1, &quot;Brightness&quot;)GUICtrlSetLimit($idSlider1, 100)$idSlider2 = GUICtrlCreateSlider(10, 82, 240, 20, BitOR($TBS_TOOLTIPS, $TBS_AUTOTICKS))GUICtrlSetOnEvent($idSlider2, &quot;Contrast&quot;)GUICtrlSetLimit($idSlider2, 100)$idButton1 = GUICtrlCreateButton(&quot;宽屏切换&quot;, 16, 160, 85, 25)GUICtrlSetOnEvent($idButton1, &quot;Button1&quot;)$idButton2 = GUICtrlCreateButton(&quot;恢复默认&quot;, 158, 160, 85, 25)GUICtrlSetOnEvent($idButton2, &quot;Button2&quot;)$idLabel1 = GUICtrlCreateLabel(&quot; 亮度调节:不可用&quot;, 10, 10, 140, 20)$idLabel2 = GUICtrlCreateLabel(&quot;对比度调节:不可用&quot;, 10, 60, 140, 20)$Combo1 = GUICtrlCreateCombo(&quot;&quot;, 102, 120, 100, 25, 0x0003)GUICtrlSetOnEvent($Combo1, &quot;Color&quot;)GUICtrlCreateLabel(&quot;色温调节&quot;, 32, 124, 48, 20)_GUICtrlSlider_SetTipSide($idSlider1, $TBTS_TOP)_GUICtrlSlider_SetTipSide($idSlider2, $TBTS_TOP)If $StringLength &lt;&gt; &quot;&quot; Then $VCP_Array = Manage_vcp($StringLength) $VCPReply = _GetVCPFeatureAndVCPFeatureReply($hMonitor, 0x86) If $VCPReply[0] = 0 Then GUICtrlSetState($idButton1, $GUI_DISABLE) $brightness = _GetMonitorBrightness($hMonitor) ;获取监视器亮度 ConsoleWrite($brightness[1] &amp; @CRLF) $contrast = _GetMonitorContrast($hMonitor) ;获取监视器对比度 If $brightness[2] &lt;&gt; 0 Then $switch1 = True If $contrast[2] &lt;&gt; 0 Then $switch2 = True If $switch1 Then GUICtrlSetData($idSlider1, $brightness[1]) GUICtrlSetData($idLabel1, &quot;设置亮度:&quot; &amp; $brightness[1]) EndIf If $switch2 Then GUICtrlSetData($idSlider2, $contrast[1]) GUICtrlSetData($idLabel2, &quot;设置对比度:&quot; &amp; $contrast[1]) EndIf For $i = 0 To UBound($VCP_Array) - 1 If $VCP_Array[$i][0] = &quot;14&quot; Then If $VCP_Array[$i][1] &lt;&gt; &quot;&quot; Then $Color_Array = StringSplit($VCP_Array[$i][1], &quot; &quot;, 2) $Color_String = &quot;&quot; For $S = 0 To UBound($Color_Array) - 1 $temp = Select_Color($Color_Array[$S]) If $temp &lt;&gt; &quot;&quot; Then $Color_String &amp;= $temp &amp; &quot;|&quot; Next EndIf ExitLoop EndIf Next If $Color_String &lt;&gt; &quot;&quot; Then $VCPCode = _GetVCPFeatureAndVCPFeatureReply($hMonitor, 0x14) GUICtrlSetData($Combo1, $Color_String, Select_Color($VCPCode[1] - 1)) Else GUICtrlSetData($Combo1, &quot;不支持&quot;, &quot;不支持&quot;) GUICtrlSetState($Combo1, $GUI_DISABLE) EndIf GUISetState(@SW_SHOW, $Gui)Else WinSetTitle($Gui, &quot;&quot;, &quot;未发现DDC/CI&quot;) GUICtrlSetData($Combo1, &quot;不支持&quot;, &quot;不支持&quot;) GUICtrlSetState($idSlider1, $GUI_DISABLE) GUICtrlSetState($idSlider2, $GUI_DISABLE) GUICtrlSetState($idButton1, $GUI_DISABLE) GUICtrlSetState($Combo1, $GUI_DISABLE) GUISetState(@SW_SHOW, $Gui)EndIfWhile 1 Sleep(50)WEndFunc LCD() Local $iDevice $iDevice = _WinAPI_CreateFileEx(&quot;\\\\.\\LCD&quot;, $OPEN_EXISTING, $GENERIC_READ + $GENERIC_WRITE, $FILE_ANY_ACCESS, 0) Return (@error) ? (SetError(1, _WinAPI_GetLastErrorMessage(), False)) : ($iDevice)EndFunc ;==&gt;LCDFunc LCD_Set($iDevice) Local $brightness = DllStructCreate(&quot;BYTE[256]&quot;) Local $DISPLAY_BRIGHTNESS = DllStructCreate(&quot;BYTE[3]&quot;) $success = _WinAPI_DeviceIoControl($iDevice, $IOCTL_VIDEO_QUERY_SUPPORTED_BRIGHTNESS, Null, 0, DllStructGetPtr($brightness), 0xff) If $success = False Then Return $BRIGHTNESS_LCD_Array = Brightness_lcd(DllStructGetData($brightness, 1)) $success = _WinAPI_DeviceIoControl($iDevice, $IOCTL_VIDEO_QUERY_DISPLAY_BRIGHTNESS, Null, 0, DllStructGetPtr($DISPLAY_BRIGHTNESS), 0x03) If $success = False Then Return $DISPLAY_BRIGHTNESS_READ = Int(BinaryMid(DllStructGetData($DISPLAY_BRIGHTNESS, 1), 3, 1)) $Gui = GUICreate(&quot;内置LCD显示器&quot;, 262, 80, -1, -1) GUISetOnEvent($GUI_EVENT_CLOSE, &quot;_exit&quot;) $idSlider3 = GUICtrlCreateSlider(10, 30, 240, 20, BitOR($TBS_TOOLTIPS, $TBS_AUTOTICKS)) GUICtrlSetLimit($idSlider3, 100) $idLabel3 = GUICtrlCreateLabel(&quot; 亮度调节:&quot;, 10, 10, 140, 20) GUICtrlSetData($idSlider3, $DISPLAY_BRIGHTNESS_READ) GUICtrlSetData($idLabel3, &quot;设置亮度:&quot; &amp; $DISPLAY_BRIGHTNESS_READ) GUICtrlSetOnEvent($idSlider3, &quot;Brightness_set_lcd&quot;) GUISetState(@SW_SHOW, $Gui) WinSetTitle($Gui, &quot;&quot;, &quot;内置LCD显示器&quot;) While 1 Sleep(50) WEndEndFunc ;==&gt;LCD_SetFunc Brightness_set_lcd() Local $lcd_BRIGHTNESS, $DISPLAY_BRIGHTNESS, $success $lcd_BRIGHTNESS = GUICtrlRead($idSlider3) GUICtrlSetData($idLabel3, &quot;设置亮度:&quot; &amp; $lcd_BRIGHTNESS) For $i = 0 To UBound($BRIGHTNESS_LCD_Array) If $lcd_BRIGHTNESS &lt;= $BRIGHTNESS_LCD_Array[$i] Then $DISPLAY_BRIGHTNESS = DllStructCreate($tag_DISPLAY_BRIGHTNESS) DllStructSetData($DISPLAY_BRIGHTNESS, &quot;ucDisplayPolicy&quot;, 3) DllStructSetData($DISPLAY_BRIGHTNESS, &quot;ucACBrightness&quot;, $BRIGHTNESS_LCD_Array[$i]) DllStructSetData($DISPLAY_BRIGHTNESS, &quot;ucDCBrightness&quot;, $BRIGHTNESS_LCD_Array[$i]) $success = _WinAPI_DeviceIoControl($hDevice, $IOCTL_VIDEO_SET_DISPLAY_BRIGHTNESS, DllStructGetPtr($DISPLAY_BRIGHTNESS), DllStructGetSize($DISPLAY_BRIGHTNESS), Null, 0) If $success = False Then Return ExitLoop EndIf NextEndFunc ;==&gt;Brightness_set_lcdFunc Select_Color($iValue) Local $String If StringIsXDigit($iValue) Then $iValue = Dec($iValue) Switch $iValue Case 1 $String = &quot;sRGB&quot; Case 2 $String = &quot;原生显示&quot; Case 3 $String = &quot;4000K&quot; Case 4 $String = &quot;5000K&quot; Case 5 $String = &quot;6500K&quot; Case 6 $String = &quot;7500K&quot; Case 7 $String = &quot;8200K&quot; Case 8 $String = &quot;9300K&quot; Case 9 $String = &quot;10000K&quot; Case 10 $String = &quot;11500K&quot; Case 11 $String = &quot;User1&quot; Case 12 $String = &quot;User2&quot; Case 13 $String = &quot;User3&quot; Case Else EndSwitch Return $StringEndFunc ;==&gt;Select_ColorFunc Color() Local $iValue = GUICtrlRead($Combo1) Select Case $iValue = &quot;sRGB&quot; _SetVCPFeature($hMonitor, 0x14, 0x01) Case $iValue = &quot;原生显示&quot; _SetVCPFeature($hMonitor, 0x14, 0x02) Case $iValue = &quot;4000K&quot; _SetVCPFeature($hMonitor, 0x14, 0x03) Case $iValue = &quot;5000K&quot; _SetVCPFeature($hMonitor, 0x14, 0x04) Case $iValue = &quot;6500K&quot; _SetVCPFeature($hMonitor, 0x14, 0x05) Case $iValue = &quot;7500K&quot; _SetVCPFeature($hMonitor, 0x14, 0x06) Case $iValue = &quot;8200K&quot; _SetVCPFeature($hMonitor, 0x14, 0x07) Case $iValue = &quot;9300K&quot; _SetVCPFeature($hMonitor, 0x14, 0x08) Case $iValue = &quot;10000K&quot; _SetVCPFeature($hMonitor, 0x14, 0x09) Case $iValue = &quot;11500K&quot; _SetVCPFeature($hMonitor, 0x14, 0x0a) Case $iValue = &quot;User1&quot; _SetVCPFeature($hMonitor, 0x14, 0x0b) Case $iValue = &quot;User2&quot; _SetVCPFeature($hMonitor, 0x14, 0x0c) Case $iValue = &quot;User3&quot; _SetVCPFeature($hMonitor, 0x14, 0x0d) Case Else EndSelectEndFunc ;==&gt;ColorFunc Button1() Local $VCPCode If $switch1 And $switch2 Then $VCPCode = _GetVCPFeatureAndVCPFeatureReply($hMonitor, 0x86) ConsoleWrite($VCPCode[1] &amp; @CRLF) If $VCPCode[1] = 8 Then _SetVCPFeature($hMonitor, 0x86, 0x02) GUICtrlSetData($idButton1, &quot;窄屏&quot;) Else _SetVCPFeature($hMonitor, 0x86, 0x08) GUICtrlSetData($idButton1, &quot;宽屏&quot;) EndIf EndIfEndFunc ;==&gt;Button1Func Button2() GUICtrlSetData($idButton2, &quot;Reset..&quot;) Sleep(250) GUISetState(@SW_HIDE) If $switch1 Or $switch2 Then _RestoreMonitorFactoryDefaults($hMonitor) Sleep(1000) EndIf _DestroyPhysicalMonitor($hMonitor) ;关闭监视器句柄 DllClose($Dxva2) ExitEndFunc ;==&gt;Button2Func Brightness() If Not $switch1 Then Return GUICtrlSetData($idLabel1, &quot;设置亮度:&quot; &amp; GUICtrlRead($idSlider1)) _SetMonitorBrightness($hMonitor, GUICtrlRead($idSlider1))EndFunc ;==&gt;BrightnessFunc Contrast() If Not $switch2 Then Return GUICtrlSetData($idLabel2, &quot;设置对比度:&quot; &amp; GUICtrlRead($idSlider2)) _SetMonitorContrast($hMonitor, GUICtrlRead($idSlider2))EndFunc ;==&gt;ContrastFunc _GetMonitorBrightness(Const $h_monitor) Local Const $MinimumBrightness = DllStructCreate(&quot;dword_ptr&quot;) Local Const $CurrentBrightness = DllStructCreate(&quot;dword_ptr&quot;) Local Const $MaximumBrightness = DllStructCreate(&quot;dword_ptr&quot;) DllCall($Dxva2, &quot;bool&quot;, &quot;GetMonitorBrightness&quot;, _ &quot;handle&quot;, $h_monitor, _ &quot;ptr&quot;, DllStructGetPtr($MinimumBrightness), _ &quot;ptr&quot;, DllStructGetPtr($CurrentBrightness), _ &quot;ptr&quot;, DllStructGetPtr($MaximumBrightness)) If @error Then Return SetError(1, _WinAPI_GetLastErrorMessage(), False) Local Const $brightness[3] = [DllStructGetData($MinimumBrightness, 1), _ DllStructGetData($CurrentBrightness, 1), _ DllStructGetData($MaximumBrightness, 1)] Return $brightnessEndFunc ;==&gt;_GetMonitorBrightnessFunc _GetMonitorContrast(Const $h_monitor) Local Const $MinimumContrast = DllStructCreate(&quot;dword_ptr&quot;) Local Const $CurrentContrast = DllStructCreate(&quot;dword_ptr&quot;) Local Const $MaximumContrast = DllStructCreate(&quot;dword_ptr&quot;) DllCall($Dxva2, &quot;bool&quot;, &quot;GetMonitorContrast&quot;, _ &quot;handle&quot;, $h_monitor, _ &quot;ptr&quot;, DllStructGetPtr($MinimumContrast), _ &quot;ptr&quot;, DllStructGetPtr($CurrentContrast), _ &quot;ptr&quot;, DllStructGetPtr($MaximumContrast)) If @error Then Return SetError(1, _WinAPI_GetLastErrorMessage(), False) Local Const $contrast[3] = [DllStructGetData($MinimumContrast, 1), _ DllStructGetData($CurrentContrast, 1), _ DllStructGetData($MaximumContrast, 1)] Return $contrastEndFunc ;==&gt;_GetMonitorContrastFunc _SetMonitorBrightness(Const $h_monitor, Const $NewBrightness) DllCall($Dxva2, &quot;bool&quot;, &quot;SetMonitorBrightness&quot;, &quot;ptr&quot;, $h_monitor, &quot;dword&quot;, $NewBrightness) Return (@error ? SetError(1, _WinAPI_GetLastErrorMessage(), False) : True)EndFunc ;==&gt;_SetMonitorBrightnessFunc _SetMonitorContrast(Const $h_monitor, Const $contrast) DllCall($Dxva2, &quot;bool&quot;, &quot;SetMonitorContrast&quot;, &quot;ptr&quot;, $h_monitor, &quot;dword&quot;, $contrast) Return (@error ? SetError(1, _WinAPI_GetLastErrorMessage(), False) : True)EndFunc ;==&gt;_SetMonitorContrastFunc _GetPhysicalMonitorsFromHMONITOR(Const $pMonitor) Local $Number = DllStructCreate(&quot;DWORD&quot;) Local $i, $tagPhysical, $M = 1 $Ret = DllCall($Dxva2, &quot;bool&quot;, &quot;GetNumberOfPhysicalMonitorsFromHMONITOR&quot;, _ &quot;handle&quot;, $pMonitor, _ &quot;ptr&quot;, DllStructGetPtr($Number)) $NumberOfMonitors = DllStructGetData($Number, 1) For $i = 1 To $NumberOfMonitors $tagPhysical &amp;= $tagSTRUCT Next $MonitorArray = DllStructCreate($tagSTRUCT) $Ret = DllCall($Dxva2, &quot;bool&quot;, &quot;GetPhysicalMonitorsFromHMONITOR&quot;, _ &quot;handle&quot;, $pMonitor, _ &quot;DWORD&quot;, $NumberOfMonitors, _ &quot;ptr&quot;, DllStructGetPtr($MonitorArray)) Return DllStructGetData($MonitorArray, 1) ;返回第一个显示器句柄EndFunc ;==&gt;_GetPhysicalMonitorsFromHMONITORFunc CapabilitiesRequestAndCapabilitiesReply(Const $h_monitor) Local Const $tagStringLength = DllStructCreate(&quot;dword_ptr&quot;) DllCall($Dxva2, &quot;bool&quot;, &quot;GetCapabilitiesStringLength&quot;, &quot;handle&quot;, $h_monitor, &quot;ptr&quot;, DllStructGetPtr($tagStringLength)) Local Const $CapabilitiesStringLength = DllStructGetData($tagStringLength, 1) Local Const $CapabilitiesString = DllStructCreate(&quot;char[&quot; &amp; $CapabilitiesStringLength &amp; &#x27;]&#x27;) DllCall($Dxva2, &quot;bool&quot;, &quot;CapabilitiesRequestAndCapabilitiesReply&quot;, _ &quot;handle&quot;, $h_monitor, _ &quot;ptr&quot;, DllStructGetPtr($CapabilitiesString), _ &quot;dword&quot;, DllStructGetSize($CapabilitiesString)) Return (@error) ? (SetError(1, _WinAPI_GetLastErrorMessage(), False)) : (DllStructGetData($CapabilitiesString, 1))EndFunc ;==&gt;CapabilitiesRequestAndCapabilitiesReplyFunc _RestoreMonitorFactoryDefaults(Const $h_monitor) DllCall($Dxva2, &quot;bool&quot;, &quot;RestoreMonitorFactoryDefaults&quot;, &quot;ptr&quot;, $h_monitor) Return (@error) ? (SetError(1, _WinAPI_GetLastErrorMessage(), False)) : (True)EndFunc ;==&gt;_RestoreMonitorFactoryDefaultsFunc _SetVCPFeature(Const $h_monitor, Const $VCPCode, Const $NewValue) DllCall($Dxva2, &quot;bool&quot;, &quot;SetVCPFeature&quot;, _ &quot;handle&quot;, $h_monitor, _ &quot;byte&quot;, $VCPCode, _ &quot;dword&quot;, $NewValue) Return (@error) ? (SetError(1, _WinAPI_GetLastErrorMessage(), False)) : (True)EndFunc ;==&gt;_SetVCPFeatureFunc _GetVCPFeatureAndVCPFeatureReply(Const $h_monitor, Const $VCPCode) Local Const $CurrentValue = DllStructCreate(&quot;dword_ptr&quot;) Local Const $MaximumValue = DllStructCreate(&quot;dword_ptr&quot;) Local Const $VCPCodeType = DllStructCreate(&quot;dword_ptr&quot;) DllCall($Dxva2, &quot;bool&quot;, &quot;GetVCPFeatureAndVCPFeatureReply&quot;, _ &quot;handle&quot;, $h_monitor, _ &quot;byte&quot;, $VCPCode, _ &quot;ptr&quot;, DllStructGetPtr($VCPCodeType), _ &quot;ptr&quot;, DllStructGetPtr($CurrentValue), _ &quot;ptr&quot;, DllStructGetPtr($MaximumValue)) If @error Then Return SetError(1, _WinAPI_GetLastErrorMessage(), False) Local Const $VCPFeatureReply[3] = [DllStructGetData($VCPCodeType, 1), DllStructGetData($CurrentValue, 1), DllStructGetData($MaximumValue, 1)] Return $VCPFeatureReplyEndFunc ;==&gt;_GetVCPFeatureAndVCPFeatureReplyFunc Manage_vcp(Const $String) Local $Exp, $i, $tmp, $OUT_String $Exp = StringRegExp($String, &quot;(?&lt;=vcp\\()([A-Za-z0-9]&#123;2&#125;[\\)\\(]?\\s?)*(?=\\))&quot;, 2) If @error Then Return $Exp = StringRegExp($Exp[0], &quot;([0-9A-Fa-f]&#123;2&#125;)(\\(.+?\\))?&quot;, 4) If @error Then Return Local $Array[UBound($Exp)][2] For $i = 0 To UBound($Exp) - 1 $tmp = $Exp[$i] $Array[$i][0] = StringStripWS(StringLeft($tmp[0], 2), 8) $OUT_String = StringStripWS(StringTrimLeft($tmp[0], 2), 3) If $OUT_String &lt;&gt; &quot;&quot; Then $OUT_String = StringTrimLeft(StringTrimRight($OUT_String, 1), 1) $Array[$i][1] = $OUT_String EndIf Next Return $ArrayEndFunc ;==&gt;Manage_vcpFunc _DestroyPhysicalMonitor(Const $h_monitor) DllCall($Dxva2, &quot;bool&quot;, &quot;DestroyPhysicalMonitor&quot;, &quot;ptr&quot;, $h_monitor) Return (@error) ? (SetError(1, _WinAPI_GetLastErrorMessage(), False)) : (True)EndFunc ;==&gt;_DestroyPhysicalMonitorFunc Brightness_lcd(Const $BRIGHTNESS_Lcd) Local $BRIGHTNESS_String, $tmp, $i For $i = 1 To BinaryLen($BRIGHTNESS_Lcd) $tmp = Int(BinaryMid($BRIGHTNESS_Lcd, $i, 1)) If $i = 1 Then $BRIGHTNESS_String &amp;= $tmp &amp; &quot;;&quot; Else If $tmp = 0 Then ExitLoop $BRIGHTNESS_String &amp;= $tmp &amp; &quot;;&quot; EndIf Next Return StringSplit(StringTrimRight($BRIGHTNESS_String, 1), &quot;;&quot;, 2)EndFunc ;==&gt;Brightness_lcdFunc _exit() If $hDevice Then _WinAPI_CloseHandle($hDevice) _DestroyPhysicalMonitor($hMonitor) ;关闭监视器句柄 DllClose($Dxva2) ExitEndFunc ;==&gt;_exit","categories":[{"name":"源码","slug":"code","permalink":"https://goodhelp.gitee.io/categories/code/"}],"tags":[{"name":"autoit源码","slug":"autoit源码","permalink":"https://goodhelp.gitee.io/tags/autoit%E6%BA%90%E7%A0%81/"},{"name":"dxva2","slug":"dxva2","permalink":"https://goodhelp.gitee.io/tags/dxva2/"},{"name":"显示器设置","slug":"显示器设置","permalink":"https://goodhelp.gitee.io/tags/%E6%98%BE%E7%A4%BA%E5%99%A8%E8%AE%BE%E7%BD%AE/"}],"author":"百脑问"},{"title":"网吧耳麦助手－设置主音量_麦克风音量_麦克风加强级别","slug":"soft/网吧耳麦助手－设置主音量-麦克风音量-麦克风加强级别","date":"2019-03-21T13:56:27.000Z","updated":"2021-09-11T16:44:49.058Z","comments":true,"path":"page/2203111529/","link":"","permalink":"https://goodhelp.gitee.io/page/2203111529/","excerpt":"网吧耳麦助手是一款自动设置系统主音量，自动设置麦克风音量，自动设置麦克风加强级别，波形显示麦克风音量的软件！ 可使用命令行运行，命令行无界面，运行后自动退出参数一 为 允许/禁止所有声音效果 0为允许 1为禁止参数二 为 设置主音量 取值范围为0-100参数三 为 设置麦克风音量 取值范围为0-100参数四 为 设置麦克风加强 取值范围为 0 10 20 30 40例如 autosound.exe 1 100 100 30表示禁止所有声音效果，主音量设置为100 麦克风音量为100 麦克风加强为30 运行本软件，看下面的麦克风检测的动态条，就可知麦克风是否正常! 本软件支持win7 win10 不支持winxp 下载地址 链接: https://pan.baidu.com/s/1b5KCsTAPffjVh40SyUUuVw 提取码: sek6 复制这段内容后打开百度网盘手机App，操作更方便哦 解压密码 bnwin.com 加强版自动检测上报麦克风是否损坏，方便及时更换麦克风损坏的耳机，不用一台一台的试耳麦是否完好!","text":"网吧耳麦助手是一款自动设置系统主音量，自动设置麦克风音量，自动设置麦克风加强级别，波形显示麦克风音量的软件！ 可使用命令行运行，命令行无界面，运行后自动退出参数一 为 允许/禁止所有声音效果 0为允许 1为禁止参数二 为 设置主音量 取值范围为0-100参数三 为 设置麦克风音量 取值范围为0-100参数四 为 设置麦克风加强 取值范围为 0 10 20 30 40例如 autosound.exe 1 100 100 30表示禁止所有声音效果，主音量设置为100 麦克风音量为100 麦克风加强为30 运行本软件，看下面的麦克风检测的动态条，就可知麦克风是否正常! 本软件支持win7 win10 不支持winxp 下载地址 链接: https://pan.baidu.com/s/1b5KCsTAPffjVh40SyUUuVw 提取码: sek6 复制这段内容后打开百度网盘手机App，操作更方便哦 解压密码 bnwin.com 加强版自动检测上报麦克风是否损坏，方便及时更换麦克风损坏的耳机，不用一台一台的试耳麦是否完好!","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"原创软件","slug":"原创软件","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%9F%E5%88%9B%E8%BD%AF%E4%BB%B6/"}]},{"title":"8圈计费系统9.5独立挂机_充值_换机_下机等功能工具","slug":"soft/8圈计费系统9-5独立挂机-充值-换机-下机等功能工具","date":"2019-03-21T13:53:41.000Z","updated":"2021-09-12T00:08:21.788Z","comments":true,"path":"page/1816476569/","link":"","permalink":"https://goodhelp.gitee.io/page/1816476569/","excerpt":"8圈计费系统独立挂机\\充值\\换机\\下机等功能工具适用于8圈 9.5版 2019-03-24 新增参数二支持 参数二为1，按8圈计费原生方式显示，为空或其他值，则直接显示功能界面! 如 8圈挂机.exe 1 1 表示按8圈计费原生方式显示下机!而 8圈挂机.exe 1 则直接显示下机界面，不会有8圈的主界面! 如 8圈挂机.exe 0 1 则按8圈计费原生方式显示挂机 参数 1 下机参数 2 换机参数 3 呼叫参数 4 充值参数 5 去上网参数 6 商城参数 7 聊天参数 8 修改密码参数 9 包时不加参数或其他值 挂机 下载地址:点我开始下载","text":"8圈计费系统独立挂机\\充值\\换机\\下机等功能工具适用于8圈 9.5版 2019-03-24 新增参数二支持 参数二为1，按8圈计费原生方式显示，为空或其他值，则直接显示功能界面! 如 8圈挂机.exe 1 1 表示按8圈计费原生方式显示下机!而 8圈挂机.exe 1 则直接显示下机界面，不会有8圈的主界面! 如 8圈挂机.exe 0 1 则按8圈计费原生方式显示挂机 参数 1 下机参数 2 换机参数 3 呼叫参数 4 充值参数 5 去上网参数 6 商城参数 7 聊天参数 8 修改密码参数 9 包时不加参数或其他值 挂机 下载地址:点我开始下载","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"八圈","slug":"八圈","permalink":"https://goodhelp.gitee.io/tags/%E5%85%AB%E5%9C%88/"},{"name":"原创软件","slug":"原创软件","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%9F%E5%88%9B%E8%BD%AF%E4%BB%B6/"}]},{"title":"单机游戏死亡阴影aardio内存修改器源码","slug":"code/单机游戏死亡阴影aardio内存修改器源码","date":"2018-10-26T14:11:47.000Z","updated":"2021-09-17T00:26:01.058Z","comments":true,"path":"page/2891878490/","link":"","permalink":"https://goodhelp.gitee.io/page/2891878490/","excerpt":"aardio是专用于桌面软件快速开发的新一代混合型编程语言 – 具有动态语言轻便、灵活的特性，而且又可以同时支持静态类型开发，象静态语言那样使用。aardio可以直接支持原生DLL，即使是外部EXE进程中的函数，也可以使用一句代码声明为普通的aardio函数对象( 原生call支持 )，aardio支持非常多的标准调用约定，例如 stdcall，cdecl，thiscall，fastcall，regparm(n) 等调用约定都可以支持。aardio虽然小，但支持的接口很丰富、可以支持com静态动态双接口，象VBS一样原生支持com对象。 以下是使用aardio写的修改单机游戏死亡阴影3的游戏数据源码，仅供学习aardio使用!新建一个aardio代码文件，把下面代码复制到代码文件中，就可直接运行! 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import win.ui;import process; //声明变量hero3,jzvar hero3,jz;hero3=process.find(&quot;Heroes3.exe&quot;)if(hero3)&#123; //把基址赋值给jz变量 jz=hero3.readNumber(0x82B0BC) &#125;else &#123; win.msgbox(&quot;请您先运行游戏&quot;)&#125;/*DSG&#123;&#123;*/var winform = win.form(text=&quot;死亡阴影修改器&quot;;left=300;right=440;bottom=247;max=false;parent=...)winform.add(button=&#123;cls=&quot;button&quot;;text=&quot;修改&quot;;left=33;top=202;right=105;bottom=237;z=1&#125;)/*&#125;&#125;*/ bqm = &#123; &quot;水晶：&quot;;&quot;水银：&quot;;&quot;石头：&quot;;&quot;金钱：&quot;;&quot;木材：&quot;;&quot;宝石：&quot;;&quot;硫磺：&quot; &#125;py = &#123; sj=Oxac;sy=Oxa0;st=Oxa4;jq=0xb4;mc=Ox9c;bs=0xb0;lh=Oxa8 &#125;bjk = &#123; &quot;sj&quot;;&quot;sy&quot;;&quot;st&quot;;&quot;jq&quot;;&quot;mc&quot;;&quot;bs&quot;;&quot;lh&quot; &#125;tab = &#123; &#125; winform.button.oncommand = function(id,event)&#123; for(i=1;#bjk;1)&#123; if(winform[&quot;edit_&quot;+bjk[ i ]].text != 0&amp;&amp;winform[&quot;edit_&quot;+bjk[ i ]].text !=&quot;&quot;)&#123; table.push(tab,bjk[ i ]) &#125; &#125; for(i=1;#tab;1)&#123; //win.msgbox(winform[&quot;edit_&quot;+tab[ i ]].text,&quot;死亡阴影修改器&quot;) hero3.writeNumber(jz+py[tab[ i ]],winform[&quot;edit_&quot;+tab[ i ]].text) &#125; tab=&#123;&#125;&#125; var topp = 5var bott = 25for(i=1;#bqm;1)&#123; winform.add( [&quot;edit_&quot;+bjk[ i ]]=&#123;num=1;bottom=bott;text=&quot;999&quot;;left=50;top=topp;z=3;right=114;edge=1;cls=&quot;edit&quot; &#125;) winform.add( [&quot;static&quot;+i]=&#123; bottom=bott;right=52;left=16;text=bqm[ i ];top=topp;z=1;transparent=1;cls=&quot;static&quot;&#125;) topp+=24 bott+=24&#125; winform.show() win.loopMessage(); 其中的基址0x82B0BC，及偏移量为什么是这个数据，就需要你使用ce自己分析了! 对aardio不熟悉可以查看在线手机 aardio使用手册","text":"aardio是专用于桌面软件快速开发的新一代混合型编程语言 – 具有动态语言轻便、灵活的特性，而且又可以同时支持静态类型开发，象静态语言那样使用。aardio可以直接支持原生DLL，即使是外部EXE进程中的函数，也可以使用一句代码声明为普通的aardio函数对象( 原生call支持 )，aardio支持非常多的标准调用约定，例如 stdcall，cdecl，thiscall，fastcall，regparm(n) 等调用约定都可以支持。aardio虽然小，但支持的接口很丰富、可以支持com静态动态双接口，象VBS一样原生支持com对象。 以下是使用aardio写的修改单机游戏死亡阴影3的游戏数据源码，仅供学习aardio使用!新建一个aardio代码文件，把下面代码复制到代码文件中，就可直接运行! 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import win.ui;import process; //声明变量hero3,jzvar hero3,jz;hero3=process.find(&quot;Heroes3.exe&quot;)if(hero3)&#123; //把基址赋值给jz变量 jz=hero3.readNumber(0x82B0BC) &#125;else &#123; win.msgbox(&quot;请您先运行游戏&quot;)&#125;/*DSG&#123;&#123;*/var winform = win.form(text=&quot;死亡阴影修改器&quot;;left=300;right=440;bottom=247;max=false;parent=...)winform.add(button=&#123;cls=&quot;button&quot;;text=&quot;修改&quot;;left=33;top=202;right=105;bottom=237;z=1&#125;)/*&#125;&#125;*/ bqm = &#123; &quot;水晶：&quot;;&quot;水银：&quot;;&quot;石头：&quot;;&quot;金钱：&quot;;&quot;木材：&quot;;&quot;宝石：&quot;;&quot;硫磺：&quot; &#125;py = &#123; sj=Oxac;sy=Oxa0;st=Oxa4;jq=0xb4;mc=Ox9c;bs=0xb0;lh=Oxa8 &#125;bjk = &#123; &quot;sj&quot;;&quot;sy&quot;;&quot;st&quot;;&quot;jq&quot;;&quot;mc&quot;;&quot;bs&quot;;&quot;lh&quot; &#125;tab = &#123; &#125; winform.button.oncommand = function(id,event)&#123; for(i=1;#bjk;1)&#123; if(winform[&quot;edit_&quot;+bjk[ i ]].text != 0&amp;&amp;winform[&quot;edit_&quot;+bjk[ i ]].text !=&quot;&quot;)&#123; table.push(tab,bjk[ i ]) &#125; &#125; for(i=1;#tab;1)&#123; //win.msgbox(winform[&quot;edit_&quot;+tab[ i ]].text,&quot;死亡阴影修改器&quot;) hero3.writeNumber(jz+py[tab[ i ]],winform[&quot;edit_&quot;+tab[ i ]].text) &#125; tab=&#123;&#125;&#125; var topp = 5var bott = 25for(i=1;#bqm;1)&#123; winform.add( [&quot;edit_&quot;+bjk[ i ]]=&#123;num=1;bottom=bott;text=&quot;999&quot;;left=50;top=topp;z=3;right=114;edge=1;cls=&quot;edit&quot; &#125;) winform.add( [&quot;static&quot;+i]=&#123; bottom=bott;right=52;left=16;text=bqm[ i ];top=topp;z=1;transparent=1;cls=&quot;static&quot;&#125;) topp+=24 bott+=24&#125; winform.show() win.loopMessage(); 其中的基址0x82B0BC，及偏移量为什么是这个数据，就需要你使用ce自己分析了! 对aardio不熟悉可以查看在线手机 aardio使用手册","categories":[{"name":"源码","slug":"code","permalink":"https://goodhelp.gitee.io/categories/code/"}],"tags":[{"name":"基址查找方法","slug":"基址查找方法","permalink":"https://goodhelp.gitee.io/tags/%E5%9F%BA%E5%9D%80%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95/"},{"name":"aardio源码","slug":"aardio源码","permalink":"https://goodhelp.gitee.io/tags/aardio%E6%BA%90%E7%A0%81/"},{"name":"内存修改方法","slug":"内存修改方法","permalink":"https://goodhelp.gitee.io/tags/%E5%86%85%E5%AD%98%E4%BF%AE%E6%94%B9%E6%96%B9%E6%B3%95/"}],"author":"百脑问"},{"title":"aardio的listview自绘源代码","slug":"code/aardio的listview自绘源代码","date":"2018-10-26T13:52:47.000Z","updated":"2021-09-16T23:54:09.750Z","comments":true,"path":"page/1712950360/","link":"","permalink":"https://goodhelp.gitee.io/page/1712950360/","excerpt":"aardio的listview自绘源代码，在aardio新建一代码文件，复制下面的代码到代码文件中，直接运行就可以看到效果! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import win.ui;/*DSG&#123;&#123;*/var winform = win.form(text=&quot;listview中添加进度条演示&quot;;right=945;bottom=474)winform.add(button=&#123;cls=&quot;button&quot;;text=&quot;(点击这里随机更新一次第二行的进度值)&quot;;left=0;top=392;right=944;bottom=472;font=LOGFONT(h=-21);z=2&#125;;流程编辑框=&#123;cls=&quot;listview&quot;;left=0;top=0;right=946;bottom=384;edge=1;font=LOGFONT(h=-19;name=&#x27;FontAwesome&#x27;);fullRow=1;vscroll=1;z=1&#125;)/*&#125;&#125;*/ import win.fontAwesome;import win.graphics;import win.imageList;var imagelist = win.imageList(5,34);winform.流程编辑框.setImageList( imagelist,1/*_LVSIL_SMALL*/ );winform.流程编辑框.insertColumn(&quot;&quot;,30,,0x2/*_LVCFMT_CENTER*/) winform.流程编辑框.insertColumn(&quot;中断&quot;,80,,0x2/*_LVCFMT_CENTER*/) winform.流程编辑框.insertColumn(&quot;备注&quot;,300,,0x0/*_LVCFMT_LEFT*/) winform.流程编辑框.insertColumn(&quot;功能&quot;,100,,0x0/*_LVCFMT_LEFT*/)winform.流程编辑框.insertColumn(&quot;参数&quot;,300,,0x0/*_LVCFMT_LEFT*/)winform.流程编辑框.insertColumn(&quot;&quot;,30,,0x2/*_LVCFMT_CENTER*/)winform.流程编辑框.insertColumn(&quot;&quot;,1,,0x2/*_LVCFMT_CENTER*/)//自适应列宽度 winform.流程编辑框.adjust = function(cx,cy)&#123; winform.流程编辑框.fillParent(5/*列序号*/);&#125; winform.流程编辑框.addItem( &#123; text=&#123;&#x27;\\uF00c&#x27;;&#x27;\\uF1db&#x27;;30;&quot;直线运动&quot;;&#x27;&#123;[&quot;速度&quot;]=1000;[&quot;模式&quot;]=&quot;相对运动&quot;;[&quot;距离&quot;]=&quot;2380&quot;;[&quot;是否等待&quot;]=&quot;否&quot;;&#125;&#x27;;&#x27;\\uF01a&#x27;&#125; &#125; )winform.流程编辑框.addItem( &#123; text=&#123;&#x27;\\uF00d&#x27;;&#x27;\\uF05e&#x27;;100;&quot;直线运动&quot;;&#x27;&#123;[&quot;速度&quot;]=300;[&quot;模式&quot;]=&quot;连续运动&quot;;[&quot;是否等待&quot;]=&quot;是&quot;;&#125;&#x27;;&#x27;\\uF01a&#x27;&#125; &#125; )winform.流程编辑框.addItem( &#123; text=&#123;&#x27;\\uF00c&#x27;;&#x27;\\uF1db&#x27;;200;&quot;调用子程序&quot;;&#x27;&#123;[&quot;调用子程序&quot;]=&quot;连续读传感器&quot;;[&quot;是否等待&quot;]=&quot;是&quot;;&#125;&#x27;;&#x27;\\uF01a&#x27;&#125; &#125; )winform.流程编辑框.addItem( &#123; text=&#123;&#x27;\\uF00c&#x27;;&#x27;\\uF1db&#x27;;50;&quot;调用子程序&quot;;&#x27;&#123;[&quot;调用子程序&quot;]=&quot;回字形对准算法&quot;;[&quot;是否等待&quot;]=&quot;是&quot;;&#125;&#x27;;&#x27;\\uF01a&#x27;&#125; &#125; )winform.流程编辑框.addItem( &#123; text=&#123;&#x27;\\uF00c&#x27;;&#x27;\\uF1db&#x27;;150;&quot;直线运动&quot;;&#x27;&#123;[&quot;速度&quot;]=1000;[&quot;模式&quot;]=&quot;相对运动&quot;;[&quot;距离&quot;]=&quot;2380&quot;;[&quot;是否等待&quot;]=&quot;否&quot;;&#125;&#x27;;&#x27;\\uF01a&#x27;&#125; &#125; )winform.流程编辑框.addItem( &#123; text=&#123;&#x27;\\uF00c&#x27;;&#x27;\\uF1db&#x27;;120;&quot;直线运动&quot;;&#x27;&#123;[&quot;速度&quot;]=1000;[&quot;模式&quot;]=&quot;相对运动&quot;;[&quot;距离&quot;]=&quot;2380&quot;;[&quot;是否等待&quot;]=&quot;否&quot;;&#125;&#x27;;&#x27;\\uF01a&#x27;&#125; &#125; )winform.流程编辑框.addItem( &#123; text=&#123;&#x27;\\uF00d&#x27;;&#x27;\\uF05e&#x27;;10;&quot;直线运动&quot;;&#x27;&#123;[&quot;速度&quot;]=300;[&quot;模式&quot;]=&quot;连续运动&quot;;[&quot;是否等待&quot;]=&quot;是&quot;;&#125;&#x27;;&#x27;\\uF01a&#x27;&#125; &#125; )winform.流程编辑框.addItem( &#123; text=&#123;&#x27;\\uF00c&#x27;;&#x27;\\uF1db&#x27;;70;&quot;调用子程序&quot;;&#x27;&#123;[&quot;调用子程序&quot;]=&quot;连续读传感器&quot;;[&quot;是否等待&quot;]=&quot;是&quot;;&#125;&#x27;;&#x27;\\uF01a&#x27;&#125; &#125; )winform.流程编辑框.addItem( &#123; text=&#123;&#x27;\\uF00c&#x27;;&#x27;\\uF1db&#x27;;260;&quot;调用子程序&quot;;&#x27;&#123;[&quot;调用子程序&quot;]=&quot;回字形对准算法&quot;;[&quot;是否等待&quot;]=&quot;是&quot;;&#125;&#x27;;&#x27;\\uF01a&#x27;&#125; &#125; )winform.流程编辑框.addItem( &#123; text=&#123;&#x27;\\uF00c&#x27;;&#x27;\\uF1db&#x27;;130;&quot;直线运动&quot;;&#x27;&#123;[&quot;速度&quot;]=1000;[&quot;模式&quot;]=&quot;相对运动&quot;;[&quot;距离&quot;]=&quot;2380&quot;;[&quot;是否等待&quot;]=&quot;否&quot;;&#125;&#x27;;&#x27;\\uF01a&#x27;&#125; &#125; ) //自绘winform.流程编辑框.onnotify = function(id,code,ptr)&#123; if( code == 0xFFFFFFF4/*_NM_CUSTOMDRAW*/ )&#123; var lvcd = winform.流程编辑框.getNotifyCustomDraw(code,ptr); if( lvcd.nmcd.dwDrawStage == 0x10001/*_CDDS_ITEMPREPAINT*/) return 0x20/*_CDRF_NOTIFYSUBITEMDRAW*/ elseif( lvcd.nmcd.dwDrawStage == 1/*_CDDS_PREPAINT*/ )&#123; return 0x20/*_CDRF_NOTIFYITEMDRAW*/; &#125; elseif( lvcd.nmcd.dwDrawStage == ( 0x10001/*_CDDS_ITEMPREPAINT*/ | 0x20000/*_CDDS_SUBITEM*/) )&#123; //注意这里 iSubItem 的索引自0开始( 其他函数通常自1开始 ) var cvs = win.graphics.canvas(); // 创建一个画布 cvs.fromHDC(lvcd.nmcd.hdc); // 传入 hDC var nItem = lvcd.nmcd.dwItemSpec+1; var nSubItem = lvcd.iSubItem; var rc = owner.getItemRect(nItem,nSubItem); if(nSubItem == 3)&#123; var RetRc = ::RECT(rc.left+1,rc.top+6,rc.right-tonumber(owner.getItemText(nItem,3)),rc.bottom-6); cvs.brush.color = 0x00ff00; cvs.fillRect(RetRc) &#125; cvs.pen.color = 0xebebeb; // 定义画笔的颜色 cvs.drawEdge(rc); lvcd.update() cvs.destroy(); return 0/*_CDRF_DODEFAULT*/ &#125; &#125;&#125;//演示更新进度winform.button.oncommand = function(id,event)&#123; winform.流程编辑框.setItemText(tostring(math.random(10,280)),2,3);&#125; winform.show() win.loopMessage();","text":"aardio的listview自绘源代码，在aardio新建一代码文件，复制下面的代码到代码文件中，直接运行就可以看到效果! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import win.ui;/*DSG&#123;&#123;*/var winform = win.form(text=&quot;listview中添加进度条演示&quot;;right=945;bottom=474)winform.add(button=&#123;cls=&quot;button&quot;;text=&quot;(点击这里随机更新一次第二行的进度值)&quot;;left=0;top=392;right=944;bottom=472;font=LOGFONT(h=-21);z=2&#125;;流程编辑框=&#123;cls=&quot;listview&quot;;left=0;top=0;right=946;bottom=384;edge=1;font=LOGFONT(h=-19;name=&#x27;FontAwesome&#x27;);fullRow=1;vscroll=1;z=1&#125;)/*&#125;&#125;*/ import win.fontAwesome;import win.graphics;import win.imageList;var imagelist = win.imageList(5,34);winform.流程编辑框.setImageList( imagelist,1/*_LVSIL_SMALL*/ );winform.流程编辑框.insertColumn(&quot;&quot;,30,,0x2/*_LVCFMT_CENTER*/) winform.流程编辑框.insertColumn(&quot;中断&quot;,80,,0x2/*_LVCFMT_CENTER*/) winform.流程编辑框.insertColumn(&quot;备注&quot;,300,,0x0/*_LVCFMT_LEFT*/) winform.流程编辑框.insertColumn(&quot;功能&quot;,100,,0x0/*_LVCFMT_LEFT*/)winform.流程编辑框.insertColumn(&quot;参数&quot;,300,,0x0/*_LVCFMT_LEFT*/)winform.流程编辑框.insertColumn(&quot;&quot;,30,,0x2/*_LVCFMT_CENTER*/)winform.流程编辑框.insertColumn(&quot;&quot;,1,,0x2/*_LVCFMT_CENTER*/)//自适应列宽度 winform.流程编辑框.adjust = function(cx,cy)&#123; winform.流程编辑框.fillParent(5/*列序号*/);&#125; winform.流程编辑框.addItem( &#123; text=&#123;&#x27;\\uF00c&#x27;;&#x27;\\uF1db&#x27;;30;&quot;直线运动&quot;;&#x27;&#123;[&quot;速度&quot;]=1000;[&quot;模式&quot;]=&quot;相对运动&quot;;[&quot;距离&quot;]=&quot;2380&quot;;[&quot;是否等待&quot;]=&quot;否&quot;;&#125;&#x27;;&#x27;\\uF01a&#x27;&#125; &#125; )winform.流程编辑框.addItem( &#123; text=&#123;&#x27;\\uF00d&#x27;;&#x27;\\uF05e&#x27;;100;&quot;直线运动&quot;;&#x27;&#123;[&quot;速度&quot;]=300;[&quot;模式&quot;]=&quot;连续运动&quot;;[&quot;是否等待&quot;]=&quot;是&quot;;&#125;&#x27;;&#x27;\\uF01a&#x27;&#125; &#125; )winform.流程编辑框.addItem( &#123; text=&#123;&#x27;\\uF00c&#x27;;&#x27;\\uF1db&#x27;;200;&quot;调用子程序&quot;;&#x27;&#123;[&quot;调用子程序&quot;]=&quot;连续读传感器&quot;;[&quot;是否等待&quot;]=&quot;是&quot;;&#125;&#x27;;&#x27;\\uF01a&#x27;&#125; &#125; )winform.流程编辑框.addItem( &#123; text=&#123;&#x27;\\uF00c&#x27;;&#x27;\\uF1db&#x27;;50;&quot;调用子程序&quot;;&#x27;&#123;[&quot;调用子程序&quot;]=&quot;回字形对准算法&quot;;[&quot;是否等待&quot;]=&quot;是&quot;;&#125;&#x27;;&#x27;\\uF01a&#x27;&#125; &#125; )winform.流程编辑框.addItem( &#123; text=&#123;&#x27;\\uF00c&#x27;;&#x27;\\uF1db&#x27;;150;&quot;直线运动&quot;;&#x27;&#123;[&quot;速度&quot;]=1000;[&quot;模式&quot;]=&quot;相对运动&quot;;[&quot;距离&quot;]=&quot;2380&quot;;[&quot;是否等待&quot;]=&quot;否&quot;;&#125;&#x27;;&#x27;\\uF01a&#x27;&#125; &#125; )winform.流程编辑框.addItem( &#123; text=&#123;&#x27;\\uF00c&#x27;;&#x27;\\uF1db&#x27;;120;&quot;直线运动&quot;;&#x27;&#123;[&quot;速度&quot;]=1000;[&quot;模式&quot;]=&quot;相对运动&quot;;[&quot;距离&quot;]=&quot;2380&quot;;[&quot;是否等待&quot;]=&quot;否&quot;;&#125;&#x27;;&#x27;\\uF01a&#x27;&#125; &#125; )winform.流程编辑框.addItem( &#123; text=&#123;&#x27;\\uF00d&#x27;;&#x27;\\uF05e&#x27;;10;&quot;直线运动&quot;;&#x27;&#123;[&quot;速度&quot;]=300;[&quot;模式&quot;]=&quot;连续运动&quot;;[&quot;是否等待&quot;]=&quot;是&quot;;&#125;&#x27;;&#x27;\\uF01a&#x27;&#125; &#125; )winform.流程编辑框.addItem( &#123; text=&#123;&#x27;\\uF00c&#x27;;&#x27;\\uF1db&#x27;;70;&quot;调用子程序&quot;;&#x27;&#123;[&quot;调用子程序&quot;]=&quot;连续读传感器&quot;;[&quot;是否等待&quot;]=&quot;是&quot;;&#125;&#x27;;&#x27;\\uF01a&#x27;&#125; &#125; )winform.流程编辑框.addItem( &#123; text=&#123;&#x27;\\uF00c&#x27;;&#x27;\\uF1db&#x27;;260;&quot;调用子程序&quot;;&#x27;&#123;[&quot;调用子程序&quot;]=&quot;回字形对准算法&quot;;[&quot;是否等待&quot;]=&quot;是&quot;;&#125;&#x27;;&#x27;\\uF01a&#x27;&#125; &#125; )winform.流程编辑框.addItem( &#123; text=&#123;&#x27;\\uF00c&#x27;;&#x27;\\uF1db&#x27;;130;&quot;直线运动&quot;;&#x27;&#123;[&quot;速度&quot;]=1000;[&quot;模式&quot;]=&quot;相对运动&quot;;[&quot;距离&quot;]=&quot;2380&quot;;[&quot;是否等待&quot;]=&quot;否&quot;;&#125;&#x27;;&#x27;\\uF01a&#x27;&#125; &#125; ) //自绘winform.流程编辑框.onnotify = function(id,code,ptr)&#123; if( code == 0xFFFFFFF4/*_NM_CUSTOMDRAW*/ )&#123; var lvcd = winform.流程编辑框.getNotifyCustomDraw(code,ptr); if( lvcd.nmcd.dwDrawStage == 0x10001/*_CDDS_ITEMPREPAINT*/) return 0x20/*_CDRF_NOTIFYSUBITEMDRAW*/ elseif( lvcd.nmcd.dwDrawStage == 1/*_CDDS_PREPAINT*/ )&#123; return 0x20/*_CDRF_NOTIFYITEMDRAW*/; &#125; elseif( lvcd.nmcd.dwDrawStage == ( 0x10001/*_CDDS_ITEMPREPAINT*/ | 0x20000/*_CDDS_SUBITEM*/) )&#123; //注意这里 iSubItem 的索引自0开始( 其他函数通常自1开始 ) var cvs = win.graphics.canvas(); // 创建一个画布 cvs.fromHDC(lvcd.nmcd.hdc); // 传入 hDC var nItem = lvcd.nmcd.dwItemSpec+1; var nSubItem = lvcd.iSubItem; var rc = owner.getItemRect(nItem,nSubItem); if(nSubItem == 3)&#123; var RetRc = ::RECT(rc.left+1,rc.top+6,rc.right-tonumber(owner.getItemText(nItem,3)),rc.bottom-6); cvs.brush.color = 0x00ff00; cvs.fillRect(RetRc) &#125; cvs.pen.color = 0xebebeb; // 定义画笔的颜色 cvs.drawEdge(rc); lvcd.update() cvs.destroy(); return 0/*_CDRF_DODEFAULT*/ &#125; &#125;&#125;//演示更新进度winform.button.oncommand = function(id,event)&#123; winform.流程编辑框.setItemText(tostring(math.random(10,280)),2,3);&#125; winform.show() win.loopMessage();","categories":[{"name":"源码","slug":"code","permalink":"https://goodhelp.gitee.io/categories/code/"}],"tags":[{"name":"aardio源码","slug":"aardio源码","permalink":"https://goodhelp.gitee.io/tags/aardio%E6%BA%90%E7%A0%81/"},{"name":"listview使用方法","slug":"listview使用方法","permalink":"https://goodhelp.gitee.io/tags/listview%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"}],"author":"百脑问"},{"title":"ApacheBench(ab)服务器负载压力测试软件","slug":"soft/ApacheBench-ab-服务器负载压力测试软件","date":"2018-10-21T04:06:41.000Z","updated":"2021-09-11T16:44:22.736Z","comments":true,"path":"page/2797625853/","link":"","permalink":"https://goodhelp.gitee.io/page/2797625853/","excerpt":"ApacheBench(ab)使用简介服务器负载太大而影响程序效率也是很常见的，Apache服务器自带有一个叫AB(ApacheBench)的工具，在bin目录下。使用这个轻巧的工具我们可以对服务器进行负载测试， 基本用法: ab -n 全部请求数 -c 并发数 测试url例；ab -n 100 -c 50 http://192.168.22.150:8088/gfmis/login http://19.104.10.79:8080/gfmis/login例:ab -n 1000 -c 50 http://www.abc.com/a.php 得到结果类似于(后面颜色字为中文翻译): Server Software: Apache/2.0.55Server Hostname: localhostServer Port: 80 Document Path: /1.phpDocument Length: 82522 bytes #请求文档大小 Concurrency Level: 50 #并发数Time taken for tests: 92.76140 seconds #全部请求完成耗时Complete requests: 10000 #全部请求数Failed requests: 1974 #失败的请求(Connect: 0, Length: 1974, Exceptions: 0)Write errors: 0Total transferred: 827019400 bytes #总传输大小HTML transferred: 825219400 bytesRequests per second: 108.61 [#/sec] (mean) #每秒请求数(平均)Time per request: 460.381 [ms] (mean) #每次并发请求时间(所有并发)Time per request: 9.208 [ms] (mean, across all concurrent requests) #每一请求时间(并发平均)Transfer rate: 8771.39 [Kbytes/sec] received #传输速率 Connection Times (ms) #连接时间min mean [+/-sd] median maxConnect(#连接): 0 0 2.1 0 46Processing(#处理): 31 458 94.7 438 1078Waiting(#等待): 15 437 87.5 422 938Total: 31 458 94.7 438 1078 其它参数:","text":"ApacheBench(ab)使用简介服务器负载太大而影响程序效率也是很常见的，Apache服务器自带有一个叫AB(ApacheBench)的工具，在bin目录下。使用这个轻巧的工具我们可以对服务器进行负载测试， 基本用法: ab -n 全部请求数 -c 并发数 测试url例；ab -n 100 -c 50 http://192.168.22.150:8088/gfmis/login http://19.104.10.79:8080/gfmis/login例:ab -n 1000 -c 50 http://www.abc.com/a.php 得到结果类似于(后面颜色字为中文翻译): Server Software: Apache/2.0.55Server Hostname: localhostServer Port: 80 Document Path: /1.phpDocument Length: 82522 bytes #请求文档大小 Concurrency Level: 50 #并发数Time taken for tests: 92.76140 seconds #全部请求完成耗时Complete requests: 10000 #全部请求数Failed requests: 1974 #失败的请求(Connect: 0, Length: 1974, Exceptions: 0)Write errors: 0Total transferred: 827019400 bytes #总传输大小HTML transferred: 825219400 bytesRequests per second: 108.61 [#/sec] (mean) #每秒请求数(平均)Time per request: 460.381 [ms] (mean) #每次并发请求时间(所有并发)Time per request: 9.208 [ms] (mean, across all concurrent requests) #每一请求时间(并发平均)Transfer rate: 8771.39 [Kbytes/sec] received #传输速率 Connection Times (ms) #连接时间min mean [+/-sd] median maxConnect(#连接): 0 0 2.1 0 46Processing(#处理): 31 458 94.7 438 1078Waiting(#等待): 15 437 87.5 422 938Total: 31 458 94.7 438 1078 其它参数: -n requests 全部请求数-c concurrency 并发数-t timelimit 最长等待回应时间-p postfile POST数据文件-T content-type POST Content-type-v verbosity How much troubleshooting info to print-w Print out results in HTML tables-i Use HEAD instead of GET-x attributes String to insert as table attributes-y attributes String to insert as tr attributes-z attributes String to insert as td or th attributes-C attribute 加入cookie, eg. ‘Apache=1234. (repeatable)-H attribute 加入http头, eg. ‘Accept-Encoding: gzip’Inserted after all normal header lines. (repeatable)-A attribute http验证,分隔传递用户名及密码-P attribute Add Basic Proxy Authentication, the attributesare a colon separated username and password.-X proxy:port 代理服务器-V 查看ab版本-k Use HTTP KeepAlive feature-d Do not show percentiles served table.-S Do not show confidence estimators and warnings.-g filename Output collected data to gnuplot format file.-e filename Output CSV file with percentages served-h Display usage information (this message) 看实际使用效果图下载地址： 链接: https://pan.baidu.com/s/1NjFciN9BRjwNGsVaiySrJg 提取码: 22be 解压密码 bnwin.com","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"精品软件","slug":"精品软件","permalink":"https://goodhelp.gitee.io/tags/%E7%B2%BE%E5%93%81%E8%BD%AF%E4%BB%B6/"}]},{"title":"TeamViewer_resetclientID重置PC端id源码","slug":"code/TeamViewer-resetclientID重置PC端id源码","date":"2018-06-13T05:10:50.000Z","updated":"2021-09-16T23:32:02.651Z","comments":true,"path":"page/2135361570/","link":"","permalink":"https://goodhelp.gitee.io/page/2135361570/","excerpt":"如何重置TeamViewer的ID？我们先来了解一下什么是WMI,WMI有一组API。我们不管使用VBScript、PowerShell脚本还是利用C#的来访问WMI的类库，都是因为WMI向外暴露的一组API。这些API是在系统安装WMI模块的时候安装的，通过他们我们能够能拿到我们想要的类。WMI有一个存储库。尽管WMI的多数实例数据都不存储在WMI中，但是WMI确实有一个存储库，用来存放提供程序提供的类信息，或者称为类的蓝图或者Schema。WMI有一个Service。WMI总是能够响应用户的访问，那是因为它有一个一直运行的Windows服务，名字叫Winmgmt。停止这个服务，所有对WMI的操作都将没有反应。WMI是可扩展的。人人都知道WMI能干很多事情，读取本机硬盘信息、读取远程计算机的用户信息、读取域用户信息等等。基本上，你能想到的获取或者更改资源的操作，它都能干。可谓吃得少，干得多。它为什么这么能干呢？这基于WMI的可扩展性。WMI对资源的操作，不是它自己实现了什么方法，而完全取决于向它注册的提供程序。 如何重置TeamViewer的ID？重置TeamViewer的ID的原理是什么，请看下面的源码Autoit3源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460; ; ----------------------------------------------------------------------------; ; ----------------------------------------------------------------------------#RequireAdmin; ----------------------------------------------------------------------------; ; ----------------------------------------------------------------------------Func _ProcessGetName($i_PID) If Not ProcessExists($i_PID) Then SetError(1) Return &#x27;&#x27; EndIf Local $a_Processes = ProcessList() If Not @error Then For $i = 1 To $a_Processes[0][0] If $a_Processes[$i][1] = $i_PID Then Return $a_Processes[$i][0] Next EndIf SetError(1) Return &#x27;&#x27;EndFuncFunc _ProcessGetPriority($vProcess) Local $i_PID = ProcessExists($vProcess) If Not $i_PID Then SetError(1) Return -1 EndIf Local $hDLL = DllOpen(&#x27;kernel32.dll&#x27;) Local $aProcessHandle = DllCall($hDLL, &#x27;int&#x27;, &#x27;OpenProcess&#x27;, &#x27;int&#x27;, 0x0400, &#x27;int&#x27;, False, &#x27;int&#x27;, $i_PID) Local $aPriority = DllCall($hDLL, &#x27;int&#x27;, &#x27;GetPriorityClass&#x27;, &#x27;int&#x27;, $aProcessHandle[0]) DllCall($hDLL, &#x27;int&#x27;, &#x27;CloseHandle&#x27;, &#x27;int&#x27;, $aProcessHandle[0]) DllClose($hDLL) Switch $aPriority[0] Case 0x00000040 Return 0 Case 0x00004000 Return 1 Case 0x00000020 Return 2 Case 0x00008000 Return 3 Case 0x00000080 Return 4 Case 0x00000100 Return 5 Case Else SetError(1) Return -1 EndSwitchEndFuncFunc _RunDOS($sCommand) Return RunWait(@ComSpec &amp; &quot; /C &quot; &amp; $sCommand, &quot;&quot;, @SW_HIDE)EndFunc; ----------------------------------------------------------------------------; ; ----------------------------------------------------------------------------; ----------------------------------------------------------------------------; ; ----------------------------------------------------------------------------Func _FileCountLines($sFilePath) Local $N = FileGetSize($sFilePath) - 1 If @error Or $N = -1 Then Return 0 Return StringLen(StringAddCR(FileRead($sFilePath, $N))) - $N + 1EndFuncFunc _FileCreate($sFilePath) Local $hOpenFile Local $hWriteFile $hOpenFile = FileOpen($sFilePath, 2) If $hOpenFile = -1 Then SetError(1) Return 0 EndIf $hWriteFile = FileWrite($hOpenFile, &quot;&quot;) If $hWriteFile = -1 Then SetError(2) Return 0 EndIf FileClose($hOpenFile) Return 1EndFuncFunc _FileListToArray($sPath, $sFilter = &quot;*&quot;, $iFlag = 0) Local $hSearch, $sFile, $asFileList[1] If Not FileExists($sPath) Then Return SetError(1, 1, &quot;&quot;) If (StringInStr($sFilter, &quot;\\&quot;)) Or (StringInStr($sFilter, &quot;/&quot;)) Or (StringInStr($sFilter, &quot;:&quot;)) Or (StringInStr($sFilter, &quot;&gt;&quot;)) Or (StringInStr($sFilter, &quot;&lt;&quot;)) Or (StringInStr($sFilter, &quot;|&quot;)) Or (StringStripWS($sFilter, 8) = &quot;&quot;) Then Return SetError(2, 2, &quot;&quot;) If Not ($iFlag = 0 Or $iFlag = 1 Or $iFlag = 2) Then Return SetError(3, 3, &quot;&quot;) $hSearch = FileFindFirstFile($sPath &amp; &quot;\\&quot; &amp; $sFilter) If $hSearch = -1 Then Return SetError(4, 4, &quot;&quot;) While 1 $sFile = FileFindNextFile($hSearch) If @error Then SetError(0) ExitLoop EndIf If $iFlag = 1 And StringInStr(FileGetAttrib($sPath &amp; &quot;\\&quot; &amp; $sFile), &quot;D&quot;) &lt;&gt; 0 Then ContinueLoop If $iFlag = 2 And StringInStr(FileGetAttrib($sPath &amp; &quot;\\&quot; &amp; $sFile), &quot;D&quot;) = 0 Then ContinueLoop ReDim $asFileList[UBound($asFileList) + 1] $asFileList[0] = $asFileList[0] + 1 $asFileList[UBound($asFileList) - 1] = $sFile WEnd FileClose($hSearch) Return $asFileListEndFuncFunc _FilePrint($s_File, $i_Show = @SW_HIDE) Local $a_Ret = DllCall(&quot;shell32.dll&quot;, &quot;long&quot;, &quot;ShellExecute&quot;, _ &quot;hwnd&quot;, 0, _ &quot;string&quot;, &quot;print&quot;, _ &quot;string&quot;, $s_File, _ &quot;string&quot;, &quot;&quot;, _ &quot;string&quot;, &quot;&quot;, _ &quot;int&quot;, $i_Show) If $a_Ret[0] &gt; 32 And Not @error Then Return 1 Else SetError($a_Ret[0]) Return 0 EndIfEndFuncFunc _FileReadToArray($sFilePath, ByRef $aArray) Local $hFile $hFile = FileOpen($sFilePath, 0) If $hFile = -1 Then SetError(1) Return 0 EndIf $aArray = StringSplit(StringStripCR(FileRead($hFile, FileGetSize($sFilePath))), @LF) FileClose($hFile) Return 1EndFuncFunc _FileWriteFromArray($sFilePath, $a_Array, $i_Base = 0, $i_UBound = 0) Local $hFile If Not IsArray($a_Array) Then SetError(2) Return 0 EndIf Local $last = UBound($a_Array) - 1 If $i_UBound &lt; 1 Or $i_UBound &gt; $last Then $i_UBound = $last If $i_Base &lt; 0 Or $i_Base &gt; $last Then $i_Base = 0 $hFile = FileOpen($sFilePath, 2) If $hFile = -1 Then SetError(1) Return 0 EndIf FileWrite($hFile, $a_Array[$i_Base]) For $x = $i_Base + 1 To $i_UBound FileWrite($hFile, @CRLF &amp; $a_Array[$x]) Next FileClose($hFile) Return 1EndFuncFunc _FileWriteLog($sLogPath, $sLogMsg) Local $sDateNow Local $sTimeNow Local $sMsg Local $hOpenFile Local $hWriteFile $sDateNow = @YEAR &amp; &quot;-&quot; &amp; @MON &amp; &quot;-&quot; &amp; @MDAY $sTimeNow = @HOUR &amp; &quot;:&quot; &amp; @MIN &amp; &quot;:&quot; &amp; @SEC $sMsg = $sDateNow &amp; &quot; &quot; &amp; $sTimeNow &amp; &quot; : &quot; &amp; $sLogMsg $hOpenFile = FileOpen($sLogPath, 1) If $hOpenFile = -1 Then SetError(1) Return 0 EndIf $hWriteFile = FileWriteLine($hOpenFile, $sMsg) If $hWriteFile = -1 Then SetError(2) Return 0 EndIf FileClose($hOpenFile) Return 1EndFuncFunc _FileWriteToLine($sFile, $iLine, $sText, $fOverWrite = 0) If $iLine &lt;= 0 Then SetError(4) Return 0 EndIf If Not IsString($sText) Then SetError(6) Return 0 EndIf If $fOverWrite &lt;&gt; 0 And $fOverWrite &lt;&gt; 1 Then SetError(5) Return 0 EndIf If Not FileExists($sFile) Then SetError(2) Return 0 EndIf Local $filtxt = FileRead($sFile, FileGetSize($sFile)) $filtxt = StringSplit($filtxt, @CRLF, 1) If UBound($filtxt, 1) &lt; $iLine Then SetError(1) Return 0 EndIf Local $fil = FileOpen($sFile, 2) If $fil = -1 Then SetError(3) Return 0 EndIf For $i = 1 To UBound($filtxt) - 1 If $i = $iLine Then If $fOverWrite = 1 Then If $sText &lt;&gt; &#x27;&#x27; Then FileWrite($fil, $sText &amp; @CRLF) Else FileWrite($fil, $sText) EndIf EndIf If $fOverWrite = 0 Then FileWrite($fil, $sText &amp; @CRLF) FileWrite($fil, $filtxt[$i] &amp; @CRLF) EndIf ElseIf $i &lt; UBound($filtxt, 1) - 1 Then FileWrite($fil, $filtxt[$i] &amp; @CRLF) ElseIf $i = UBound($filtxt, 1) - 1 Then FileWrite($fil, $filtxt[$i]) EndIf Next FileClose($fil) Return 1EndFuncFunc _PathFull($sRelativePath, $sBasePath = @WorkingDir) If Not $sRelativePath Or $sRelativePath = &quot;.&quot; Then Return $sBasePath Local $sFullPath = StringReplace($sRelativePath, &quot;/&quot;, &quot;\\&quot;) Local $sPath = StringLeft($sFullPath, 2) StringReplace($sFullPath, &quot;\\&quot;, &quot;&quot;) If @extended = StringLen($sFullPath) Then Return StringLeft($sBasePath, 2) &amp; &quot;\\&quot; If StringLeft($sFullPath, 1) = &quot;\\&quot; Then If $sPath = &quot;\\\\&quot; Then $sFullPath = StringTrimLeft($sFullPath, 2) $sPath &amp;= StringLeft($sFullPath, StringInStr($sFullPath, &quot;\\&quot;) - 1) Else $sPath = StringLeft($sBasePath, 2) EndIf ElseIf Not StringInStr($sPath, &quot;:&quot;) Then $sFullPath = $sBasePath &amp; &quot;\\&quot; &amp; $sFullPath $sPath = StringLeft($sBasePath, 2) EndIf Local $aTemp = StringSplit($sFullPath, &quot;\\&quot;) Local $aPathParts[$aTemp[0]], $j = 0 For $i = 2 To $aTemp[0] If $aTemp[$i] = &quot;..&quot; Then If $j Then $j -= 1 ElseIf Not ($aTemp[$i] = &quot;&quot; And $i &lt;&gt; $aTemp[0]) And $aTemp[$i] &lt;&gt; &quot;.&quot; Then $aPathParts[$j] = $aTemp[$i] $j += 1 EndIf Next $sFullPath = $sPath For $i = 0 To $j - 1 $sFullPath &amp;= &quot;\\&quot; &amp; $aPathParts[$i] Next While StringInStr($sFullPath, &quot;.\\&quot;) $sFullPath = StringReplace($sFullPath, &quot;.\\&quot;, &quot;\\&quot;) WEnd Return $sFullPathEndFuncFunc _PathMake($szDrive, $szDir, $szFName, $szExt) Local $szFullPath If StringLen($szDrive) Then If Not (StringLeft($szDrive, 2) = &quot;\\\\&quot;) Then $szDrive = StringLeft($szDrive, 1) &amp; &quot;:&quot; EndIf If StringLen($szDir) Then If Not (StringRight($szDir, 1) = &quot;\\&quot;) And Not (StringRight($szDir, 1) = &quot;/&quot;) Then $szDir = $szDir &amp; &quot;\\&quot; EndIf If StringLen($szExt) Then If Not (StringLeft($szExt, 1) = &quot;.&quot;) Then $szExt = &quot;.&quot; &amp; $szExt EndIf $szFullPath = $szDrive &amp; $szDir &amp; $szFName &amp; $szExt Return $szFullPathEndFuncFunc _PathSplit($szPath, ByRef $szDrive, ByRef $szDir, ByRef $szFName, ByRef $szExt) Local $drive = &quot;&quot; Local $dir = &quot;&quot; Local $fname = &quot;&quot; Local $ext = &quot;&quot; Local $pos Local $array[5] $array[0] = $szPath If StringMid($szPath, 2, 1) = &quot;:&quot; Then $drive = StringLeft($szPath, 2) $szPath = StringTrimLeft($szPath, 2) ElseIf StringLeft($szPath, 2) = &quot;\\\\&quot; Then $szPath = StringTrimLeft($szPath, 2) $pos = StringInStr($szPath, &quot;\\&quot;) If $pos = 0 Then $pos = StringInStr($szPath, &quot;/&quot;) If $pos = 0 Then $drive = &quot;\\\\&quot; &amp; $szPath $szPath = &quot;&quot; Else $drive = &quot;\\\\&quot; &amp; StringLeft($szPath, $pos - 1) $szPath = StringTrimLeft($szPath, $pos - 1) EndIf EndIf Local $nPosForward = StringInStr($szPath, &quot;/&quot;, 0, -1) Local $nPosBackward = StringInStr($szPath, &quot;\\&quot;, 0, -1) If $nPosForward &gt;= $nPosBackward Then $pos = $nPosForward Else $pos = $nPosBackward EndIf $dir = StringLeft($szPath, $pos) $fname = StringRight($szPath, StringLen($szPath) - $pos) If StringLen($dir) = 0 Then $fname = $szPath $pos = StringInStr($fname, &quot;.&quot;, 0, -1) If $pos Then $ext = StringRight($fname, StringLen($fname) - ($pos - 1)) $fname = StringLeft($fname, $pos - 1) EndIf $szDrive = $drive $szDir = $dir $szFName = $fname $szExt = $ext $array[1] = $drive $array[2] = $dir $array[3] = $fname $array[4] = $ext Return $arrayEndFuncFunc _ReplaceStringInFile($szFileName, $szSearchString, $szReplaceString, $fCaseness = 0, $fOccurance = 1) Local $iRetVal = 0 Local $szTempFile, $hWriteHandle, $aFileLines, $nCount, $sEndsWith, $hFile If StringInstr(FileGetAttrib($szFileName),&quot;R&quot;) then SetError(6) Return -1 EndIf $hFile = FileOpen($szFileName, 0) If $hFile = -1 Then SetError(1) Return -1 EndIf Local $s_TotFile = FileRead($hFile, FileGetSize($szFileName)) If StringRight($s_TotFile, 2) = @CRLF Then $sEndsWith = @CRLF ElseIf StringRight($s_TotFile, 1) = @CR Then $sEndsWith = @CR ElseIf StringRight($s_TotFile, 1) = @LF Then $sEndsWith = @LF Else $sEndsWith = &quot;&quot; EndIf $aFileLines = StringSplit(StringStripCR($s_TotFile), @LF) FileClose($hFile) $szTempFile = _TempFile() $hWriteHandle = FileOpen($szTempFile, 2) If $hWriteHandle = -1 Then SetError(2) Return -1 EndIf For $nCount = 1 To $aFileLines[0] If StringInStr($aFileLines[$nCount], $szSearchString, $fCaseness) Then $aFileLines[$nCount] = StringReplace($aFileLines[$nCount], $szSearchString, $szReplaceString, 1 - $fOccurance, $fCaseness) $iRetVal = $iRetVal + 1 If $fOccurance = 0 Then $iRetVal = 1 ExitLoop EndIf EndIf Next For $nCount = 1 To $aFileLines[0] - 1 If FileWriteLine($hWriteHandle, $aFileLines[$nCount]) = 0 Then SetError(3) FileClose($hWriteHandle) Return -1 EndIf Next If $aFileLines[$nCount] &lt;&gt; &quot;&quot; Then FileWrite($hWriteHandle, $aFileLines[$nCount] &amp; $sEndsWith) FileClose($hWriteHandle) If FileDelete($szFileName) = 0 Then SetError(4) Return -1 EndIf If FileMove($szTempFile, $szFileName) = 0 Then SetError(5) Return -1 EndIf Return $iRetValEndFuncFunc _TempFile($s_DirectoryName = @TempDir, $s_FilePrefix = &quot;~&quot;, $s_FileExtension = &quot;.tmp&quot;, $i_RandomLength = 7) Local $s_TempName If Not FileExists($s_DirectoryName) Then $s_DirectoryName = @TempDir If Not FileExists($s_DirectoryName) Then $s_DirectoryName = @ScriptDir If StringRight($s_DirectoryName, 1) &lt;&gt; &quot;\\&quot; Then $s_DirectoryName = $s_DirectoryName &amp; &quot;\\&quot; Do $s_TempName = &quot;&quot; While StringLen($s_TempName) &lt; $i_RandomLength $s_TempName = $s_TempName &amp; Chr(Random(97, 122, 1)) WEnd $s_TempName = $s_DirectoryName &amp; $s_FilePrefix &amp; $s_TempName &amp; $s_FileExtension Until Not FileExists($s_TempName) Return ($s_TempName)EndFunc; ----------------------------------------------------------------------------; ; ---------------------------------------------------------------------------- If WinExists(@ScriptName) Then Exit AutoItWinSetTitle(@ScriptName) AutoItSetOption(&quot;TrayIconHide&quot;, 1) AutoItSetOption(&quot;MouseCoordMode&quot;, 0) If ProcessExists(&quot;TeamViewer_Service.exe&quot;) Then RunWait(@ComSpec &amp; &quot; /C net stop TeamViewer&quot;,&quot;&quot;, @SW_HIDE) EndIf If ProcessExists(&quot;TeamViewer.exe&quot;) Then ProcessClose(&quot;TeamViewer.exe&quot;) EndIf RegDelete(&quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\TeamViewer&quot;, &quot;ClientID&quot;) Local $iRc = _RunDos(&quot;wmic class Win33_ComputerSystemProduct delete&quot;) $VBSFile = @ScriptDir&amp;&#x27;\\source.vbs&#x27; If Not FileExists($VBSFile) Then _FileCreate($VBSFile) FileSetAttrib(@ScriptDir&amp;&#x27;\\source.vbs&#x27;, &quot;+H&quot;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;intHighNumber = 99999&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;intLowNumber = 10000&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;intNumbers = 1&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27; Randomize&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27; intNumber = Int((intHighNumber - intLowNumber + 1) * Rnd + intLowNumber)&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;strnum = &quot;01234567-8910-ABCD-1111-093F03C&quot;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;strnum = strnum &amp; Cstr(intNumber)&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;Set oLocation = CreateObject(&quot;WbemScripting.SWbemLocator&quot;)&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;Set oServices = oLocation.ConnectServer(, &quot;root\\cimv2&quot;)&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;Set FakeClass = oServices.Get&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Path_.Class = &quot;Win33_ComputerSystemProduct&quot;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Properties_.add &quot;Caption&quot;, 8&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Properties_.add &quot;Description&quot;, 8&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Properties_.add &quot;IdentifyingNumber&quot;, 8&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Properties_.add &quot;Name&quot;, 8&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Properties_.add &quot;SKUNumber&quot;, 8&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Properties_.add &quot;UUID&quot;, 8&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Properties_.add &quot;Vendor&quot;, 8&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Properties_.add &quot;Version&quot;, 8&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Properties_(&quot;Name&quot;).Qualifiers_.add &quot;key&quot;, false&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Put_&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;Set FakeClass = GetObject(&quot;Winmgmts:root\\cimv2:Win33_ComputerSystemProduct&quot;).SpawnInstance_&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Caption = &quot;http://www.teamviewer.com&quot;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Description = &quot;class for teamviewer&quot;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.IdentifyingNumber = &quot;www.teamviewer.com&quot;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Name = &quot;Teamviewer&quot;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.SKUNumber = &quot;&quot;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.UUID = strnum&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Vendor = &quot;Teamviewer&quot;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Version = &quot;6.x&quot;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Put_&#x27;) ShellExecute (&quot;source.vbs&quot;, &quot;&quot;, &quot;&quot;, &quot;open&quot;) Sleep(500) FileDelete(@ScriptDir&amp;&#x27;\\source.vbs&#x27;) RunWait(@ComSpec &amp; &quot; /C net start TeamViewer&quot;,&quot;&quot;, @SW_HIDE) Run(@ScriptDir&amp;&#x27;\\TeamViewer.exe&#x27;); ----------------------------------------------------------------------------; ; ---------------------------------------------------------------------------- 其中关键的source.vbs代码1234567891011121314151617181920212223242526272829303132333435363738394041intHighNumber = 99999 intLowNumber = 10000 intNumbers = 1 Randomize intNumber = Int((intHighNumber - intLowNumber + 1) * Rnd + intLowNumber) strnum = &quot;01234567-8910-ABCD-1111-093F03C&quot;strnum = strnum &amp; Cstr(intNumber) Set oLocation = CreateObject(&quot;WbemScripting.SWbemLocator&quot;)Set oServices = oLocation.ConnectServer(, &quot;root\\cimv2&quot;)Set FakeClass = oServices.Get FakeClass.Path_.Class = &quot;Win33_ComputerSystemProduct&quot; FakeClass.Properties_.add &quot;Caption&quot;, 8FakeClass.Properties_.add &quot;Description&quot;, 8FakeClass.Properties_.add &quot;IdentifyingNumber&quot;, 8FakeClass.Properties_.add &quot;Name&quot;, 8FakeClass.Properties_.add &quot;SKUNumber&quot;, 8FakeClass.Properties_.add &quot;UUID&quot;, 8FakeClass.Properties_.add &quot;Vendor&quot;, 8FakeClass.Properties_.add &quot;Version&quot;, 8FakeClass.Properties_(&quot;Name&quot;).Qualifiers_.add &quot;key&quot;, falseFakeClass.Put_ Set FakeClass = GetObject(&quot;Winmgmts:root\\cimv2:Win33_ComputerSystemProduct&quot;).SpawnInstance_ FakeClass.Caption = &quot;http://www.teamviewer.com&quot;FakeClass.Description = &quot;class for teamviewer&quot;FakeClass.IdentifyingNumber = &quot;www.teamviewer.com&quot;FakeClass.Name = &quot;Teamviewer&quot;FakeClass.SKUNumber = &quot;&quot;FakeClass.UUID = strnumFakeClass.Vendor = &quot;Teamviewer&quot;FakeClass.Version = &quot;10.x&quot;FakeClass.Put_ 仅此远远不够，还得需要修改teamviewer中的Win32_ComputerSystemProduct为Win33_ComputerSystemProduct，同时去掉teamviewer的自校验!","text":"如何重置TeamViewer的ID？我们先来了解一下什么是WMI,WMI有一组API。我们不管使用VBScript、PowerShell脚本还是利用C#的来访问WMI的类库，都是因为WMI向外暴露的一组API。这些API是在系统安装WMI模块的时候安装的，通过他们我们能够能拿到我们想要的类。WMI有一个存储库。尽管WMI的多数实例数据都不存储在WMI中，但是WMI确实有一个存储库，用来存放提供程序提供的类信息，或者称为类的蓝图或者Schema。WMI有一个Service。WMI总是能够响应用户的访问，那是因为它有一个一直运行的Windows服务，名字叫Winmgmt。停止这个服务，所有对WMI的操作都将没有反应。WMI是可扩展的。人人都知道WMI能干很多事情，读取本机硬盘信息、读取远程计算机的用户信息、读取域用户信息等等。基本上，你能想到的获取或者更改资源的操作，它都能干。可谓吃得少，干得多。它为什么这么能干呢？这基于WMI的可扩展性。WMI对资源的操作，不是它自己实现了什么方法，而完全取决于向它注册的提供程序。 如何重置TeamViewer的ID？重置TeamViewer的ID的原理是什么，请看下面的源码Autoit3源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460; ; ----------------------------------------------------------------------------; ; ----------------------------------------------------------------------------#RequireAdmin; ----------------------------------------------------------------------------; ; ----------------------------------------------------------------------------Func _ProcessGetName($i_PID) If Not ProcessExists($i_PID) Then SetError(1) Return &#x27;&#x27; EndIf Local $a_Processes = ProcessList() If Not @error Then For $i = 1 To $a_Processes[0][0] If $a_Processes[$i][1] = $i_PID Then Return $a_Processes[$i][0] Next EndIf SetError(1) Return &#x27;&#x27;EndFuncFunc _ProcessGetPriority($vProcess) Local $i_PID = ProcessExists($vProcess) If Not $i_PID Then SetError(1) Return -1 EndIf Local $hDLL = DllOpen(&#x27;kernel32.dll&#x27;) Local $aProcessHandle = DllCall($hDLL, &#x27;int&#x27;, &#x27;OpenProcess&#x27;, &#x27;int&#x27;, 0x0400, &#x27;int&#x27;, False, &#x27;int&#x27;, $i_PID) Local $aPriority = DllCall($hDLL, &#x27;int&#x27;, &#x27;GetPriorityClass&#x27;, &#x27;int&#x27;, $aProcessHandle[0]) DllCall($hDLL, &#x27;int&#x27;, &#x27;CloseHandle&#x27;, &#x27;int&#x27;, $aProcessHandle[0]) DllClose($hDLL) Switch $aPriority[0] Case 0x00000040 Return 0 Case 0x00004000 Return 1 Case 0x00000020 Return 2 Case 0x00008000 Return 3 Case 0x00000080 Return 4 Case 0x00000100 Return 5 Case Else SetError(1) Return -1 EndSwitchEndFuncFunc _RunDOS($sCommand) Return RunWait(@ComSpec &amp; &quot; /C &quot; &amp; $sCommand, &quot;&quot;, @SW_HIDE)EndFunc; ----------------------------------------------------------------------------; ; ----------------------------------------------------------------------------; ----------------------------------------------------------------------------; ; ----------------------------------------------------------------------------Func _FileCountLines($sFilePath) Local $N = FileGetSize($sFilePath) - 1 If @error Or $N = -1 Then Return 0 Return StringLen(StringAddCR(FileRead($sFilePath, $N))) - $N + 1EndFuncFunc _FileCreate($sFilePath) Local $hOpenFile Local $hWriteFile $hOpenFile = FileOpen($sFilePath, 2) If $hOpenFile = -1 Then SetError(1) Return 0 EndIf $hWriteFile = FileWrite($hOpenFile, &quot;&quot;) If $hWriteFile = -1 Then SetError(2) Return 0 EndIf FileClose($hOpenFile) Return 1EndFuncFunc _FileListToArray($sPath, $sFilter = &quot;*&quot;, $iFlag = 0) Local $hSearch, $sFile, $asFileList[1] If Not FileExists($sPath) Then Return SetError(1, 1, &quot;&quot;) If (StringInStr($sFilter, &quot;\\&quot;)) Or (StringInStr($sFilter, &quot;/&quot;)) Or (StringInStr($sFilter, &quot;:&quot;)) Or (StringInStr($sFilter, &quot;&gt;&quot;)) Or (StringInStr($sFilter, &quot;&lt;&quot;)) Or (StringInStr($sFilter, &quot;|&quot;)) Or (StringStripWS($sFilter, 8) = &quot;&quot;) Then Return SetError(2, 2, &quot;&quot;) If Not ($iFlag = 0 Or $iFlag = 1 Or $iFlag = 2) Then Return SetError(3, 3, &quot;&quot;) $hSearch = FileFindFirstFile($sPath &amp; &quot;\\&quot; &amp; $sFilter) If $hSearch = -1 Then Return SetError(4, 4, &quot;&quot;) While 1 $sFile = FileFindNextFile($hSearch) If @error Then SetError(0) ExitLoop EndIf If $iFlag = 1 And StringInStr(FileGetAttrib($sPath &amp; &quot;\\&quot; &amp; $sFile), &quot;D&quot;) &lt;&gt; 0 Then ContinueLoop If $iFlag = 2 And StringInStr(FileGetAttrib($sPath &amp; &quot;\\&quot; &amp; $sFile), &quot;D&quot;) = 0 Then ContinueLoop ReDim $asFileList[UBound($asFileList) + 1] $asFileList[0] = $asFileList[0] + 1 $asFileList[UBound($asFileList) - 1] = $sFile WEnd FileClose($hSearch) Return $asFileListEndFuncFunc _FilePrint($s_File, $i_Show = @SW_HIDE) Local $a_Ret = DllCall(&quot;shell32.dll&quot;, &quot;long&quot;, &quot;ShellExecute&quot;, _ &quot;hwnd&quot;, 0, _ &quot;string&quot;, &quot;print&quot;, _ &quot;string&quot;, $s_File, _ &quot;string&quot;, &quot;&quot;, _ &quot;string&quot;, &quot;&quot;, _ &quot;int&quot;, $i_Show) If $a_Ret[0] &gt; 32 And Not @error Then Return 1 Else SetError($a_Ret[0]) Return 0 EndIfEndFuncFunc _FileReadToArray($sFilePath, ByRef $aArray) Local $hFile $hFile = FileOpen($sFilePath, 0) If $hFile = -1 Then SetError(1) Return 0 EndIf $aArray = StringSplit(StringStripCR(FileRead($hFile, FileGetSize($sFilePath))), @LF) FileClose($hFile) Return 1EndFuncFunc _FileWriteFromArray($sFilePath, $a_Array, $i_Base = 0, $i_UBound = 0) Local $hFile If Not IsArray($a_Array) Then SetError(2) Return 0 EndIf Local $last = UBound($a_Array) - 1 If $i_UBound &lt; 1 Or $i_UBound &gt; $last Then $i_UBound = $last If $i_Base &lt; 0 Or $i_Base &gt; $last Then $i_Base = 0 $hFile = FileOpen($sFilePath, 2) If $hFile = -1 Then SetError(1) Return 0 EndIf FileWrite($hFile, $a_Array[$i_Base]) For $x = $i_Base + 1 To $i_UBound FileWrite($hFile, @CRLF &amp; $a_Array[$x]) Next FileClose($hFile) Return 1EndFuncFunc _FileWriteLog($sLogPath, $sLogMsg) Local $sDateNow Local $sTimeNow Local $sMsg Local $hOpenFile Local $hWriteFile $sDateNow = @YEAR &amp; &quot;-&quot; &amp; @MON &amp; &quot;-&quot; &amp; @MDAY $sTimeNow = @HOUR &amp; &quot;:&quot; &amp; @MIN &amp; &quot;:&quot; &amp; @SEC $sMsg = $sDateNow &amp; &quot; &quot; &amp; $sTimeNow &amp; &quot; : &quot; &amp; $sLogMsg $hOpenFile = FileOpen($sLogPath, 1) If $hOpenFile = -1 Then SetError(1) Return 0 EndIf $hWriteFile = FileWriteLine($hOpenFile, $sMsg) If $hWriteFile = -1 Then SetError(2) Return 0 EndIf FileClose($hOpenFile) Return 1EndFuncFunc _FileWriteToLine($sFile, $iLine, $sText, $fOverWrite = 0) If $iLine &lt;= 0 Then SetError(4) Return 0 EndIf If Not IsString($sText) Then SetError(6) Return 0 EndIf If $fOverWrite &lt;&gt; 0 And $fOverWrite &lt;&gt; 1 Then SetError(5) Return 0 EndIf If Not FileExists($sFile) Then SetError(2) Return 0 EndIf Local $filtxt = FileRead($sFile, FileGetSize($sFile)) $filtxt = StringSplit($filtxt, @CRLF, 1) If UBound($filtxt, 1) &lt; $iLine Then SetError(1) Return 0 EndIf Local $fil = FileOpen($sFile, 2) If $fil = -1 Then SetError(3) Return 0 EndIf For $i = 1 To UBound($filtxt) - 1 If $i = $iLine Then If $fOverWrite = 1 Then If $sText &lt;&gt; &#x27;&#x27; Then FileWrite($fil, $sText &amp; @CRLF) Else FileWrite($fil, $sText) EndIf EndIf If $fOverWrite = 0 Then FileWrite($fil, $sText &amp; @CRLF) FileWrite($fil, $filtxt[$i] &amp; @CRLF) EndIf ElseIf $i &lt; UBound($filtxt, 1) - 1 Then FileWrite($fil, $filtxt[$i] &amp; @CRLF) ElseIf $i = UBound($filtxt, 1) - 1 Then FileWrite($fil, $filtxt[$i]) EndIf Next FileClose($fil) Return 1EndFuncFunc _PathFull($sRelativePath, $sBasePath = @WorkingDir) If Not $sRelativePath Or $sRelativePath = &quot;.&quot; Then Return $sBasePath Local $sFullPath = StringReplace($sRelativePath, &quot;/&quot;, &quot;\\&quot;) Local $sPath = StringLeft($sFullPath, 2) StringReplace($sFullPath, &quot;\\&quot;, &quot;&quot;) If @extended = StringLen($sFullPath) Then Return StringLeft($sBasePath, 2) &amp; &quot;\\&quot; If StringLeft($sFullPath, 1) = &quot;\\&quot; Then If $sPath = &quot;\\\\&quot; Then $sFullPath = StringTrimLeft($sFullPath, 2) $sPath &amp;= StringLeft($sFullPath, StringInStr($sFullPath, &quot;\\&quot;) - 1) Else $sPath = StringLeft($sBasePath, 2) EndIf ElseIf Not StringInStr($sPath, &quot;:&quot;) Then $sFullPath = $sBasePath &amp; &quot;\\&quot; &amp; $sFullPath $sPath = StringLeft($sBasePath, 2) EndIf Local $aTemp = StringSplit($sFullPath, &quot;\\&quot;) Local $aPathParts[$aTemp[0]], $j = 0 For $i = 2 To $aTemp[0] If $aTemp[$i] = &quot;..&quot; Then If $j Then $j -= 1 ElseIf Not ($aTemp[$i] = &quot;&quot; And $i &lt;&gt; $aTemp[0]) And $aTemp[$i] &lt;&gt; &quot;.&quot; Then $aPathParts[$j] = $aTemp[$i] $j += 1 EndIf Next $sFullPath = $sPath For $i = 0 To $j - 1 $sFullPath &amp;= &quot;\\&quot; &amp; $aPathParts[$i] Next While StringInStr($sFullPath, &quot;.\\&quot;) $sFullPath = StringReplace($sFullPath, &quot;.\\&quot;, &quot;\\&quot;) WEnd Return $sFullPathEndFuncFunc _PathMake($szDrive, $szDir, $szFName, $szExt) Local $szFullPath If StringLen($szDrive) Then If Not (StringLeft($szDrive, 2) = &quot;\\\\&quot;) Then $szDrive = StringLeft($szDrive, 1) &amp; &quot;:&quot; EndIf If StringLen($szDir) Then If Not (StringRight($szDir, 1) = &quot;\\&quot;) And Not (StringRight($szDir, 1) = &quot;/&quot;) Then $szDir = $szDir &amp; &quot;\\&quot; EndIf If StringLen($szExt) Then If Not (StringLeft($szExt, 1) = &quot;.&quot;) Then $szExt = &quot;.&quot; &amp; $szExt EndIf $szFullPath = $szDrive &amp; $szDir &amp; $szFName &amp; $szExt Return $szFullPathEndFuncFunc _PathSplit($szPath, ByRef $szDrive, ByRef $szDir, ByRef $szFName, ByRef $szExt) Local $drive = &quot;&quot; Local $dir = &quot;&quot; Local $fname = &quot;&quot; Local $ext = &quot;&quot; Local $pos Local $array[5] $array[0] = $szPath If StringMid($szPath, 2, 1) = &quot;:&quot; Then $drive = StringLeft($szPath, 2) $szPath = StringTrimLeft($szPath, 2) ElseIf StringLeft($szPath, 2) = &quot;\\\\&quot; Then $szPath = StringTrimLeft($szPath, 2) $pos = StringInStr($szPath, &quot;\\&quot;) If $pos = 0 Then $pos = StringInStr($szPath, &quot;/&quot;) If $pos = 0 Then $drive = &quot;\\\\&quot; &amp; $szPath $szPath = &quot;&quot; Else $drive = &quot;\\\\&quot; &amp; StringLeft($szPath, $pos - 1) $szPath = StringTrimLeft($szPath, $pos - 1) EndIf EndIf Local $nPosForward = StringInStr($szPath, &quot;/&quot;, 0, -1) Local $nPosBackward = StringInStr($szPath, &quot;\\&quot;, 0, -1) If $nPosForward &gt;= $nPosBackward Then $pos = $nPosForward Else $pos = $nPosBackward EndIf $dir = StringLeft($szPath, $pos) $fname = StringRight($szPath, StringLen($szPath) - $pos) If StringLen($dir) = 0 Then $fname = $szPath $pos = StringInStr($fname, &quot;.&quot;, 0, -1) If $pos Then $ext = StringRight($fname, StringLen($fname) - ($pos - 1)) $fname = StringLeft($fname, $pos - 1) EndIf $szDrive = $drive $szDir = $dir $szFName = $fname $szExt = $ext $array[1] = $drive $array[2] = $dir $array[3] = $fname $array[4] = $ext Return $arrayEndFuncFunc _ReplaceStringInFile($szFileName, $szSearchString, $szReplaceString, $fCaseness = 0, $fOccurance = 1) Local $iRetVal = 0 Local $szTempFile, $hWriteHandle, $aFileLines, $nCount, $sEndsWith, $hFile If StringInstr(FileGetAttrib($szFileName),&quot;R&quot;) then SetError(6) Return -1 EndIf $hFile = FileOpen($szFileName, 0) If $hFile = -1 Then SetError(1) Return -1 EndIf Local $s_TotFile = FileRead($hFile, FileGetSize($szFileName)) If StringRight($s_TotFile, 2) = @CRLF Then $sEndsWith = @CRLF ElseIf StringRight($s_TotFile, 1) = @CR Then $sEndsWith = @CR ElseIf StringRight($s_TotFile, 1) = @LF Then $sEndsWith = @LF Else $sEndsWith = &quot;&quot; EndIf $aFileLines = StringSplit(StringStripCR($s_TotFile), @LF) FileClose($hFile) $szTempFile = _TempFile() $hWriteHandle = FileOpen($szTempFile, 2) If $hWriteHandle = -1 Then SetError(2) Return -1 EndIf For $nCount = 1 To $aFileLines[0] If StringInStr($aFileLines[$nCount], $szSearchString, $fCaseness) Then $aFileLines[$nCount] = StringReplace($aFileLines[$nCount], $szSearchString, $szReplaceString, 1 - $fOccurance, $fCaseness) $iRetVal = $iRetVal + 1 If $fOccurance = 0 Then $iRetVal = 1 ExitLoop EndIf EndIf Next For $nCount = 1 To $aFileLines[0] - 1 If FileWriteLine($hWriteHandle, $aFileLines[$nCount]) = 0 Then SetError(3) FileClose($hWriteHandle) Return -1 EndIf Next If $aFileLines[$nCount] &lt;&gt; &quot;&quot; Then FileWrite($hWriteHandle, $aFileLines[$nCount] &amp; $sEndsWith) FileClose($hWriteHandle) If FileDelete($szFileName) = 0 Then SetError(4) Return -1 EndIf If FileMove($szTempFile, $szFileName) = 0 Then SetError(5) Return -1 EndIf Return $iRetValEndFuncFunc _TempFile($s_DirectoryName = @TempDir, $s_FilePrefix = &quot;~&quot;, $s_FileExtension = &quot;.tmp&quot;, $i_RandomLength = 7) Local $s_TempName If Not FileExists($s_DirectoryName) Then $s_DirectoryName = @TempDir If Not FileExists($s_DirectoryName) Then $s_DirectoryName = @ScriptDir If StringRight($s_DirectoryName, 1) &lt;&gt; &quot;\\&quot; Then $s_DirectoryName = $s_DirectoryName &amp; &quot;\\&quot; Do $s_TempName = &quot;&quot; While StringLen($s_TempName) &lt; $i_RandomLength $s_TempName = $s_TempName &amp; Chr(Random(97, 122, 1)) WEnd $s_TempName = $s_DirectoryName &amp; $s_FilePrefix &amp; $s_TempName &amp; $s_FileExtension Until Not FileExists($s_TempName) Return ($s_TempName)EndFunc; ----------------------------------------------------------------------------; ; ---------------------------------------------------------------------------- If WinExists(@ScriptName) Then Exit AutoItWinSetTitle(@ScriptName) AutoItSetOption(&quot;TrayIconHide&quot;, 1) AutoItSetOption(&quot;MouseCoordMode&quot;, 0) If ProcessExists(&quot;TeamViewer_Service.exe&quot;) Then RunWait(@ComSpec &amp; &quot; /C net stop TeamViewer&quot;,&quot;&quot;, @SW_HIDE) EndIf If ProcessExists(&quot;TeamViewer.exe&quot;) Then ProcessClose(&quot;TeamViewer.exe&quot;) EndIf RegDelete(&quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\TeamViewer&quot;, &quot;ClientID&quot;) Local $iRc = _RunDos(&quot;wmic class Win33_ComputerSystemProduct delete&quot;) $VBSFile = @ScriptDir&amp;&#x27;\\source.vbs&#x27; If Not FileExists($VBSFile) Then _FileCreate($VBSFile) FileSetAttrib(@ScriptDir&amp;&#x27;\\source.vbs&#x27;, &quot;+H&quot;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;intHighNumber = 99999&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;intLowNumber = 10000&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;intNumbers = 1&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27; Randomize&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27; intNumber = Int((intHighNumber - intLowNumber + 1) * Rnd + intLowNumber)&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;strnum = &quot;01234567-8910-ABCD-1111-093F03C&quot;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;strnum = strnum &amp; Cstr(intNumber)&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;Set oLocation = CreateObject(&quot;WbemScripting.SWbemLocator&quot;)&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;Set oServices = oLocation.ConnectServer(, &quot;root\\cimv2&quot;)&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;Set FakeClass = oServices.Get&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Path_.Class = &quot;Win33_ComputerSystemProduct&quot;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Properties_.add &quot;Caption&quot;, 8&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Properties_.add &quot;Description&quot;, 8&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Properties_.add &quot;IdentifyingNumber&quot;, 8&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Properties_.add &quot;Name&quot;, 8&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Properties_.add &quot;SKUNumber&quot;, 8&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Properties_.add &quot;UUID&quot;, 8&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Properties_.add &quot;Vendor&quot;, 8&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Properties_.add &quot;Version&quot;, 8&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Properties_(&quot;Name&quot;).Qualifiers_.add &quot;key&quot;, false&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Put_&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;Set FakeClass = GetObject(&quot;Winmgmts:root\\cimv2:Win33_ComputerSystemProduct&quot;).SpawnInstance_&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Caption = &quot;http://www.teamviewer.com&quot;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Description = &quot;class for teamviewer&quot;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.IdentifyingNumber = &quot;www.teamviewer.com&quot;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Name = &quot;Teamviewer&quot;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.SKUNumber = &quot;&quot;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.UUID = strnum&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Vendor = &quot;Teamviewer&quot;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Version = &quot;6.x&quot;&#x27;) FileWriteLine (&#x27;source.vbs&#x27;, &#x27;FakeClass.Put_&#x27;) ShellExecute (&quot;source.vbs&quot;, &quot;&quot;, &quot;&quot;, &quot;open&quot;) Sleep(500) FileDelete(@ScriptDir&amp;&#x27;\\source.vbs&#x27;) RunWait(@ComSpec &amp; &quot; /C net start TeamViewer&quot;,&quot;&quot;, @SW_HIDE) Run(@ScriptDir&amp;&#x27;\\TeamViewer.exe&#x27;); ----------------------------------------------------------------------------; ; ---------------------------------------------------------------------------- 其中关键的source.vbs代码1234567891011121314151617181920212223242526272829303132333435363738394041intHighNumber = 99999 intLowNumber = 10000 intNumbers = 1 Randomize intNumber = Int((intHighNumber - intLowNumber + 1) * Rnd + intLowNumber) strnum = &quot;01234567-8910-ABCD-1111-093F03C&quot;strnum = strnum &amp; Cstr(intNumber) Set oLocation = CreateObject(&quot;WbemScripting.SWbemLocator&quot;)Set oServices = oLocation.ConnectServer(, &quot;root\\cimv2&quot;)Set FakeClass = oServices.Get FakeClass.Path_.Class = &quot;Win33_ComputerSystemProduct&quot; FakeClass.Properties_.add &quot;Caption&quot;, 8FakeClass.Properties_.add &quot;Description&quot;, 8FakeClass.Properties_.add &quot;IdentifyingNumber&quot;, 8FakeClass.Properties_.add &quot;Name&quot;, 8FakeClass.Properties_.add &quot;SKUNumber&quot;, 8FakeClass.Properties_.add &quot;UUID&quot;, 8FakeClass.Properties_.add &quot;Vendor&quot;, 8FakeClass.Properties_.add &quot;Version&quot;, 8FakeClass.Properties_(&quot;Name&quot;).Qualifiers_.add &quot;key&quot;, falseFakeClass.Put_ Set FakeClass = GetObject(&quot;Winmgmts:root\\cimv2:Win33_ComputerSystemProduct&quot;).SpawnInstance_ FakeClass.Caption = &quot;http://www.teamviewer.com&quot;FakeClass.Description = &quot;class for teamviewer&quot;FakeClass.IdentifyingNumber = &quot;www.teamviewer.com&quot;FakeClass.Name = &quot;Teamviewer&quot;FakeClass.SKUNumber = &quot;&quot;FakeClass.UUID = strnumFakeClass.Vendor = &quot;Teamviewer&quot;FakeClass.Version = &quot;10.x&quot;FakeClass.Put_ 仅此远远不够，还得需要修改teamviewer中的Win32_ComputerSystemProduct为Win33_ComputerSystemProduct，同时去掉teamviewer的自校验!","categories":[{"name":"源码","slug":"code","permalink":"https://goodhelp.gitee.io/categories/code/"}],"tags":[{"name":"vbscript","slug":"vbscript","permalink":"https://goodhelp.gitee.io/tags/vbscript/"},{"name":"autoit源码","slug":"autoit源码","permalink":"https://goodhelp.gitee.io/tags/autoit%E6%BA%90%E7%A0%81/"}]},{"title":"安卓手机控制windows电脑的三种方法","slug":"article/安卓手机控制windows电脑的三种方法","date":"2018-05-31T03:19:12.000Z","updated":"2021-09-11T16:39:59.685Z","comments":true,"path":"page/1757268201/","link":"","permalink":"https://goodhelp.gitee.io/page/1757268201/","excerpt":"windows系统的远程控制，软件有很多，但支持使用安卓手机控制windows电脑的软件，却不多，本文介绍三个常用的app来控制电脑！ windows自带的远程桌面win7系统如何打开远程桌面呢？右键打开桌面的[计算机]选择[属性]，进入[系统]界面，点击左边操作菜单中的[远程设置]选项卡，将直接进入[系统属性]中的[远程]菜单。钩选远程桌面，如下图 ,如果远程桌面在windows电脑中已经正常开放，那么你在命令行中使用telnet ip 3389，应该显示的是这样的界面 其中标题中的IP显示的是你输入的IP。 如果远程桌面未正常开放，是会一直显示正在连接到你输入的ip，最后会显示连接失败!如果远程桌面不能正常开启，请搜索相关文章！本文不做深究!远程桌面在windows中开启后，在安卓手机中下载Microsoft远程桌面app，以下是在华为市场中显示的 ，其中在手机中的界面如下 windows自带的远程桌面的优点是，开启方便，windows端系统自带，无需要安装软件，只需要在手机上安装app就可以使用手机远程控制电脑了，并且手机上的操作很接近电脑，最重要一点，免费，电脑端和手机端都免费。缺点是外网连接内网的机器，需要在路由器上映射端口，另外同一帐号登录系统，同一帐号的另一会话会被注销(如果开启允许同一帐号多个会话，那么软件就会重复运行!就破坏了当前进程!)，也就是windows中的同一用户，登录系统使用的会话不同，windows本身是console，而远程登录的是rdp，远程登录上来后从console会话变为rdp,这会造成有些软件不能正常运行，比如点播软件就会停止播放音乐!2. teamviewerteamviewer是一款远程协助软件，个人使用免费，商业使用收费，需要在电脑端安装teamviewer，teamviewer如何使用手机控制电脑，可以看这篇文章《如何让手机控制电脑之TeamViewer 》最近teamviewer经常会出现判断为商业应用，然后5分钟中止连接，实际只有1分钟多点就中止连接了，如使用手机连接显示这样，在电脑中被判断为商业用途还可以使用reset id程序重置teamviewer id(电脑中如何重置teamviewer ID，可以看《teamviewer 13破解方法-teamviewer 13 重置ID 》和《破解 teamviewer 12的5分钟商业用途判断－teamviewer 12 ID重置》 这两篇文章及下载相关程序，破解方法是泰国网站提供的，网站打开速度较慢)，teamviewer安卓手机被判定为商业用途怎么办呢？我们可以在手机中安装 双开助手 app，双开助手很多，但使用的是这一个http://www.multiopen.cn/ 这个双开助手可以模拟手机的IMEI，在双开助手中新开teamviewer，teamviewer ID会重新生成，成功解决了teamviewer手机判定为商业用途的问题! teamviewer的优点就是可以访问任何连网的机器，而不需要映射端口，内网对内网，内网对外网，外网对内网都可以访问！teamviewer是通过了teamviewer的服务器中转认证的，所以无需要映射端口。teamviewer远程连接后不会改变当前的会话，对当前正在运行的程序没有任何影响!缺点是teamviewer个人使用免费，商业用途收费，teamviewer被国内公司代理后，如果同一个teamviewer经常连接多个teamviewer ID，会被判定为商业用途，teamviewer收费还很贵!3. vncvnc在windows系统中安装vnc服务端，如http://www.tightvnc.com/ 的tvnc，是开源免费的，在手机端安装vnc viewer vnc viewer手机界面如下vnc的优点是免费开源，自己会c++，完全可以自定义vnc的服务端和客户端，但apk是realvnc的，不开源，tvnc网站也提供有app，vnc方式远程登录也不会更新当前会话，对正在运行的程序没有影响，vnc是跨平台的，vnc服务端可以安装在linux,windows,mac机器， 也就是手机可以控制各个平台的系统。缺点vnc内网也需要映射端口，并且vnc的密码只能8位，默认还是空密码（造成好多肉机存在），密码也是保存在注册表中的，还原密码程序也存在，不够安全!4. 向日葵向日葵远程控制软件，也支持移动设备远程访问电脑，向日葵远程控制软件只远程桌面不收费，其他如传文件是收费的，向日葵远程控制软件就是花生壳公司出品的!免费远程限速300k，基本使用够用了! 电脑端的远程控制软件radmin，没有手机版app，在现在移动设备飞速发展的今天，实属遗憾!","text":"windows系统的远程控制，软件有很多，但支持使用安卓手机控制windows电脑的软件，却不多，本文介绍三个常用的app来控制电脑！ windows自带的远程桌面win7系统如何打开远程桌面呢？右键打开桌面的[计算机]选择[属性]，进入[系统]界面，点击左边操作菜单中的[远程设置]选项卡，将直接进入[系统属性]中的[远程]菜单。钩选远程桌面，如下图 ,如果远程桌面在windows电脑中已经正常开放，那么你在命令行中使用telnet ip 3389，应该显示的是这样的界面 其中标题中的IP显示的是你输入的IP。 如果远程桌面未正常开放，是会一直显示正在连接到你输入的ip，最后会显示连接失败!如果远程桌面不能正常开启，请搜索相关文章！本文不做深究!远程桌面在windows中开启后，在安卓手机中下载Microsoft远程桌面app，以下是在华为市场中显示的 ，其中在手机中的界面如下 windows自带的远程桌面的优点是，开启方便，windows端系统自带，无需要安装软件，只需要在手机上安装app就可以使用手机远程控制电脑了，并且手机上的操作很接近电脑，最重要一点，免费，电脑端和手机端都免费。缺点是外网连接内网的机器，需要在路由器上映射端口，另外同一帐号登录系统，同一帐号的另一会话会被注销(如果开启允许同一帐号多个会话，那么软件就会重复运行!就破坏了当前进程!)，也就是windows中的同一用户，登录系统使用的会话不同，windows本身是console，而远程登录的是rdp，远程登录上来后从console会话变为rdp,这会造成有些软件不能正常运行，比如点播软件就会停止播放音乐!2. teamviewerteamviewer是一款远程协助软件，个人使用免费，商业使用收费，需要在电脑端安装teamviewer，teamviewer如何使用手机控制电脑，可以看这篇文章《如何让手机控制电脑之TeamViewer 》最近teamviewer经常会出现判断为商业应用，然后5分钟中止连接，实际只有1分钟多点就中止连接了，如使用手机连接显示这样，在电脑中被判断为商业用途还可以使用reset id程序重置teamviewer id(电脑中如何重置teamviewer ID，可以看《teamviewer 13破解方法-teamviewer 13 重置ID 》和《破解 teamviewer 12的5分钟商业用途判断－teamviewer 12 ID重置》 这两篇文章及下载相关程序，破解方法是泰国网站提供的，网站打开速度较慢)，teamviewer安卓手机被判定为商业用途怎么办呢？我们可以在手机中安装 双开助手 app，双开助手很多，但使用的是这一个http://www.multiopen.cn/ 这个双开助手可以模拟手机的IMEI，在双开助手中新开teamviewer，teamviewer ID会重新生成，成功解决了teamviewer手机判定为商业用途的问题! teamviewer的优点就是可以访问任何连网的机器，而不需要映射端口，内网对内网，内网对外网，外网对内网都可以访问！teamviewer是通过了teamviewer的服务器中转认证的，所以无需要映射端口。teamviewer远程连接后不会改变当前的会话，对当前正在运行的程序没有任何影响!缺点是teamviewer个人使用免费，商业用途收费，teamviewer被国内公司代理后，如果同一个teamviewer经常连接多个teamviewer ID，会被判定为商业用途，teamviewer收费还很贵!3. vncvnc在windows系统中安装vnc服务端，如http://www.tightvnc.com/ 的tvnc，是开源免费的，在手机端安装vnc viewer vnc viewer手机界面如下vnc的优点是免费开源，自己会c++，完全可以自定义vnc的服务端和客户端，但apk是realvnc的，不开源，tvnc网站也提供有app，vnc方式远程登录也不会更新当前会话，对正在运行的程序没有影响，vnc是跨平台的，vnc服务端可以安装在linux,windows,mac机器， 也就是手机可以控制各个平台的系统。缺点vnc内网也需要映射端口，并且vnc的密码只能8位，默认还是空密码（造成好多肉机存在），密码也是保存在注册表中的，还原密码程序也存在，不够安全!4. 向日葵向日葵远程控制软件，也支持移动设备远程访问电脑，向日葵远程控制软件只远程桌面不收费，其他如传文件是收费的，向日葵远程控制软件就是花生壳公司出品的!免费远程限速300k，基本使用够用了! 电脑端的远程控制软件radmin，没有手机版app，在现在移动设备飞速发展的今天，实属遗憾!","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"控制电脑","slug":"控制电脑","permalink":"https://goodhelp.gitee.io/tags/%E6%8E%A7%E5%88%B6%E7%94%B5%E8%84%91/"}]},{"title":"如何自定义编译CheatEngine6.7","slug":"article/如何自定义编译CheatEngine6-7","date":"2018-05-08T03:13:49.000Z","updated":"2021-09-17T00:24:48.619Z","comments":true,"path":"page/1225249485/","link":"","permalink":"https://goodhelp.gitee.io/page/1225249485/","excerpt":"如何自定义编译Cheat Engine6.7(打造自己的CE6.7修改器，避免部分游戏的检测)Cheat Engine(作弊引擎ce) 是一款内存修改编辑工具 ，它允许你修改你的游戏或软件内存数据，以得到一些其他功能。它包括16进制编辑，反汇编程序，内存查找工具。与同类修改工具相比，它具有强大的反汇编功能，且自身附带了外挂制作工具，可以用它直接生成外挂。Cheat Engine的开发语言是pascal,采用Lazarus IDE开发!Cheat Engine是一个开源软件！Cheat Engine开源地址： https://github.com/cheat-engine/cheat-engineCheat Engine 官方网站：http://cheatengine.org/ 官方有编译好的版本，如果没有专门检测CE的程序，那么使用官方的CE就足够了，直接下载就可以运行!但现在很多游戏或程序对CE有检测，直接下载官方的CE会无法运行。这时我们可以自己编译Cheat Engine，当前官方最新版本为6.7，所以我们这儿介绍Cheat Engine6.7的修改及编译，避免部份游戏检测CE! 前期工作： 需要使用到的软件及ce源码等下载地址： lazarus-1.6.4-fpc-3.0.2-win64.exe下载地址(Cheat Engine6.7是使用的lazarus1.6.4编译，所以必须下载1.6.4，此文件是64位的lazarus1.6.4的主安装文件)官方推荐第三方下载链接：https://sourceforge.net/projects/lazarus/files/Lazarus%20Windows%2064%20bits/百脑问提供的百度云下载链接：https://pan.baidu.com/s/1VIRTU57RikwSMk1X15RP2w 密码：mbwj lazarus-1.6.4-fpc-3.0.2-cross-i386-win32-win64.exe(此文件是lazarus1.6.4编译为32位程序的补丁包)官方推荐第三方下载链接：https://sourceforge.net/projects/lazarus/files/Lazarus%20Windows%2064%20bits/百脑问提供的百度云下载链接：https://pan.baidu.com/s/1iGnpHnOor2ygiz4TaY3OJw 密码：bt8s cheat-engine-6.7.zip(Cheat Engine6.7的源码包，你可以直接到https://github.com/cheat-engine/cheat-engine 下载)百脑问提供的百度云下载链接：https://pan.baidu.com/s/1bXTJkn6lHCFmOKc2AoJjEw 密码：68×2 安装好 lazarus-1.6.4-fpc-3.0.2-win64.exe和lazarus-1.6.4-fpc-3.0.2-cross-i386-win32-win64.exe 解开cheat-engine-6.7.zip源码包! 进入CE源码包的Cheat Engine目录，找到cheatengine.lpi，双击打开! 自定义cheatengine6.7如果你熟悉lazarus的使用就可以轻松的修改Cheat Engine的源文件了，以下是假如你不了解lazarus的使用，仅仅是为了不让程序检测到ce而自定义ce！ 前面的源码中双击cheatengine.lpi打开后的界面，象这样第一步，我们修改ce的标题，按Shift+F12(也可以点击上面所示图中的第二行的第二个图标)打开窗口管理器，找到MainForm，双击打开，然后在Object Inspector窗口(如果没有显示Object Inspector窗口，可以在view菜单中点击Object Inspector打开，或者按F11打开)中单击MainForm:TMainForm 在下面的Properties选项卡中，找到Caption，修改后面的Cheat Engine 6.8为自己的标题，比如这儿修改为C_BnWin.Com_E6.7，然后Ctrl+O找到MainUnit2.pas打开，修改第16行的Cheat Engine 6.8 Beta 1为自己的标题，如这儿修改为C_BnWin.Com_E6.7","text":"如何自定义编译Cheat Engine6.7(打造自己的CE6.7修改器，避免部分游戏的检测)Cheat Engine(作弊引擎ce) 是一款内存修改编辑工具 ，它允许你修改你的游戏或软件内存数据，以得到一些其他功能。它包括16进制编辑，反汇编程序，内存查找工具。与同类修改工具相比，它具有强大的反汇编功能，且自身附带了外挂制作工具，可以用它直接生成外挂。Cheat Engine的开发语言是pascal,采用Lazarus IDE开发!Cheat Engine是一个开源软件！Cheat Engine开源地址： https://github.com/cheat-engine/cheat-engineCheat Engine 官方网站：http://cheatengine.org/ 官方有编译好的版本，如果没有专门检测CE的程序，那么使用官方的CE就足够了，直接下载就可以运行!但现在很多游戏或程序对CE有检测，直接下载官方的CE会无法运行。这时我们可以自己编译Cheat Engine，当前官方最新版本为6.7，所以我们这儿介绍Cheat Engine6.7的修改及编译，避免部份游戏检测CE! 前期工作： 需要使用到的软件及ce源码等下载地址： lazarus-1.6.4-fpc-3.0.2-win64.exe下载地址(Cheat Engine6.7是使用的lazarus1.6.4编译，所以必须下载1.6.4，此文件是64位的lazarus1.6.4的主安装文件)官方推荐第三方下载链接：https://sourceforge.net/projects/lazarus/files/Lazarus%20Windows%2064%20bits/百脑问提供的百度云下载链接：https://pan.baidu.com/s/1VIRTU57RikwSMk1X15RP2w 密码：mbwj lazarus-1.6.4-fpc-3.0.2-cross-i386-win32-win64.exe(此文件是lazarus1.6.4编译为32位程序的补丁包)官方推荐第三方下载链接：https://sourceforge.net/projects/lazarus/files/Lazarus%20Windows%2064%20bits/百脑问提供的百度云下载链接：https://pan.baidu.com/s/1iGnpHnOor2ygiz4TaY3OJw 密码：bt8s cheat-engine-6.7.zip(Cheat Engine6.7的源码包，你可以直接到https://github.com/cheat-engine/cheat-engine 下载)百脑问提供的百度云下载链接：https://pan.baidu.com/s/1bXTJkn6lHCFmOKc2AoJjEw 密码：68×2 安装好 lazarus-1.6.4-fpc-3.0.2-win64.exe和lazarus-1.6.4-fpc-3.0.2-cross-i386-win32-win64.exe 解开cheat-engine-6.7.zip源码包! 进入CE源码包的Cheat Engine目录，找到cheatengine.lpi，双击打开! 自定义cheatengine6.7如果你熟悉lazarus的使用就可以轻松的修改Cheat Engine的源文件了，以下是假如你不了解lazarus的使用，仅仅是为了不让程序检测到ce而自定义ce！ 前面的源码中双击cheatengine.lpi打开后的界面，象这样第一步，我们修改ce的标题，按Shift+F12(也可以点击上面所示图中的第二行的第二个图标)打开窗口管理器，找到MainForm，双击打开，然后在Object Inspector窗口(如果没有显示Object Inspector窗口，可以在view菜单中点击Object Inspector打开，或者按F11打开)中单击MainForm:TMainForm 在下面的Properties选项卡中，找到Caption，修改后面的Cheat Engine 6.8为自己的标题，比如这儿修改为C_BnWin.Com_E6.7，然后Ctrl+O找到MainUnit2.pas打开，修改第16行的Cheat Engine 6.8 Beta 1为自己的标题，如这儿修改为C_BnWin.Com_E6.7 第二步，我们修改CE的图标 按Shift+Ctrl+F11在打开的窗口左边选中Project Option的Application 右边点击Load ICO，选择一个ico就可以修改ce的图标了! 第三步，编译32位的CE和64位的CE，和上面一样按Shift+Ctrl+F11 选中Compiler Options，右边下拉框中，选择Release 32-Bit，编译出的CE就是32位的 选择Release 64-Bit 编译出的CE就是64位的! 第四步，修改完成后，Ctrl+F9编译，在bin目录就会生成CE可执行文件了，32位和64位的CE编译后可执行文件应该为cheatengine-i386.exe和cheatengine-x86_64.exe 当然你也可以修改其他的相关信息，也可以加一些其他代码到CE的源代码中，这样就更不会检测到属于你自己的CE了! 下面是自定义Cheat Engine的视频教程! 下面是百脑问bnwin.com自定义专用的CE6.7下载地址： 链接：https://pan.baidu.com/s/1TUCMpNo90H194u927ce3ug 密码：f35t","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"ce技巧","slug":"ce技巧","permalink":"https://goodhelp.gitee.io/tags/ce%E6%8A%80%E5%B7%A7/"},{"name":"基址查找方法","slug":"基址查找方法","permalink":"https://goodhelp.gitee.io/tags/%E5%9F%BA%E5%9D%80%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95/"}]},{"title":"如何快速让cef、wke、blink等支持mp4和mp3","slug":"article/如何快速让cef、wke、blink等支持mp4和mp3","date":"2018-05-02T03:09:20.000Z","updated":"2021-09-16T23:37:15.087Z","comments":true,"path":"page/3317533050/","link":"","permalink":"https://goodhelp.gitee.io/page/3317533050/","excerpt":"如何快速让cef、wke、blink等支持mp4和mp3(支持html5的video和audio标签)?在cef中，默认是不支持mp3和mp4的，使用cef控件写的软件打开带有video或audio标签的视频或音频是会播放失败的!一种方法就是自己重新编译cef的库，加入支持mp3和mp4的支持。如何编译看这篇文章 如何让dcef3支持mp3和h.264 mp4解码播放(有源码及dll)! 这是从文件的本身出发，修改后支持mp3和mp4，从另一方面来说，采用cef的精简版控件，比如wke,blink或低版本的ie等，修改文件重新编译支持mp3和mp4的方法就不可行了!能不能不修改文件直接支持mp3和mp4的video和audio标签呢？这儿介绍一种修改html本身而不动浏览器控件文件的解决方法，当然你得有修改html文件的权限。 使用html5media让浏览器兼容&lt;Video&gt;&lt;Audio&gt;标签。html5media是一个开源项目html5media 官网：https://html5media.info/html5media 项目：https://github.com/etianen/html5mediahtml5media Wiki：https://github.com/etianen/html5media/wiki html5media 官网CDN:http://api.html5media.info/1.2.2/html5media.min.jshtml5media 国内CDN:http://www.bootcdn.cn/html5media/ 如何使用html5media？它只需要一行代码就可以使HTML5的video和audio标签在所有主流浏览器中都能正常工作。只需要在html的head文档中添加如下代码 1&lt; script src = “ http://api.html5media.info/1.1.8/html5media.min.js ” &gt; &lt;/ script &gt; 然后按照html5的video标签添加的视频 1&lt; video src=&quot;video.mp4&quot; preload=&quot;&quot; controls=&quot;controls&quot; width=&quot;320&quot; height=&quot;200&quot;&gt; 按照html5的audio标签添加的音频","text":"如何快速让cef、wke、blink等支持mp4和mp3(支持html5的video和audio标签)?在cef中，默认是不支持mp3和mp4的，使用cef控件写的软件打开带有video或audio标签的视频或音频是会播放失败的!一种方法就是自己重新编译cef的库，加入支持mp3和mp4的支持。如何编译看这篇文章 如何让dcef3支持mp3和h.264 mp4解码播放(有源码及dll)! 这是从文件的本身出发，修改后支持mp3和mp4，从另一方面来说，采用cef的精简版控件，比如wke,blink或低版本的ie等，修改文件重新编译支持mp3和mp4的方法就不可行了!能不能不修改文件直接支持mp3和mp4的video和audio标签呢？这儿介绍一种修改html本身而不动浏览器控件文件的解决方法，当然你得有修改html文件的权限。 使用html5media让浏览器兼容&lt;Video&gt;&lt;Audio&gt;标签。html5media是一个开源项目html5media 官网：https://html5media.info/html5media 项目：https://github.com/etianen/html5mediahtml5media Wiki：https://github.com/etianen/html5media/wiki html5media 官网CDN:http://api.html5media.info/1.2.2/html5media.min.jshtml5media 国内CDN:http://www.bootcdn.cn/html5media/ 如何使用html5media？它只需要一行代码就可以使HTML5的video和audio标签在所有主流浏览器中都能正常工作。只需要在html的head文档中添加如下代码 1&lt; script src = “ http://api.html5media.info/1.1.8/html5media.min.js ” &gt; &lt;/ script &gt; 然后按照html5的video标签添加的视频 1&lt; video src=&quot;video.mp4&quot; preload=&quot;&quot; controls=&quot;controls&quot; width=&quot;320&quot; height=&quot;200&quot;&gt; 按照html5的audio标签添加的音频 1&lt;audio src=&quot;audio.mp3&quot; controls preload&gt; 都可以正常播放了! html5media的原理就是把不支持&lt;Video&gt;&lt;Audio&gt;标签的替换为使用flash播放！ 这样使用html5media后，cef、wke、blink等所有浏览器都支持html5的video和audio标签了! 如果你是使用wke或blink在自己的程序界面中添加显示mp4或mp3，那么你需要自己把html5media.min.js和flowplayer.audio.swf flowplayer.controls.swf flowplayer.swf文件全部下载到你的程序目录(js文件和swf放在同一目录)，在你的程序中就可以在wke或blink中使用video或audio标签了!","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"cef技巧","slug":"cef技巧","permalink":"https://goodhelp.gitee.io/tags/cef%E6%8A%80%E5%B7%A7/"}]},{"title":"delphi如何实现php中的parse_url网址拆分函数?","slug":"article/delphi如何实现php中的parse-url网址拆分函数","date":"2018-04-12T03:07:05.000Z","updated":"2021-09-16T23:42:10.296Z","comments":true,"path":"page/3056921327/","link":"","permalink":"https://goodhelp.gitee.io/page/3056921327/","excerpt":"php中拆分URL的一个很重要的函数就是parse_url();但在delphi如何不正则分析就可以实现如此方便的功能呢？实际上delphi的indy有一个单元实现此功能-IdURI单元，实现如下分拆 1234http://login:password@somehost.somedomain.com:8080/some_path/something.html?param1=val&amp;param2=val#nose\\__/ \\___/ \\______/ \\_____________________/ \\__/\\_______________________/ \\___________________/ \\__/ | | | | | | | |Scheme Username Password Host Port Path Query Fragment 123456789101112131415161718uses ..., IdURI; var URI: TIdURI; URI := TIdURI.Create(&#x27;http://login:password@somehost.somedomain.com:8080/some_path/something_else.html?param1=val&amp;param2=val&#x27;);try Protocol = URI.Protocol Username = URI.Username Password = URI.Password Host = URI.Host Port = URI.Port Path = URI.Path Query = URI.Paramsfinally URI.Free;end; 以下是使用InternetCrackUrl方法实现(依赖windows的WinInet库) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#123;$APPTYPE CONSOLE&#125; uses Windows, SysUtils, WinInet; procedure ParseURL(const lpszUrl: string);var lpszScheme : array[0..INTERNET_MAX_SCHEME_LENGTH - 1] of Char; lpszHostName : array[0..INTERNET_MAX_HOST_NAME_LENGTH - 1] of Char; lpszUserName : array[0..INTERNET_MAX_USER_NAME_LENGTH - 1] of Char; lpszPassword : array[0..INTERNET_MAX_PASSWORD_LENGTH - 1] of Char; lpszUrlPath : array[0..INTERNET_MAX_PATH_LENGTH - 1] of Char; lpszExtraInfo : array[0..1024 - 1] of Char; lpUrlComponents : TURLComponents;begin ZeroMemory(@lpszScheme, SizeOf(lpszScheme)); ZeroMemory(@lpszHostName, SizeOf(lpszHostName)); ZeroMemory(@lpszUserName, SizeOf(lpszUserName)); ZeroMemory(@lpszPassword, SizeOf(lpszPassword)); ZeroMemory(@lpszUrlPath, SizeOf(lpszUrlPath)); ZeroMemory(@lpszExtraInfo, SizeOf(lpszExtraInfo)); ZeroMemory(@lpUrlComponents, SizeOf(TURLComponents)); lpUrlComponents.dwStructSize := SizeOf(TURLComponents); lpUrlComponents.lpszScheme := lpszScheme; lpUrlComponents.dwSchemeLength := SizeOf(lpszScheme); lpUrlComponents.lpszHostName := lpszHostName; lpUrlComponents.dwHostNameLength := SizeOf(lpszHostName); lpUrlComponents.lpszUserName := lpszUserName; lpUrlComponents.dwUserNameLength := SizeOf(lpszUserName); lpUrlComponents.lpszPassword := lpszPassword; lpUrlComponents.dwPasswordLength := SizeOf(lpszPassword); lpUrlComponents.lpszUrlPath := lpszUrlPath; lpUrlComponents.dwUrlPathLength := SizeOf(lpszUrlPath); lpUrlComponents.lpszExtraInfo := lpszExtraInfo; lpUrlComponents.dwExtraInfoLength := SizeOf(lpszExtraInfo); InternetCrackUrl(PChar(lpszUrl), Length(lpszUrl), ICU_DECODE or ICU_ESCAPE, lpUrlComponents); Writeln(Format(&#x27;Protocol : %s&#x27;,[lpszScheme])); Writeln(Format(&#x27;Host : %s&#x27;,[lpszHostName])); Writeln(Format(&#x27;User : %s&#x27;,[lpszUserName])); Writeln(Format(&#x27;Password : %s&#x27;,[lpszPassword])); Writeln(Format(&#x27;Path : %s&#x27;,[lpszUrlPath])); Writeln(Format(&#x27;ExtraInfo: %s&#x27;,[lpszExtraInfo]));end; begin try ParseURL(&#x27;http://login:password@somehost.somedomain.com/some_path/something_else.html?param1=val&amp;param2=val&#x27;); except on E: Exception do Writeln(E.ClassName, &#x27;: &#x27;, E.Message); end; readln;end. 以上运行输出效果Protocol : httpHost : somehost.somedomain.comUser : loginPassword : passwordPath : /some_path/something_else.htmlExtraInfo: ?param1=val&amp;param2=val","text":"php中拆分URL的一个很重要的函数就是parse_url();但在delphi如何不正则分析就可以实现如此方便的功能呢？实际上delphi的indy有一个单元实现此功能-IdURI单元，实现如下分拆 1234http://login:password@somehost.somedomain.com:8080/some_path/something.html?param1=val&amp;param2=val#nose\\__/ \\___/ \\______/ \\_____________________/ \\__/\\_______________________/ \\___________________/ \\__/ | | | | | | | |Scheme Username Password Host Port Path Query Fragment 123456789101112131415161718uses ..., IdURI; var URI: TIdURI; URI := TIdURI.Create(&#x27;http://login:password@somehost.somedomain.com:8080/some_path/something_else.html?param1=val&amp;param2=val&#x27;);try Protocol = URI.Protocol Username = URI.Username Password = URI.Password Host = URI.Host Port = URI.Port Path = URI.Path Query = URI.Paramsfinally URI.Free;end; 以下是使用InternetCrackUrl方法实现(依赖windows的WinInet库) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#123;$APPTYPE CONSOLE&#125; uses Windows, SysUtils, WinInet; procedure ParseURL(const lpszUrl: string);var lpszScheme : array[0..INTERNET_MAX_SCHEME_LENGTH - 1] of Char; lpszHostName : array[0..INTERNET_MAX_HOST_NAME_LENGTH - 1] of Char; lpszUserName : array[0..INTERNET_MAX_USER_NAME_LENGTH - 1] of Char; lpszPassword : array[0..INTERNET_MAX_PASSWORD_LENGTH - 1] of Char; lpszUrlPath : array[0..INTERNET_MAX_PATH_LENGTH - 1] of Char; lpszExtraInfo : array[0..1024 - 1] of Char; lpUrlComponents : TURLComponents;begin ZeroMemory(@lpszScheme, SizeOf(lpszScheme)); ZeroMemory(@lpszHostName, SizeOf(lpszHostName)); ZeroMemory(@lpszUserName, SizeOf(lpszUserName)); ZeroMemory(@lpszPassword, SizeOf(lpszPassword)); ZeroMemory(@lpszUrlPath, SizeOf(lpszUrlPath)); ZeroMemory(@lpszExtraInfo, SizeOf(lpszExtraInfo)); ZeroMemory(@lpUrlComponents, SizeOf(TURLComponents)); lpUrlComponents.dwStructSize := SizeOf(TURLComponents); lpUrlComponents.lpszScheme := lpszScheme; lpUrlComponents.dwSchemeLength := SizeOf(lpszScheme); lpUrlComponents.lpszHostName := lpszHostName; lpUrlComponents.dwHostNameLength := SizeOf(lpszHostName); lpUrlComponents.lpszUserName := lpszUserName; lpUrlComponents.dwUserNameLength := SizeOf(lpszUserName); lpUrlComponents.lpszPassword := lpszPassword; lpUrlComponents.dwPasswordLength := SizeOf(lpszPassword); lpUrlComponents.lpszUrlPath := lpszUrlPath; lpUrlComponents.dwUrlPathLength := SizeOf(lpszUrlPath); lpUrlComponents.lpszExtraInfo := lpszExtraInfo; lpUrlComponents.dwExtraInfoLength := SizeOf(lpszExtraInfo); InternetCrackUrl(PChar(lpszUrl), Length(lpszUrl), ICU_DECODE or ICU_ESCAPE, lpUrlComponents); Writeln(Format(&#x27;Protocol : %s&#x27;,[lpszScheme])); Writeln(Format(&#x27;Host : %s&#x27;,[lpszHostName])); Writeln(Format(&#x27;User : %s&#x27;,[lpszUserName])); Writeln(Format(&#x27;Password : %s&#x27;,[lpszPassword])); Writeln(Format(&#x27;Path : %s&#x27;,[lpszUrlPath])); Writeln(Format(&#x27;ExtraInfo: %s&#x27;,[lpszExtraInfo]));end; begin try ParseURL(&#x27;http://login:password@somehost.somedomain.com/some_path/something_else.html?param1=val&amp;param2=val&#x27;); except on E: Exception do Writeln(E.ClassName, &#x27;: &#x27;, E.Message); end; readln;end. 以上运行输出效果Protocol : httpHost : somehost.somedomain.comUser : loginPassword : passwordPath : /some_path/something_else.htmlExtraInfo: ?param1=val&amp;param2=val","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"delphi技巧","slug":"delphi技巧","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%8A%80%E5%B7%A7/"}]},{"title":"自定义8圈桌面侧边栏_领航桌面侧边栏原理","slug":"soft/自定义8圈桌面侧边栏-领航桌面侧边栏原理","date":"2018-03-30T13:49:14.000Z","updated":"2021-09-12T00:10:27.428Z","comments":true,"path":"page/1077583104/","link":"","permalink":"https://goodhelp.gitee.io/page/1077583104/","excerpt":"本软件适用于不想使用营销软件，不想关闭8圈桌面侧边栏，只想把8圈桌面侧边栏遮挡（就象领航桌面侧边栏一样把8圈的桌面侧边栏遮挡），虽然不想用营销软件但又想自定义桌面侧边栏! 那么你可以使用本自定义8圈桌面侧边栏！本软件不修改8圈任何文件，不影响8圈系统的正常功能!完全独立于8圈。在网吧环境中，有时我们想不使用营销活动，不计积分，不发红包，不搞游戏活动等等，只是想使用一下呼叫网管，点歌，显示一下网吧公告等基本的功能!最重要的一点，不想使用营销软件，因为使用这些基本功能，营销软件会有广告,还有一点，在8圈计费系统中，不希望看到8圈桌面那毫无美感而不能更改的侧边栏!本软件就是适用于以上环境!功能如下 遮挡8圈桌面侧边栏删除本软件目录中的config.ini文件，运行本软件，自动遮档8圈桌面侧边栏，原理和领航营销软件2.0遮挡8圈桌面侧边栏一样! 可自定义侧边栏在本软件skin目录中，内置了领航1.0的桌面侧边栏6款皮肤，领航2.0的桌面侧边栏，和网乐的一款桌面皮肤!只需要在config.ini中设置皮肤名称就可以显示类似营销软件的界面,比如设置 皮肤=lhv2 运行本软件则会显示领航2.0的桌面侧边栏皮肤!最重要的是你可以把桌面侧边完全当成画板，自定义桌面侧边哪儿显示什么，如何显示，只要你会html，css，js其他的语法，那么强大的自定义桌面侧边栏就会由你说了算! 自定义的侧边栏链接可运行任何程序比如在自定义侧边栏的html文件中添加一个链接 那么我们只需要添加一个onclick事件，象这样就是点击这个链接，运行机器中的计算器程序。点击桌面侧边栏就运行程序的命令是 onclick=’javascript:external.Run(“可执行程序完整路径”,”运行参数”)’ 其中可执行程序完整路径的斜杠需要是/ 你可以参照本软件目录的skin目录中的html皮肤修改!这样我们就可以只使用营销软件的服务端，而不使用营销软件的客户端，本软件可以和网乐营销软件服务端有效完美结合，而不使用网乐营销软件的客户端。使用其他营销软件的服务端也大同小异!比如我们想在桌面侧边栏显示美化的在线充值按钮，挂机，呼叫网管等，等只需要按照这样添加就行了！如果你想调用8圈的在线充值等功能，可以结合本站的http://www.bnwin.com/page/576111441/软件使用! 如果你在8圈系统中使用了营销软件，请不要使用本软件!本软件必须运行在有8圈桌面侧边栏的环境，没有8圈桌面侧边栏，运行会什么也不会显示！如果你只是想不显示8圈桌面侧边栏，请看这儿http://www.bnwin.com/page/3211467574/ 看看运行效果软件下载地址链接: https://pan.baidu.com/s/1QK67GHENwYxyuHyirvhwiQ 提取码: rvja 复制这段内容后打开百度网盘手机App，操作更方便哦如果你觉得自带桌面侧边栏样式，不符合你的美感，你也不会html，我们可以有偿桌面侧边栏皮肤定制! 使用此软件方法绝不会提示计费系统异常，如下这种情况! 本软件已停止更新，仅适合于八圈9.5以下版本","text":"本软件适用于不想使用营销软件，不想关闭8圈桌面侧边栏，只想把8圈桌面侧边栏遮挡（就象领航桌面侧边栏一样把8圈的桌面侧边栏遮挡），虽然不想用营销软件但又想自定义桌面侧边栏! 那么你可以使用本自定义8圈桌面侧边栏！本软件不修改8圈任何文件，不影响8圈系统的正常功能!完全独立于8圈。在网吧环境中，有时我们想不使用营销活动，不计积分，不发红包，不搞游戏活动等等，只是想使用一下呼叫网管，点歌，显示一下网吧公告等基本的功能!最重要的一点，不想使用营销软件，因为使用这些基本功能，营销软件会有广告,还有一点，在8圈计费系统中，不希望看到8圈桌面那毫无美感而不能更改的侧边栏!本软件就是适用于以上环境!功能如下 遮挡8圈桌面侧边栏删除本软件目录中的config.ini文件，运行本软件，自动遮档8圈桌面侧边栏，原理和领航营销软件2.0遮挡8圈桌面侧边栏一样! 可自定义侧边栏在本软件skin目录中，内置了领航1.0的桌面侧边栏6款皮肤，领航2.0的桌面侧边栏，和网乐的一款桌面皮肤!只需要在config.ini中设置皮肤名称就可以显示类似营销软件的界面,比如设置 皮肤=lhv2 运行本软件则会显示领航2.0的桌面侧边栏皮肤!最重要的是你可以把桌面侧边完全当成画板，自定义桌面侧边哪儿显示什么，如何显示，只要你会html，css，js其他的语法，那么强大的自定义桌面侧边栏就会由你说了算! 自定义的侧边栏链接可运行任何程序比如在自定义侧边栏的html文件中添加一个链接 那么我们只需要添加一个onclick事件，象这样就是点击这个链接，运行机器中的计算器程序。点击桌面侧边栏就运行程序的命令是 onclick=’javascript:external.Run(“可执行程序完整路径”,”运行参数”)’ 其中可执行程序完整路径的斜杠需要是/ 你可以参照本软件目录的skin目录中的html皮肤修改!这样我们就可以只使用营销软件的服务端，而不使用营销软件的客户端，本软件可以和网乐营销软件服务端有效完美结合，而不使用网乐营销软件的客户端。使用其他营销软件的服务端也大同小异!比如我们想在桌面侧边栏显示美化的在线充值按钮，挂机，呼叫网管等，等只需要按照这样添加就行了！如果你想调用8圈的在线充值等功能，可以结合本站的http://www.bnwin.com/page/576111441/软件使用! 如果你在8圈系统中使用了营销软件，请不要使用本软件!本软件必须运行在有8圈桌面侧边栏的环境，没有8圈桌面侧边栏，运行会什么也不会显示！如果你只是想不显示8圈桌面侧边栏，请看这儿http://www.bnwin.com/page/3211467574/ 看看运行效果软件下载地址链接: https://pan.baidu.com/s/1QK67GHENwYxyuHyirvhwiQ 提取码: rvja 复制这段内容后打开百度网盘手机App，操作更方便哦如果你觉得自带桌面侧边栏样式，不符合你的美感，你也不会html，我们可以有偿桌面侧边栏皮肤定制! 使用此软件方法绝不会提示计费系统异常，如下这种情况! 本软件已停止更新，仅适合于八圈9.5以下版本","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"八圈","slug":"八圈","permalink":"https://goodhelp.gitee.io/tags/%E5%85%AB%E5%9C%88/"},{"name":"原创软件","slug":"原创软件","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%9F%E5%88%9B%E8%BD%AF%E4%BB%B6/"}]},{"title":"如何取得窗口的Z序","slug":"article/如何取得窗口的Z序","date":"2018-03-30T03:04:04.000Z","updated":"2021-09-16T23:36:36.346Z","comments":true,"path":"page/2238981937/","link":"","permalink":"https://goodhelp.gitee.io/page/2238981937/","excerpt":"如何取得窗口的Z序_How to get the window`s z-order?Z 序：一个重叠窗口的堆，每个窗口在Z 序中 都有唯一一个位置。一个窗口的Z 序 ，指明了该窗口在重叠窗口堆中的位置。这个窗口堆 是沿着一个虚拟的轴——“ Z 轴”，从屏幕上垂直向屏幕外延伸。 Z 序顶部的窗口覆盖 Z 序中的其他窗口。 Z 序底部的窗口被 Z 序中的其他窗口覆盖。 系统用一个单链表维护 Z 序。系统按照顶端窗口、顶层窗口和子窗口的分类 ，将窗口插入到 Z 序表中。顶端窗口覆盖其他所有非顶端窗口，而不管它是不是活动窗口或是不是前台窗口。顶端窗口有 WS_EX_TOPMOST 风格。在 Z 序中，所有顶端窗口都在非顶端窗口之前。在 Z 序中，子窗口是按着他的父窗口进行分组的。 应用程序一旦创建了一个窗口，系统就将其放入Z 序中 同类窗口的顶部。可以调用 BringWindowToTop() 函数，把某窗口拉到 Z 序中同类窗口的顶部。可以利用 SetWindowPos() 和 DeferWindowPos() 函数对 Z 序进行重新排列。 用户在激活不同的窗口过程中会改变 Z 序。因为系统会将活动窗口，放置在 Z 序中同类窗口的顶部 。当一个窗口变成 Z 序中的顶层窗口时，它的所有子窗口也变为顶层窗口。可以用 GetTopWindow() 来查找一个父窗口的所有子窗口，并返回（ Z 序中）顶部子窗口的句柄。用 GetNextWindow() 函数，可以获得 Z 序中的前一个或后一个窗口的句柄。 对于顶端窗口，顶层窗口和子窗口，如果只考虑同一类的话，如果有多个，总会一个覆盖另一个。但是这三类是按照上面讲的排列的。也就是有人讲的：1.TopMost在最上面2，顶级窗口次之3，子窗口在父窗口之上4，同级窗口当前激活窗口在前 HDWP hdwp = BeginDeferWindowPos(2); hdwp = DeferWindowPos( hdwp, hStatic, NULL, 0, 0,100, 20, SWP_NOACTIVATE | SWP_NOZORDER |SWP_NOMOVE );hdwp = DeferWindowPos( hdwp, hEdit, NULL, 0, 0, 100, 20, SWP_NOACTIVATE | SWP_NOZORDER |SWP_NOMOVE );EndDeferWindowPos( hdwp ); 其作用和SetWindowPos()差不多。 6.HWND GetWindow(HWND hWnd,UINT uCmd)","text":"如何取得窗口的Z序_How to get the window`s z-order?Z 序：一个重叠窗口的堆，每个窗口在Z 序中 都有唯一一个位置。一个窗口的Z 序 ，指明了该窗口在重叠窗口堆中的位置。这个窗口堆 是沿着一个虚拟的轴——“ Z 轴”，从屏幕上垂直向屏幕外延伸。 Z 序顶部的窗口覆盖 Z 序中的其他窗口。 Z 序底部的窗口被 Z 序中的其他窗口覆盖。 系统用一个单链表维护 Z 序。系统按照顶端窗口、顶层窗口和子窗口的分类 ，将窗口插入到 Z 序表中。顶端窗口覆盖其他所有非顶端窗口，而不管它是不是活动窗口或是不是前台窗口。顶端窗口有 WS_EX_TOPMOST 风格。在 Z 序中，所有顶端窗口都在非顶端窗口之前。在 Z 序中，子窗口是按着他的父窗口进行分组的。 应用程序一旦创建了一个窗口，系统就将其放入Z 序中 同类窗口的顶部。可以调用 BringWindowToTop() 函数，把某窗口拉到 Z 序中同类窗口的顶部。可以利用 SetWindowPos() 和 DeferWindowPos() 函数对 Z 序进行重新排列。 用户在激活不同的窗口过程中会改变 Z 序。因为系统会将活动窗口，放置在 Z 序中同类窗口的顶部 。当一个窗口变成 Z 序中的顶层窗口时，它的所有子窗口也变为顶层窗口。可以用 GetTopWindow() 来查找一个父窗口的所有子窗口，并返回（ Z 序中）顶部子窗口的句柄。用 GetNextWindow() 函数，可以获得 Z 序中的前一个或后一个窗口的句柄。 对于顶端窗口，顶层窗口和子窗口，如果只考虑同一类的话，如果有多个，总会一个覆盖另一个。但是这三类是按照上面讲的排列的。也就是有人讲的：1.TopMost在最上面2，顶级窗口次之3，子窗口在父窗口之上4，同级窗口当前激活窗口在前 HDWP hdwp = BeginDeferWindowPos(2); hdwp = DeferWindowPos( hdwp, hStatic, NULL, 0, 0,100, 20, SWP_NOACTIVATE | SWP_NOZORDER |SWP_NOMOVE );hdwp = DeferWindowPos( hdwp, hEdit, NULL, 0, 0, 100, 20, SWP_NOACTIVATE | SWP_NOZORDER |SWP_NOMOVE );EndDeferWindowPos( hdwp ); 其作用和SetWindowPos()差不多。 6.HWND GetWindow(HWND hWnd,UINT uCmd) 此函数的作用是：返回与hWnd有某种关系的窗口的句柄，uCmd有以下几种意思： GW_CHILD ： 如果指定窗口是父窗口，则获得的是在Z序顶端的子窗口的句柄，否则为NULL。函数仅检查指定父窗口的子窗口，不检查继承窗口。 GW_ENABLEDPOUP： （WindowsNT 5.0）返回的句柄标识了属于指定窗口的处于使能状态弹出式窗口（检索使用第一个由GW_HWNDNEXT 查找到的满足前述条件的窗口）；如果无使能窗口，则获得的句柄与指定窗口相同。 GW_HWNDFIRST ：返回的句柄标识了在Z序最高端的相同类型的窗口。如果指定窗口是最高端窗口，则该句柄标识了在Z序最高端的最高端窗口；如果指定窗口是顶层窗口，则该句柄标识了在z序最高端的顶层窗口：如果指定窗口是子窗口，则句柄标识了在Z序最高端的同属窗口。 GW_HWNDLAST :返回的句柄标识了在z序最低端的相同类型的窗口。如果指定窗口是最高端窗口，则该柄标识了在z序最低端的最高端窗口：如果指定窗口是顶层窗口，则该句柄标识了在z序最低端的顶层窗口；如果指定窗口是子窗口，则句柄标识了在Z序最低端的同属窗口。 GW_HWNDNEXT ：返回的句柄标识了在Z序中指定窗口下的相同类型的窗口。如果指定窗口是最高端窗口，则该句柄标识了在指定窗口下的最高端窗口：如果指定窗口是顶层窗口，则该句柄标识了在指定窗口下的顶层窗口；如果指定窗口是子窗口，则句柄标识了在指定窗口下的同属窗口。 GW HWNDPREV ：返回的句柄标识了在Z序中指定窗口上的相同类型的窗口。如果指定窗口是最高端窗口，则该句柄标识了在指定窗口上的最高端窗口；如果指定窗口是顶层窗口，则该句柄标识了在指定窗口上的顶层窗口；如果指定窗口是子窗口，则句柄标识了在指定窗口上的同属窗口。GW_OWNER ：返回的句柄标识了指定窗口的所有者窗口（如果存在）。返回值：如果函数成功，返回值为窗口句柄；如果与指定窗口有特定关系的窗口不存在，则返回值为NULL。 C#取得z-order的代码 123456789101112131415161718192021222324252627282930313233343536using System;using System.Runtime.InteropServices; namespace Win32&#123; public static class HwndHelper &#123; [DllImport(&quot;user32.dll&quot;)] private static extern IntPtr GetWindow(IntPtr hWnd, uint uCmd); public static bool GetWindowZOrder(IntPtr hwnd, out int zOrder) &#123; const uint GW_HWNDPREV = 3; const uint GW_HWNDLAST = 1; var lowestHwnd = GetWindow(hwnd, GW_HWNDLAST); var z = 0; var hwndTmp = lowestHwnd; while (hwndTmp != IntPtr.Zero) &#123; if (hwnd == hwndTmp) &#123; zOrder = z; return true; &#125; hwndTmp = GetWindow(hwndTmp, GW_HWNDPREV); z++; &#125; zOrder = int.MinValue; return false; &#125; &#125;&#125; aardio取得z-order的代码(取得windows的Z序代码)如下 123456789101112131415function get_zorder(win_hwnd)&#123; var lowestHwnd = ::User32.GetWindow(win_hwnd,0x1/*_GW_HWNDLAST*/); var z=0; var hwndTmp=lowestHwnd; while (hwndTmp != 0) &#123; if (win_hwnd == hwndTmp) &#123; return z; &#125; hwndTmp = ::User32.GetWindow(hwndTmp,0x3); z++; &#125; return 0; &#125;","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"aardio技巧","slug":"aardio技巧","permalink":"https://goodhelp.gitee.io/tags/aardio%E6%8A%80%E5%B7%A7/"},{"name":"c#技巧","slug":"c-技巧","permalink":"https://goodhelp.gitee.io/tags/c-%E6%8A%80%E5%B7%A7/"}]},{"title":"ZIP一个没落天才的故事","slug":"other/ZIP一个没落天才的故事","date":"2018-03-27T14:59:39.000Z","updated":"2021-09-16T23:47:55.121Z","comments":true,"path":"page/4277289715/","link":"","permalink":"https://goodhelp.gitee.io/page/4277289715/","excerpt":"ZIP是什么？ *.ZIP，是一个文件的压缩的算法，原名Deflate（真空），发明者为菲利普·卡兹（Phil Katz)），他于1989年1月公布了该格式的资料。ZIP通常使用后缀名“.zip”，它的MIME格式为 application/zip 。目前，ZIP格式属于几种主流的压缩格式之一，其竞争者包括RAR格式以及开放源码的7-Zip格式。从性能上比较，RAR格式较ZIP格式压缩率较高，但是它的压缩时间远远高于Zip。而7-Zip(7z)由于提供了免费的压缩工具而逐渐在更多的领域得到应用。 Phil Katz不愿意为一个压缩软件付钱，就索性自己写了一个更好的算法，然后无偿公开。2000年4月14日，他被发现死于一家汽车旅馆，年仅37岁，死时手中握着一个空酒瓶。他留下了zip算法，却没有留下一张像样的照片。 久违了的zip在你的脑海里还能占据多少空间?或许，你跟本就把它忘记了。 记得刚上大学的2001年,在电脑报上看到过一篇介绍Philip Katz的文章，那时，我才知道，原来zip是曾经是那么的“不可一世”，那么广泛的被使用着。 Winzip的创始人是Philip Katz。用Ultraedit打开任一个zip文件，可以看到文件最前面PK两个字母，这便是zip文件格式的创始人Philip Katz的名字缩写。 在19年前，也就是公元1988年，那时候互联网还刚刚开始有了雏形，而最流行的是一种使用电话线拨号登陆别人在家里搭建的服务平台——交换信息的电子公告牌(BBS)系统。这种系统有些类似现在的论坛和新闻组，由于站长之间互相转信也成为了一个庞大的信息网络(惠多网)。 老一点的网虫可能都有印象，在没有 Internet的年代，中国大地上也曾有几十个这样的BBS存在，著名的字处理软件WPS的作者求伯君和CCED的作者朱崇君当年都是非常有名的个人站长。 由于电话线的接入速度慢的可怜，通过BBS传输较大文件实在是叫人痛苦的一件事。于是，使用文件压缩技术减小文件的体积并将多个文件压缩到一个封包中就成为了BBS用户的一项必须掌握的技巧。当时的美国BBS上，比较流行的是一种叫做ARC的压缩技术，由于它是一家商业公司开发的压缩技术，使用这种软件进行工作是需要付费的。那时候的菲利普·卡兹是一个沉迷于BBS 上的毛头小伙，由于经常混迹于BBS上，对于ARC的收费非常不满的他自己开发了一个程序叫PKARC，这个程序与ARC完全兼容，可以压缩和解压缩 ARC文件。这样一来，大批的ARC用户自然转而使用菲利普·卡兹的免费软件。ARC的制作公司一怒之下将菲利普·卡兹告上了法庭，法庭自然判决菲利普· 卡兹禁止继续开发和传播PKARC。这种判决并没有磨灭菲利普·卡兹的斗志，而是激起了他要与ARC斗争到底的决心。在虚拟的世界中，自由、平等永远是真正的程序员永久的追求。 他放弃了PKARC的开发，发誓要写出一款比ARC更好的压缩软件来打败ARC。这一场官司造就了一名编程天才的横空出世，也造就了一个后来在互联网时代的文件标准。几周以后，后来统治整个BBS世界乃至Internet世界的ZIP在菲利普·卡兹手中发出了第一声响亮的啼哭!","text":"ZIP是什么？ *.ZIP，是一个文件的压缩的算法，原名Deflate（真空），发明者为菲利普·卡兹（Phil Katz)），他于1989年1月公布了该格式的资料。ZIP通常使用后缀名“.zip”，它的MIME格式为 application/zip 。目前，ZIP格式属于几种主流的压缩格式之一，其竞争者包括RAR格式以及开放源码的7-Zip格式。从性能上比较，RAR格式较ZIP格式压缩率较高，但是它的压缩时间远远高于Zip。而7-Zip(7z)由于提供了免费的压缩工具而逐渐在更多的领域得到应用。 Phil Katz不愿意为一个压缩软件付钱，就索性自己写了一个更好的算法，然后无偿公开。2000年4月14日，他被发现死于一家汽车旅馆，年仅37岁，死时手中握着一个空酒瓶。他留下了zip算法，却没有留下一张像样的照片。 久违了的zip在你的脑海里还能占据多少空间?或许，你跟本就把它忘记了。 记得刚上大学的2001年,在电脑报上看到过一篇介绍Philip Katz的文章，那时，我才知道，原来zip是曾经是那么的“不可一世”，那么广泛的被使用着。 Winzip的创始人是Philip Katz。用Ultraedit打开任一个zip文件，可以看到文件最前面PK两个字母，这便是zip文件格式的创始人Philip Katz的名字缩写。 在19年前，也就是公元1988年，那时候互联网还刚刚开始有了雏形，而最流行的是一种使用电话线拨号登陆别人在家里搭建的服务平台——交换信息的电子公告牌(BBS)系统。这种系统有些类似现在的论坛和新闻组，由于站长之间互相转信也成为了一个庞大的信息网络(惠多网)。 老一点的网虫可能都有印象，在没有 Internet的年代，中国大地上也曾有几十个这样的BBS存在，著名的字处理软件WPS的作者求伯君和CCED的作者朱崇君当年都是非常有名的个人站长。 由于电话线的接入速度慢的可怜，通过BBS传输较大文件实在是叫人痛苦的一件事。于是，使用文件压缩技术减小文件的体积并将多个文件压缩到一个封包中就成为了BBS用户的一项必须掌握的技巧。当时的美国BBS上，比较流行的是一种叫做ARC的压缩技术，由于它是一家商业公司开发的压缩技术，使用这种软件进行工作是需要付费的。那时候的菲利普·卡兹是一个沉迷于BBS 上的毛头小伙，由于经常混迹于BBS上，对于ARC的收费非常不满的他自己开发了一个程序叫PKARC，这个程序与ARC完全兼容，可以压缩和解压缩 ARC文件。这样一来，大批的ARC用户自然转而使用菲利普·卡兹的免费软件。ARC的制作公司一怒之下将菲利普·卡兹告上了法庭，法庭自然判决菲利普· 卡兹禁止继续开发和传播PKARC。这种判决并没有磨灭菲利普·卡兹的斗志，而是激起了他要与ARC斗争到底的决心。在虚拟的世界中，自由、平等永远是真正的程序员永久的追求。 他放弃了PKARC的开发，发誓要写出一款比ARC更好的压缩软件来打败ARC。这一场官司造就了一名编程天才的横空出世，也造就了一个后来在互联网时代的文件标准。几周以后，后来统治整个BBS世界乃至Internet世界的ZIP在菲利普·卡兹手中发出了第一声响亮的啼哭! 不名则已，一鸣惊人，这种名为PKZIP的程序可以将一个或多个文件压缩到一个后缀为“.zip”的文件中，无论从压缩比、压缩速度方面都超过了商业软件 ARC。卡兹将PKZIP作为自由软件免费发放，使其如同草原上的星星之火般在全美的各大BBS上蔓延开来，用户以几何级数的增长，各大BBS的站长自发将原来使用ARC格式压缩的文件转换成ZIP格式，卡兹用他天才的头脑和顽强的毅力堂堂正正的击败了ARC，ARC的制作公司在PKZIP的强大攻势下很快就消声匿迹了。用自由软件打败商业公司的传奇故事很快传遍了整个BBS世界，疾恶如仇而又身手不凡的菲利普·卡兹如同数字世界的大侠般仗剑江湖，劫富济贫，以一人之力擎起了压缩软件的大旗。 此后卡兹一直继续着对 PKZIP的开发和维护工作，PKZIP建立和统治了DOS时代的压缩标准。直到Windows的诞生，使用卡兹创造的压缩算法的软件Winzip的出现更使ZIP格式成为Internet的传输标准，ZIP压缩格式也成为压缩文档的事实标准。 PKZIP及其“克隆”作品Winzip成为Internet历史上最有名的共享软件之一，ZIP压缩格式也成为压缩文档的事实标准，建立起一个统治Internet的“ZIP王朝”。菲利普·卡兹为世界贡献了一个伟大的共享软件，而他自己却几乎没有从中获得任何好处!因为从一开始，ZIP就是为了反抗收费的PKARC“而生”的。 但是，不良的生活习惯，长期巨大的精神压力，导致了潦倒无助的他在2000年的4月14号，死在了美国威斯康星州密尔沃基的一家汽车旅馆里，死时，手里还紧握着一个烈性酒的酒瓶。 Philip Katz从未在ZIP身上得到半点好处，坚持信念的结果往往是潦倒的生活，糟糕的个人生活和长期编写软件的巨大压力使卡兹染上了酗酒的恶习，最终断送了他那年轻的生命。他为世界贡献了一个伟大的免费软件，更为重要的是他缔造了一种大众化的压缩格式，然而却过早地离开了这个世界。 就在Philip Katz去世的前后，ZIP的最大对手：WINRAR，正在悄然崛起。当时Winzip早已稳坐压缩界头把交椅，但随着2.7版本的出现，Wrar却日益壮大，两者斗争得异常激烈(注：与Winzip一样，其实早在DOS时代，就存在RAR的DOS版本，只是RAR在DOS时代敌不过只能用命令行的ARJ，到了Windows时代又招架不住WinZip的进攻，皆因RAR压缩率低和速度慢，并且RAR压缩格式以前一直缺少其它软件的支持，导致WinRAR都未能广泛流行)。 就当时两者的性能而言，Winzip压缩只支持ZIP格式，解压缩支持ZIP、CAB，还有TAR、GZip、UUencode、XXencode、BinHex、MIME等几种Internet常用格式(可以看出WinZip的重心之所在)，ARJ、LHA和ARC则需要相应的外挂程序。但WinZip跟Windows资源管理器结合得很紧密，最常用的压缩和解压缩操作已集成到鼠标右键菜单中，点按右键即可轻松完成压缩解压缩。并且增加了不少人性化的功能如E-mail功能，分卷压缩，密码加密等;那Winrar又凭什么与其争锋呢?答案是格式支持与功能!WinRAR压缩格式支持自家的RAR和ZIP(即可“兼容”ZIP)，解压缩支持RAR、ZIP、CAB、ACE、ARJ、LHA、TAR、GZip、UUE，基本上常用的都有了。WinRAR在界面上类似WinZip在功能上基本是WinZip有的它都有，甚至有好多比WinZip还更好更强大。如有特色的”Repair archive”功能甚至可以修复损坏的zip文件;”Convert archive to SFX”功能把RAR和ZIP文件转换成自解压文件，同WinZip不同的是，在压缩时就可以直接存为自解压文件…取对手之精华，并改进之，这就是Winrar敢于与压缩界龙头叫板的原因。 或许到了这里，你会问：为什么zip不去支持rar呢?这样竞争不就“公平”了吗?但我告诉你的是：zip格式是开放的，任何压缩软件都可以免费使用，RAR是RARLab的专利算法，其它软件要想提供对Rar格式支持必须交纳费用以获得授权，如果winzip想要支持zip，就必须向rarlab付费，这根本就是拿自己的血汗去喂饱对手。我们须明白：winzip和winrar都是共享软件，中国人用惯了盗版的winrar，以为rar才是压缩格式的王道，如果自以为全天下的压缩软件都应该支持rar格式，那么只能说这是一种极其荒谬的认知。 虽然ZIP仍然是压缩文件的标准格式，但随着WinRAR的功能越来越强大，并且对ZIP的兼容性和ISO镜像文件的支持，固步自封的WinZip已经逐渐开始被网民们所遗忘。面临被打倒，昔日的强者做出了最后的反击–Winzip9.0。2004年发布的Winzip9.0是Winzip公司在02年后两年内第一次发布的Winzip软件更新，可见这次Winzip反击的决心。本版本的Winzip带来了很多新的功能特性，如：加密标准提高，支持符合AES技术的128位和256位的高级加密标准;支持64位扩展技术;内置了先进的“真空”压缩算法(Enhanced Deflate)等。这一切都是针对WinRAR 3.30，誓求夺回压缩界的王座。 可惜就像乔丹的最后出场一样，也许真的是老了，我们再难看到英雄昔日的光彩。 WinZip 9.0对压缩格式的支持并没有什么增加，支持原有的18种压缩格式，但仍然不支持ISO这一非常流行的镜像文件格式，并且最大的问题是不兼容RAR，这就令许多用户敬而远之了;相对而言，WinRAR 3.30目前的压缩格式虽然只有15种，但由于兼容ZIP和支持ISO，仅仅这两条就使不少WinZip的老用户心动神移了。 随着绝唱反击的失败，于2005年7月，WinZip被Vector Capital收购。 也许在天之灵的Philip Katz并没有想到有这一天，作为下载量达到1亿4000万次，成就压缩标准zip的Winzip计算公司好象没有考虑过用其技术来赚钱的事(实际上很少有人会在WinZip试用期过后支付29美元购买正版授权，因此WinZip至今都没有获得太多利润)。它为大家提供一款如此经典的压缩软件，曾经，它是何等辉煌，但如今却威风难再。或者正如歌词所说:”想回到过去，试着让故事继续，至少不再让你离我而去…”","categories":[{"name":"其他","slug":"其他","permalink":"https://goodhelp.gitee.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"人物故事","slug":"人物故事","permalink":"https://goodhelp.gitee.io/tags/%E4%BA%BA%E7%89%A9%E6%95%85%E4%BA%8B/"},{"name":"文章","slug":"文章","permalink":"https://goodhelp.gitee.io/tags/%E6%96%87%E7%AB%A0/"}]},{"title":"AE模板-动感极限运动动作电影游戏宣传片预告片信号损坏视频开场","slug":"material/AE模板-动感极限运动动作电影游戏宣传片预告片信号损坏视频开场","date":"2018-03-25T03:42:40.000Z","updated":"2021-09-11T16:42:39.904Z","comments":true,"path":"page/3714672010/","link":"","permalink":"https://goodhelp.gitee.io/page/3714672010/","excerpt":"包含信号损坏，亮度置换，多摄像机分屏，摄像机推拉等多种动画场景视频图片文字效果，所有的镜头都是单独模块化的，可以自己随意拖拽组合成自己的开场宣传视频，默认包含以下已经做好的视频片头，可以直接使用： 开场视频风格 V1 (0:30)开场视频风格 V1 (0:30)开场视频风格 V1 (0:36)预告片(0:30)宣传片 (1:10)动作电影宣传片 v1 (1:00)动作电影宣传片 v2 (1:00)动态幻灯片视频 v1 (2:13)动态幻灯片视频 v2 (1:40)3个Logo展示 (0:04) 版 本：AE CS5或者更高版本，必使用英文版AE分辨率：4K高清3840×2160插 件：不需要第三方插件大 小：1.82GB教 程：视频教程音 乐：不包含背景音乐注 意：模板修改需要有一定的AE基础，未入门的新手请谨慎购买，店主不负责帮忙修改使用者一定要对AE了解，我们只提供模板，不包使用不包括预览视频中图像（就是人物照片与实拍影片）与音乐素材视频预览：您的浏览器不支持HTML5的 video 标签，无法为您播放！视频截图：下载地址:https://pan.baidu.com/s/1Eefu1hnL336pMTdPrWd1sg 密码：omy0","text":"包含信号损坏，亮度置换，多摄像机分屏，摄像机推拉等多种动画场景视频图片文字效果，所有的镜头都是单独模块化的，可以自己随意拖拽组合成自己的开场宣传视频，默认包含以下已经做好的视频片头，可以直接使用： 开场视频风格 V1 (0:30)开场视频风格 V1 (0:30)开场视频风格 V1 (0:36)预告片(0:30)宣传片 (1:10)动作电影宣传片 v1 (1:00)动作电影宣传片 v2 (1:00)动态幻灯片视频 v1 (2:13)动态幻灯片视频 v2 (1:40)3个Logo展示 (0:04) 版 本：AE CS5或者更高版本，必使用英文版AE分辨率：4K高清3840×2160插 件：不需要第三方插件大 小：1.82GB教 程：视频教程音 乐：不包含背景音乐注 意：模板修改需要有一定的AE基础，未入门的新手请谨慎购买，店主不负责帮忙修改使用者一定要对AE了解，我们只提供模板，不包使用不包括预览视频中图像（就是人物照片与实拍影片）与音乐素材视频预览：您的浏览器不支持HTML5的 video 标签，无法为您播放！视频截图：下载地址:https://pan.baidu.com/s/1Eefu1hnL336pMTdPrWd1sg 密码：omy0","categories":[{"name":"素材","slug":"material","permalink":"https://goodhelp.gitee.io/categories/material/"}],"tags":[{"name":"ae模板","slug":"ae模板","permalink":"https://goodhelp.gitee.io/tags/ae%E6%A8%A1%E6%9D%BF/"}]},{"title":"恢宏大气金色文字","slug":"material/恢宏大气金色文字","date":"2018-03-25T03:40:14.000Z","updated":"2021-09-11T16:42:47.015Z","comments":true,"path":"page/1476230064/","link":"","permalink":"https://goodhelp.gitee.io/page/1476230064/","excerpt":"【版本要求】:建议使用 AE CS6或更高的AE英文版打开【插件要求】:Element V2;Particular【模板尺寸】:1920X1080【时间长度】:14秒【音频】:有【文件大小】:389M【视频截图】:【视频预览】:您的浏览器不支持HTML5的 video 标签，无法为您播放！ 下载地址https://pan.baidu.com/s/1gqNWtWYCc1mFpcBR22Lkgg 密码：5pxn","text":"【版本要求】:建议使用 AE CS6或更高的AE英文版打开【插件要求】:Element V2;Particular【模板尺寸】:1920X1080【时间长度】:14秒【音频】:有【文件大小】:389M【视频截图】:【视频预览】:您的浏览器不支持HTML5的 video 标签，无法为您播放！ 下载地址https://pan.baidu.com/s/1gqNWtWYCc1mFpcBR22Lkgg 密码：5pxn","categories":[{"name":"素材","slug":"material","permalink":"https://goodhelp.gitee.io/categories/material/"}],"tags":[{"name":"ae模板","slug":"ae模板","permalink":"https://goodhelp.gitee.io/tags/ae%E6%A8%A1%E6%9D%BF/"}]},{"title":"迅雷地址、快车地址和QQ旋风地址加解密原理","slug":"article/迅雷地址、快车地址和QQ旋风地址加解密原理","date":"2018-03-12T03:01:49.000Z","updated":"2021-09-16T23:42:54.567Z","comments":true,"path":"page/708277890/","link":"","permalink":"https://goodhelp.gitee.io/page/708277890/","excerpt":"迅雷地址和快车地址的加密方式很简单，其实都是用的Base64加密方式，只不过有一点点的小改动而已。 1. 迅雷链接地址加密方式迅雷链接地址转换原理是在地址的前方和后方加入两个字母AA、ZZ，然后再进行Base64加密，再加上Thunder://这个专用链接标识，从而转换成迅雷的专用地址。例如：原链接为：http://www.forece.net/win7.rar在原地址前面加”AA”，后面加”ZZ”(注：不包括引号)，地址变为AAhttp://www.forece.net/win7.rarZZ此地址base64编码为QUFodHRwOi8vd3d3LmZvcmVjZS5uZXQvd2luNy5yYXJaWg==加入迅雷专链标识，即在上地址前加thunder://，即thunder://QUFodHRwOi8vd3d3LmZvcmVjZS5uZXQvd2luNy5yYXJaWg== 2. 网际快车链接地址加密方式网际快车的链接地址转换原理和迅雷的类似，只不过是在地址前后加上[FLASHGET]，经过Base64加密，然后在地址前加flashget://这个快车专用链接标识，最后还需要加一个标识符（&amp;符号），符号任意，我一般就加我的名字（&amp;forece），这样就可以将普通http地址转换成快车的地址了。例如：原链接为：http://www.forece.net/win7.rar在原地址前后都加上”[FLASHGET]“(注：不包括引号)，地址变为[FLASHGET]http://www.forece.net/win7.rar[FLASHGET]此地址base64编码为 W0ZMQVNIR0VUXWh0dHA6Ly93d3cuZm9yZWNlLm5ldC93aW43LnJhcltGTEFTSEdFVF0= 加上快车专链标识和结尾符号，即在上地址前加flashget://，结尾加&amp;forece，即 flashget://W0ZMQVNIR0VUXWh0dHA6Ly93d3cuZm9yZWNlLm5ldC93aW43LnJhcltGTEFTSEdFVF0=&amp;forece “&amp;符号”，符号怎么得出我也不清楚，只是看网上别人这么写的，至今无人报错。 3. QQ旋风链接地址加密方式","text":"迅雷地址和快车地址的加密方式很简单，其实都是用的Base64加密方式，只不过有一点点的小改动而已。 1. 迅雷链接地址加密方式迅雷链接地址转换原理是在地址的前方和后方加入两个字母AA、ZZ，然后再进行Base64加密，再加上Thunder://这个专用链接标识，从而转换成迅雷的专用地址。例如：原链接为：http://www.forece.net/win7.rar在原地址前面加”AA”，后面加”ZZ”(注：不包括引号)，地址变为AAhttp://www.forece.net/win7.rarZZ此地址base64编码为QUFodHRwOi8vd3d3LmZvcmVjZS5uZXQvd2luNy5yYXJaWg==加入迅雷专链标识，即在上地址前加thunder://，即thunder://QUFodHRwOi8vd3d3LmZvcmVjZS5uZXQvd2luNy5yYXJaWg== 2. 网际快车链接地址加密方式网际快车的链接地址转换原理和迅雷的类似，只不过是在地址前后加上[FLASHGET]，经过Base64加密，然后在地址前加flashget://这个快车专用链接标识，最后还需要加一个标识符（&amp;符号），符号任意，我一般就加我的名字（&amp;forece），这样就可以将普通http地址转换成快车的地址了。例如：原链接为：http://www.forece.net/win7.rar在原地址前后都加上”[FLASHGET]“(注：不包括引号)，地址变为[FLASHGET]http://www.forece.net/win7.rar[FLASHGET]此地址base64编码为 W0ZMQVNIR0VUXWh0dHA6Ly93d3cuZm9yZWNlLm5ldC93aW43LnJhcltGTEFTSEdFVF0= 加上快车专链标识和结尾符号，即在上地址前加flashget://，结尾加&amp;forece，即 flashget://W0ZMQVNIR0VUXWh0dHA6Ly93d3cuZm9yZWNlLm5ldC93aW43LnJhcltGTEFTSEdFVF0=&amp;forece “&amp;符号”，符号怎么得出我也不清楚，只是看网上别人这么写的，至今无人报错。 3. QQ旋风链接地址加密方式QQ旋风的地址转换相对就简单多了，将原地址直接base64编码加密就可以了，然后加上标识符qqdl://即可。例如：原链接为：http://www.forece.net/win7.rar此地址base64编码为aHR0cDovL3d3dy5mb3JlY2UubmV0L3dpbjcucmFy 再加上旋风专链标识，在上地址前加qqdl://，即 qqdl://aHR0cDovL3d3dy5mb3JlY2UubmV0L3dpbjcucmFy 这样，普通的http地址就可以轻松的转换成快车，迅雷，旋风的地址了。相反，解密只要将过程反推即可。同样还是利用Base64加密，解密工具。迅雷地址和快车地址的加密方式很简单，其实都是用的Base64加密方式，只不过有一点点的小改动而已。","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"破解方法","slug":"破解方法","permalink":"https://goodhelp.gitee.io/tags/%E7%A0%B4%E8%A7%A3%E6%96%B9%E6%B3%95/"}]},{"title":"云更新无盘各版本官方下载地址","slug":"other/云更新无盘各版本官方下载地址","date":"2018-03-06T02:58:58.000Z","updated":"2021-09-16T23:48:50.573Z","comments":true,"path":"page/1778183789/","link":"","permalink":"https://goodhelp.gitee.io/page/1778183789/","excerpt":"云更新是专业高效的网吧数字内容管理软件,用户可以通过云更新搭建的三层更新平台实现海量娱乐内容的自动更新和下载，轻松完成娱乐内容的添加、管理和更新等一系列复杂的工作。云更新官方网站上只提供最新的云更新版本下载，以前的版本不提供下载，如果你需要下载以前的版本怎么办呢？ 云更新5498版的官方下载地址：(此版会被强制更新)云更新5498版服务端安装包下载：http://file.yungengxin.com/Soft/download/Server_x64_2017.1.15.5498_Setup.zip云更新5498版客户端安装包下载：http://file.yungengxin.com/Soft/download/Client2017.1.15.5498_Setup.zip 云更新6596版的官方下载地址：云更新6596服务端安装包下载：http://file.yungengxin.com/Soft/download/Server_x64_2017.6.15.6596_Setup.zip云更新6596客户端安装包下载：http://file.yungengxin.com/Soft/download/Client2017.6.15.6596_Setup.zip云更新6596开包升级工具下载：http://file.yungengxin.com/Soft/download/ClientUpdate2017.6.15.6596.zip 云更新7625版的官方下载地址：云更新7625服务端和客户端安装包下载：http://file.yungengxin.com/Soft/download/Standard_2017.10.15.7625.zip 看出什么端倪了吗？云更新官网虽然不提供旧版本的下载链接，实际上旧版本文件是存在云更新服务器上的，所有旧版本均存放在http://file.yungengxin.com/Soft/download/中的，如果此地址允许目录列表，那么就可以把云更新版本全部下载了，但此地址不支持目录列表，所以需要你知道你需要下载的文件的文件名！但我们可以看出，以前的版本服务端都这样按日期和版本号命名的，比如Server_x64_2017.1.15.5498_Setup.zip，指的是64位服务端(Server_x64)，发期日期是2017.1.15，版本号是5498，只要你知道这些就可以试着下载了。下面是我们从云更新服务器下载后保存到百度云上的!百度云下载 链接: https://pan.baidu.com/s/1529CfcnaEmoqP1gI01ELBw 密码: 3kht","text":"云更新是专业高效的网吧数字内容管理软件,用户可以通过云更新搭建的三层更新平台实现海量娱乐内容的自动更新和下载，轻松完成娱乐内容的添加、管理和更新等一系列复杂的工作。云更新官方网站上只提供最新的云更新版本下载，以前的版本不提供下载，如果你需要下载以前的版本怎么办呢？ 云更新5498版的官方下载地址：(此版会被强制更新)云更新5498版服务端安装包下载：http://file.yungengxin.com/Soft/download/Server_x64_2017.1.15.5498_Setup.zip云更新5498版客户端安装包下载：http://file.yungengxin.com/Soft/download/Client2017.1.15.5498_Setup.zip 云更新6596版的官方下载地址：云更新6596服务端安装包下载：http://file.yungengxin.com/Soft/download/Server_x64_2017.6.15.6596_Setup.zip云更新6596客户端安装包下载：http://file.yungengxin.com/Soft/download/Client2017.6.15.6596_Setup.zip云更新6596开包升级工具下载：http://file.yungengxin.com/Soft/download/ClientUpdate2017.6.15.6596.zip 云更新7625版的官方下载地址：云更新7625服务端和客户端安装包下载：http://file.yungengxin.com/Soft/download/Standard_2017.10.15.7625.zip 看出什么端倪了吗？云更新官网虽然不提供旧版本的下载链接，实际上旧版本文件是存在云更新服务器上的，所有旧版本均存放在http://file.yungengxin.com/Soft/download/中的，如果此地址允许目录列表，那么就可以把云更新版本全部下载了，但此地址不支持目录列表，所以需要你知道你需要下载的文件的文件名！但我们可以看出，以前的版本服务端都这样按日期和版本号命名的，比如Server_x64_2017.1.15.5498_Setup.zip，指的是64位服务端(Server_x64)，发期日期是2017.1.15，版本号是5498，只要你知道这些就可以试着下载了。下面是我们从云更新服务器下载后保存到百度云上的!百度云下载 链接: https://pan.baidu.com/s/1529CfcnaEmoqP1gI01ELBw 密码: 3kht","categories":[{"name":"其他","slug":"其他","permalink":"https://goodhelp.gitee.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"文章","slug":"文章","permalink":"https://goodhelp.gitee.io/tags/%E6%96%87%E7%AB%A0/"},{"name":"云更新","slug":"云更新","permalink":"https://goodhelp.gitee.io/tags/%E4%BA%91%E6%9B%B4%E6%96%B0/"}]},{"title":"学习外挂的外挂源代码","slug":"code/学习外挂的外挂源代码","date":"2018-03-01T05:03:05.000Z","updated":"2021-09-17T00:25:45.606Z","comments":true,"path":"page/4071443873/","link":"","permalink":"https://goodhelp.gitee.io/page/4071443873/","excerpt":"01:可得到在网页中输入的用户名和密码的源代码 VC源代码02:传2脱机源代码 VC源代码03:传2机器人源代码 VC源代码04:封包截取的源码,值得学习 VC源代码05:神迹外挂挂源码 VC源代码06:系统加速源代码 DELPHI源代码07:传2外挂源码 ,功能丰富,是不可多得的源码 DELPHI源代码08:神迹脱机外挂源码 DELPHI源代码09:内存修改器源代码 VB源代码10:Winsock 详细使用例程 VB源代码11:内存搜索及修改源代码 VB源代码12:QQ消息自动发送器,有许多API操作值得学习 VB源代码13:读写INI文件的操作,值得学习 VB源代码14:截取封包的操作 VB源代码15:又一个内存修改器的源代码 VB源代码16:剑侠补血源码 VB源代码17:绿光抓包器，很好用 BC源代码18:封包截取源代码 VC源代码19:CS最有名的作敝器ORC9源码 VC源代码20:mu窗口化源码 VC源代码21:系统加速源码 VB源代码22:魔力宝贝和石器时代解图工具源码 VC源代码23:刀剑online 内存查看（HP，MP等） VB源代码24 :巨好的传奇2外挂 VC源代码25：巨好的龙族外挂源码 VB源代码26：传奇封包分析器 VB源代码27：DiabloII的外挂源代码 VC源代码28：JoolzCheat源码（著名游戏CS1.5版作弊器ogc-para源码） VC源代码29：传奇自动发言外挂 VC源代码30：盛大传奇外挂源码 VC源代码31：新大话西游经典系列源代码 VC源代码32：自动释放ASN聚气外挂源代码 VC源代码33:天翼脱机外挂源码（强力推荐） DELPHI源代码34：内存查找修改器 （和FPE GE一样，查找速度极快） DELPHI源代码35：又一个内存查找修改器 DELPHI源代码36：内存查找修改 DELPHI源代码37：BlowFish解密函数 DELPHI源代码38:lose-v0.41beta-win32-src DELPHI源代码39：传奇VB代码-Group.dat文件解密代码 VB源代码40：刀剑自动补血 VB源代码41：金庸小外挂 VB源代码42：腾讯QQ游戏–对对碰外挂制作教程详解 VB源代码43：APIhook DELPHI源代码44：APIHOOK VC源代码45：一个呼出热键的示例 DELPHI源代码46：mir外挂 易语言47：奇迹登陆器 VB源代码48：QQ对对碰小外挂 DELPHI源代码49：好像是封神ONLINE的东西 VC源代码50：一个极好的钩子教材 易语言51：传世地图 BC源代码52：奇迹登录器的E源码 易语言53：对对碰挂机 VC源代码54：库库神仙的防大补贴 DELPHI源代码55：扫雷外挂 DELPHI源代码56：毁灭天使2源代码 易语言 全部源代码下载地址：链接: https://pan.baidu.com/s/1Nr_ujf-OWGVZh1DrYdd6SA 提取码: amnp 复制这段内容后打开百度网盘手机App，操作更方便哦","text":"01:可得到在网页中输入的用户名和密码的源代码 VC源代码02:传2脱机源代码 VC源代码03:传2机器人源代码 VC源代码04:封包截取的源码,值得学习 VC源代码05:神迹外挂挂源码 VC源代码06:系统加速源代码 DELPHI源代码07:传2外挂源码 ,功能丰富,是不可多得的源码 DELPHI源代码08:神迹脱机外挂源码 DELPHI源代码09:内存修改器源代码 VB源代码10:Winsock 详细使用例程 VB源代码11:内存搜索及修改源代码 VB源代码12:QQ消息自动发送器,有许多API操作值得学习 VB源代码13:读写INI文件的操作,值得学习 VB源代码14:截取封包的操作 VB源代码15:又一个内存修改器的源代码 VB源代码16:剑侠补血源码 VB源代码17:绿光抓包器，很好用 BC源代码18:封包截取源代码 VC源代码19:CS最有名的作敝器ORC9源码 VC源代码20:mu窗口化源码 VC源代码21:系统加速源码 VB源代码22:魔力宝贝和石器时代解图工具源码 VC源代码23:刀剑online 内存查看（HP，MP等） VB源代码24 :巨好的传奇2外挂 VC源代码25：巨好的龙族外挂源码 VB源代码26：传奇封包分析器 VB源代码27：DiabloII的外挂源代码 VC源代码28：JoolzCheat源码（著名游戏CS1.5版作弊器ogc-para源码） VC源代码29：传奇自动发言外挂 VC源代码30：盛大传奇外挂源码 VC源代码31：新大话西游经典系列源代码 VC源代码32：自动释放ASN聚气外挂源代码 VC源代码33:天翼脱机外挂源码（强力推荐） DELPHI源代码34：内存查找修改器 （和FPE GE一样，查找速度极快） DELPHI源代码35：又一个内存查找修改器 DELPHI源代码36：内存查找修改 DELPHI源代码37：BlowFish解密函数 DELPHI源代码38:lose-v0.41beta-win32-src DELPHI源代码39：传奇VB代码-Group.dat文件解密代码 VB源代码40：刀剑自动补血 VB源代码41：金庸小外挂 VB源代码42：腾讯QQ游戏–对对碰外挂制作教程详解 VB源代码43：APIhook DELPHI源代码44：APIHOOK VC源代码45：一个呼出热键的示例 DELPHI源代码46：mir外挂 易语言47：奇迹登陆器 VB源代码48：QQ对对碰小外挂 DELPHI源代码49：好像是封神ONLINE的东西 VC源代码50：一个极好的钩子教材 易语言51：传世地图 BC源代码52：奇迹登录器的E源码 易语言53：对对碰挂机 VC源代码54：库库神仙的防大补贴 DELPHI源代码55：扫雷外挂 DELPHI源代码56：毁灭天使2源代码 易语言 全部源代码下载地址：链接: https://pan.baidu.com/s/1Nr_ujf-OWGVZh1DrYdd6SA 提取码: amnp 复制这段内容后打开百度网盘手机App，操作更方便哦","categories":[{"name":"源码","slug":"code","permalink":"https://goodhelp.gitee.io/categories/code/"}],"tags":[{"name":"基址查找方法","slug":"基址查找方法","permalink":"https://goodhelp.gitee.io/tags/%E5%9F%BA%E5%9D%80%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95/"},{"name":"delphi源码","slug":"delphi源码","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%BA%90%E7%A0%81/"},{"name":"游戏外挂方法","slug":"游戏外挂方法","permalink":"https://goodhelp.gitee.io/tags/%E6%B8%B8%E6%88%8F%E5%A4%96%E6%8C%82%E6%96%B9%E6%B3%95/"}]},{"title":"在游戏中切出外挂delphi代码","slug":"code/在游戏中切出外挂delphi代码","date":"2018-03-01T05:01:16.000Z","updated":"2021-09-17T00:25:32.144Z","comments":true,"path":"page/1318062081/","link":"","permalink":"https://goodhelp.gitee.io/page/1318062081/","excerpt":"需要用DLL方式调用:这是DLL的DPR文件: 1234567891011121314151617181920212223242526library Hook32; &#123; Important note about DLL memory management: ShareMem must be thefirst unit in your library&#x27;s USES clause AND your project&#x27;s (selectProject-View Source) USES clause if your DLL exports any procedures orfunctions that pass strings as parameters or function results. Thisapplies to all strings passed to and from your DLL--even those thatare nested in records and classes. ShareMem is the interface unit tothe BORLNDMM.DLL shared memory manager, which must be deployed alongwith your DLL. To avoid using BORLNDMM.DLL, pass string informationusing PChar or ShortString parameters. &#125; usesSysUtils,Forms,Classes,myDLl in &#x27;myDLl.pas&#x27; &#123;Form1&#125;; &#123;$R *.res&#125; exportsHookOn,HookOff; begin&#123;Application.Initialize;Application.Run; &#125;end. 这是DLL的PAS文件: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142unit myDLl; interface usesWindows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,Dialogs, StdCtrls; typeTForm1 = class(TForm)Button1: TButton;Edit1: TEdit;Memo1: TMemo;procedure Button1Click(Sender: TObject);procedure FormClose(Sender: TObject; var Action: TCloseAction);procedure FormDestroy(Sender: TObject);procedure FormActivate(Sender: TObject);private&#123; Private declarations &#125;public&#123; Public declarations &#125;end; varForm1: TForm1;function HookProc(nCode:Integer;WParam: WPARAM;LParam:LPARAM):LRESULT;stdcall;function HookOn(lpHwnd:HWND;lpType:Longint):Longint;stdcall;export;function HookOff:Boolean;stdcall;export; implementation&#123;type KeyboardBytes=recordkbArray:array[0..255] of byte;end;&#125; varhHk: HHOOK=0;hMOUSEHk: HHOOK=0;mhwnd:HWND=0;bShow:Boolean=False;myKey:Byte=VK_F7;kbArray:TKeyboardState;hThread: Cardinal;hmod: Pointer; //HinstancehProcessId: Cardinal; // KeyHookStruct:^THardwareHookStruct;mMode:Integer; &#123;$R *.dfm&#125; function HookProc(nCode:Integer;WParam: WPARAM;LParam:LPARAM):LRESULT;stdcall;beginResult :=0; if nCode&lt;0 thenResult := CallNextHookEx(hHk,nCode,WParam,LParam)elsebeginGetKeyboardState(kbArray); if (bShow=False) And (kbArray[myKey]=1) thenbeginbShow:=True;Form1:=TForm1.Create(Application);ShowCursor(true);try// Form1.Caption :=&#x27;我的DLL中的窗体！&#x27;;// LockWindowUpdate(mhwnd);/// SetParent(Form1.Handle,mhwnd);// MoveWindow(Form1.Handle,1,1,2,2,True);// UpdateWindow(Form1.Handle);// UpdateWindow(mhwnd);SetWindowPos(Form1.Handle, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE Or SWP_NOSIZE);// UpdateWindow(mhwnd);// mMode:=GetMapMode(GetDC(mhwnd));// SetMapMode(GetDC(Form1.Handle),mMode);// UpdateWindow(Form1.Handle);// SetWindowLong(Form1.Handle,GWL_STYLE,GetWindowLong(mhwnd, GWL_STYLE)); Result :=1;SuspendThread(hThread);Form1.ShowModal;ShowCursor(true);ResumeThread(hThread);kbArray[myKey] := 0;SetKeyboardState(kbArray); finallyForm1.Free;end;endelsebeginResult := CallNextHookEx(hHk,nCode,WParam,LParam);end;end;end; function HookOn(lpHwnd:HWND;lpType:Longint): Longint;stdcall; export;beginmhwnd:=lpHwnd;if hHk&lt;&gt;0 then UnHookWindowsHookEx(hHk);hThread :=GetWindowThreadProcessId(mhwnd,hmod);// hProcessId:=cardinal(hmod);// Sleep(200);hHk :=SetWindowsHookEx(lpType,@HookProc,hInstance,hThread); // WH_KEYBOARDResult :=hHkend; function HookOff:Boolean;stdcall; export;beginif hHk&lt;&gt;0 thenbeginUnHookWindowsHookEx(hHk);hHk :=0;Result :=true;endelseResult :=false;end; procedure TForm1.FormClose(Sender: TObject; var Action: TCloseAction);beginbShow:=False;end; procedure TForm1.FormDestroy(Sender: TObject);beginbShow:=False;end; procedure TForm1.Button1Click(Sender: TObject);beginForm1.close;end; procedure TForm1.FormActivate(Sender: TObject);beginShowCursor(true);end; end. 这是调用的程序PAS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748unit Unit1; interface usesWindows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,Dialogs, StdCtrls, ExtCtrls; typeTForm1 = class(TForm)procedure FormCreate(Sender: TObject);procedure FormClose(Sender: TObject; var Action: TCloseAction); private&#123; Private declarations &#125;public&#123; Public declarations &#125;end; varForm1: TForm1;function HookOn(lpHwnd:HWND;lpType:Longint):Longint;stdcall;external &#x27;HOOK32.DLL&#x27; name &#x27;HookOn&#x27;;function HookOff:Boolean;stdcall;external &#x27;HOOK32.DLL&#x27; name &#x27;HookOff&#x27;;implementation &#123;$R *.dfm&#125; procedure TForm1.FormCreate(Sender: TObject);varhHandle:HWND;hProID:HWND;hThrID:HWND;h1:HWND;begin//这些只是自身程序的，没什么用。hHandle:=Application.Handle;hProID:=GetCurrentProcessId();hThrID:=GetCurrentThreadId();h1:=FindWindow(NIL,&#x27;你的程序&#x27;);//这是窗口的句柄，要自己找到后，填写入。HookOn(h1,WH_KEYBOARD);end; procedure TForm1.FormClose(Sender: TObject; var Action: TCloseAction);beginhookoff;end; end.","text":"需要用DLL方式调用:这是DLL的DPR文件: 1234567891011121314151617181920212223242526library Hook32; &#123; Important note about DLL memory management: ShareMem must be thefirst unit in your library&#x27;s USES clause AND your project&#x27;s (selectProject-View Source) USES clause if your DLL exports any procedures orfunctions that pass strings as parameters or function results. Thisapplies to all strings passed to and from your DLL--even those thatare nested in records and classes. ShareMem is the interface unit tothe BORLNDMM.DLL shared memory manager, which must be deployed alongwith your DLL. To avoid using BORLNDMM.DLL, pass string informationusing PChar or ShortString parameters. &#125; usesSysUtils,Forms,Classes,myDLl in &#x27;myDLl.pas&#x27; &#123;Form1&#125;; &#123;$R *.res&#125; exportsHookOn,HookOff; begin&#123;Application.Initialize;Application.Run; &#125;end. 这是DLL的PAS文件: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142unit myDLl; interface usesWindows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,Dialogs, StdCtrls; typeTForm1 = class(TForm)Button1: TButton;Edit1: TEdit;Memo1: TMemo;procedure Button1Click(Sender: TObject);procedure FormClose(Sender: TObject; var Action: TCloseAction);procedure FormDestroy(Sender: TObject);procedure FormActivate(Sender: TObject);private&#123; Private declarations &#125;public&#123; Public declarations &#125;end; varForm1: TForm1;function HookProc(nCode:Integer;WParam: WPARAM;LParam:LPARAM):LRESULT;stdcall;function HookOn(lpHwnd:HWND;lpType:Longint):Longint;stdcall;export;function HookOff:Boolean;stdcall;export; implementation&#123;type KeyboardBytes=recordkbArray:array[0..255] of byte;end;&#125; varhHk: HHOOK=0;hMOUSEHk: HHOOK=0;mhwnd:HWND=0;bShow:Boolean=False;myKey:Byte=VK_F7;kbArray:TKeyboardState;hThread: Cardinal;hmod: Pointer; //HinstancehProcessId: Cardinal; // KeyHookStruct:^THardwareHookStruct;mMode:Integer; &#123;$R *.dfm&#125; function HookProc(nCode:Integer;WParam: WPARAM;LParam:LPARAM):LRESULT;stdcall;beginResult :=0; if nCode&lt;0 thenResult := CallNextHookEx(hHk,nCode,WParam,LParam)elsebeginGetKeyboardState(kbArray); if (bShow=False) And (kbArray[myKey]=1) thenbeginbShow:=True;Form1:=TForm1.Create(Application);ShowCursor(true);try// Form1.Caption :=&#x27;我的DLL中的窗体！&#x27;;// LockWindowUpdate(mhwnd);/// SetParent(Form1.Handle,mhwnd);// MoveWindow(Form1.Handle,1,1,2,2,True);// UpdateWindow(Form1.Handle);// UpdateWindow(mhwnd);SetWindowPos(Form1.Handle, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE Or SWP_NOSIZE);// UpdateWindow(mhwnd);// mMode:=GetMapMode(GetDC(mhwnd));// SetMapMode(GetDC(Form1.Handle),mMode);// UpdateWindow(Form1.Handle);// SetWindowLong(Form1.Handle,GWL_STYLE,GetWindowLong(mhwnd, GWL_STYLE)); Result :=1;SuspendThread(hThread);Form1.ShowModal;ShowCursor(true);ResumeThread(hThread);kbArray[myKey] := 0;SetKeyboardState(kbArray); finallyForm1.Free;end;endelsebeginResult := CallNextHookEx(hHk,nCode,WParam,LParam);end;end;end; function HookOn(lpHwnd:HWND;lpType:Longint): Longint;stdcall; export;beginmhwnd:=lpHwnd;if hHk&lt;&gt;0 then UnHookWindowsHookEx(hHk);hThread :=GetWindowThreadProcessId(mhwnd,hmod);// hProcessId:=cardinal(hmod);// Sleep(200);hHk :=SetWindowsHookEx(lpType,@HookProc,hInstance,hThread); // WH_KEYBOARDResult :=hHkend; function HookOff:Boolean;stdcall; export;beginif hHk&lt;&gt;0 thenbeginUnHookWindowsHookEx(hHk);hHk :=0;Result :=true;endelseResult :=false;end; procedure TForm1.FormClose(Sender: TObject; var Action: TCloseAction);beginbShow:=False;end; procedure TForm1.FormDestroy(Sender: TObject);beginbShow:=False;end; procedure TForm1.Button1Click(Sender: TObject);beginForm1.close;end; procedure TForm1.FormActivate(Sender: TObject);beginShowCursor(true);end; end. 这是调用的程序PAS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748unit Unit1; interface usesWindows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,Dialogs, StdCtrls, ExtCtrls; typeTForm1 = class(TForm)procedure FormCreate(Sender: TObject);procedure FormClose(Sender: TObject; var Action: TCloseAction); private&#123; Private declarations &#125;public&#123; Public declarations &#125;end; varForm1: TForm1;function HookOn(lpHwnd:HWND;lpType:Longint):Longint;stdcall;external &#x27;HOOK32.DLL&#x27; name &#x27;HookOn&#x27;;function HookOff:Boolean;stdcall;external &#x27;HOOK32.DLL&#x27; name &#x27;HookOff&#x27;;implementation &#123;$R *.dfm&#125; procedure TForm1.FormCreate(Sender: TObject);varhHandle:HWND;hProID:HWND;hThrID:HWND;h1:HWND;begin//这些只是自身程序的，没什么用。hHandle:=Application.Handle;hProID:=GetCurrentProcessId();hThrID:=GetCurrentThreadId();h1:=FindWindow(NIL,&#x27;你的程序&#x27;);//这是窗口的句柄，要自己找到后，填写入。HookOn(h1,WH_KEYBOARD);end; procedure TForm1.FormClose(Sender: TObject; var Action: TCloseAction);beginhookoff;end; end.","categories":[{"name":"源码","slug":"code","permalink":"https://goodhelp.gitee.io/categories/code/"}],"tags":[{"name":"基址查找方法","slug":"基址查找方法","permalink":"https://goodhelp.gitee.io/tags/%E5%9F%BA%E5%9D%80%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95/"},{"name":"delphi源码","slug":"delphi源码","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%BA%90%E7%A0%81/"},{"name":"游戏外挂方法","slug":"游戏外挂方法","permalink":"https://goodhelp.gitee.io/tags/%E6%B8%B8%E6%88%8F%E5%A4%96%E6%8C%82%E6%96%B9%E6%B3%95/"}]},{"title":"Delphi中那些容易混淆的基础知识","slug":"article/Delphi中那些容易混淆的基础知识","date":"2018-02-28T02:51:49.000Z","updated":"2021-09-16T23:40:44.444Z","comments":true,"path":"page/1150891238/","link":"","permalink":"https://goodhelp.gitee.io/page/1150891238/","excerpt":"1. @、^、Addr、PointerDelphi(Pascal)中有几个特殊的符号，如@、^等，弄清楚这些符号的运行，首先要明白Delphi指针的一些基础知识：指针，是一个无符号整数（unsigned int），它是一个以当前系统寻址范围为取值范围的整数。指针对应着一个数据在内存中的地址，得到了指针就可以自由地修改该数据。指针的指针就是用来存放指针所在的内存地址的。明白了指针的基本含义，就容易理解它们之间 的区别了： @XX：取变量、函数或过程XX的地址（获取指针）； Addr(XX)：和@的作用类似，唯一的不同在于如果编译选项{$T-}没有打开，@返回的是一个通用的指针，如果编译选项打开了，@返回的是XX对应的指针，但Addr却不受此编译选项的约束。 ^：当它出现在类型定义的前面时如 ^typename 表示指向这种类型的指针; 当它出现在指针变量后边时 如 point^ 返回指针指向的变量的值; Pointer：无类型指针（对应PChar、PInteger等则为“有类型指针”）。通过这段代码则更容易区分它们：12345678varX, Y: Integer; // X and Y 整数类型P: ^Integer; // P 指向整数类型的指针beginX := 11; // 给 X 赋值P := @X; // 把 x的地址赋给pY := P^; // 取出p所指向的数值赋给yend; 第二行定义了两个变量X，Y。 第三行声明了P是指向整数类型的指针；意味着P能够指向X或者Y的地址。第五行赋给X值，第六行把X的地址赋给P。最后通过P指向的变量赋值给Y。此时，X和Y有相同的值。2. Char、Byte Char是一个字符，必须赋以字符如‘A’等； Byte是无符号整数，数值范围0~255。虽然字符实质上也是整数，但与C不同，Delphi中将他们划为两种不同的类型，各自遵从不同的运算。比如运算符+对于Byte是整数加法，对于Char则是字符连接成串。他们可以相互转化：Ord(‘A’)得到字符对应的整数，Chr(65)得到整数对应的字符。同理，就很好区分array of Byte和array of Char了。3. Move、CopyMemoryMove字面意思上是“移动”的意思，其实不然，在Delphi中Move更像是Copy：它可以复制一段内存片段到另外一段内存空间中。如下代码：1234567891011121314151617var source, dest : string;begin // Set up our starting string source := &#x27;123456789&#x27;; dest := &#x27;---------&#x27;; // Copy a substring from source into the middle of dest Move(source[5], dest[3], 4); // Show the source and destination strings ShowMessage(&#x27;Source = &#x27;+source); ShowMessage(&#x27;Dest = &#x27;+dest);end;//结果------------------//Source = 123456789//Dest = --5678--- 而CopyMemory则可以在Delphi的源码中看出端倪：1234procedure CopyMemory(Destination: Pointer; Source: Pointer; Length: DWORD);begin Move(Source^, Destination^, Length);end; 可以看出，CopyMemory其实也是调用了Move方法，但参数变了，CopyMemory参数是指针。当然，从源码还可以发现MoveMemory和CopyMemory是一模一样的功能。CopyMemory一般的使用方法为：123456789var buf1,buf2: array[0..9] of AnsiChar;begin buf1 := &#x27;0123456789&#x27;; buf2 := &#x27;abcdefghij&#x27;; CopyMemory(@buf2[2], @buf1[4], 5); ShowMessage(buf1); &#123;0123456789&#125; ShowMessage(buf2); &#123;ab45678hij&#125;end; 4. GetMem和FreeMem、GetMemory和FreeMemory、New和Dispose、StrAlloc和StrDispose、AllocMemDelphi中的内存申请和释放方法比较多，但有一点儿需要牢记的是上述方法建议配对使用。GetMem和FreeMem与GetMemory和FreeMemory在Delphi的源码中可以看到是被调用和调用的关系，FreeMemory会判断指针是否为空：123456789101112function GetMemory(Size: Integer): Pointer; cdecl;begin Result := MemoryManager.GetMem(Size);end; function FreeMemory(P: Pointer): Integer; cdecl;begin if P = nil then Result := 0 else Result := MemoryManager.FreeMem(P);end; 因此，建议用GetMemory和FreeMemory代替GetMem和FreeMem。New和Dispose是用来管理变体类型内存分配，如变体结构体：12345TRecord = recordText: string;Value: Integer;end;PRecord = ^TRecord; 如果用GetMem和FreeMem、GetMemory和FreeMemory来释放，会造成Text的内存没有释放，造成内存泄漏。如果用Dispose来释放指针，要加上定义信息，否则造成内存泄漏，正确写法Dispose(PRecord(Point))。另外需要注意的一点是：Delphi设计的Dispose释放内存时，只是标记这部分内存可以再用来被New等函数分配，并不是把从系统申请到的内存归还给操作系统，只在程序结束时，才全部释放给操作系统，因此并不能在资源管理器中看到Dispose的“显著效果”。一般使用方法如下：12345678910111213141516Type PMyRec = ^TMyRec; TMyRec = record FName: string; LName: string; end;var MyRecPtr: PMyRec; TreeViewIndex: LongInt;begin New(MyRecPtr); MyRecPtr^.FName := Edit1.Text; MyRecPtr^.LName := Edit2.Text; &#123;其他处理&#125; Dispose(MyRecPtr);end; StrAlloc和StrDispose这个函数也是一对，他们分配PChar加一个Cardinal长度，因此一定要用StrDispose释放，否则容易造成4字节的内存泄漏。StrAlloc分配的指针可以使用StrBufSize来获得大小。AllocMem和GetMem的区别在于AllocMem在申请内存后会初始化这段内存（把内存全部初始化为#0），同样和FreeMem配对使用。","text":"1. @、^、Addr、PointerDelphi(Pascal)中有几个特殊的符号，如@、^等，弄清楚这些符号的运行，首先要明白Delphi指针的一些基础知识：指针，是一个无符号整数（unsigned int），它是一个以当前系统寻址范围为取值范围的整数。指针对应着一个数据在内存中的地址，得到了指针就可以自由地修改该数据。指针的指针就是用来存放指针所在的内存地址的。明白了指针的基本含义，就容易理解它们之间 的区别了： @XX：取变量、函数或过程XX的地址（获取指针）； Addr(XX)：和@的作用类似，唯一的不同在于如果编译选项{$T-}没有打开，@返回的是一个通用的指针，如果编译选项打开了，@返回的是XX对应的指针，但Addr却不受此编译选项的约束。 ^：当它出现在类型定义的前面时如 ^typename 表示指向这种类型的指针; 当它出现在指针变量后边时 如 point^ 返回指针指向的变量的值; Pointer：无类型指针（对应PChar、PInteger等则为“有类型指针”）。通过这段代码则更容易区分它们：12345678varX, Y: Integer; // X and Y 整数类型P: ^Integer; // P 指向整数类型的指针beginX := 11; // 给 X 赋值P := @X; // 把 x的地址赋给pY := P^; // 取出p所指向的数值赋给yend; 第二行定义了两个变量X，Y。 第三行声明了P是指向整数类型的指针；意味着P能够指向X或者Y的地址。第五行赋给X值，第六行把X的地址赋给P。最后通过P指向的变量赋值给Y。此时，X和Y有相同的值。2. Char、Byte Char是一个字符，必须赋以字符如‘A’等； Byte是无符号整数，数值范围0~255。虽然字符实质上也是整数，但与C不同，Delphi中将他们划为两种不同的类型，各自遵从不同的运算。比如运算符+对于Byte是整数加法，对于Char则是字符连接成串。他们可以相互转化：Ord(‘A’)得到字符对应的整数，Chr(65)得到整数对应的字符。同理，就很好区分array of Byte和array of Char了。3. Move、CopyMemoryMove字面意思上是“移动”的意思，其实不然，在Delphi中Move更像是Copy：它可以复制一段内存片段到另外一段内存空间中。如下代码：1234567891011121314151617var source, dest : string;begin // Set up our starting string source := &#x27;123456789&#x27;; dest := &#x27;---------&#x27;; // Copy a substring from source into the middle of dest Move(source[5], dest[3], 4); // Show the source and destination strings ShowMessage(&#x27;Source = &#x27;+source); ShowMessage(&#x27;Dest = &#x27;+dest);end;//结果------------------//Source = 123456789//Dest = --5678--- 而CopyMemory则可以在Delphi的源码中看出端倪：1234procedure CopyMemory(Destination: Pointer; Source: Pointer; Length: DWORD);begin Move(Source^, Destination^, Length);end; 可以看出，CopyMemory其实也是调用了Move方法，但参数变了，CopyMemory参数是指针。当然，从源码还可以发现MoveMemory和CopyMemory是一模一样的功能。CopyMemory一般的使用方法为：123456789var buf1,buf2: array[0..9] of AnsiChar;begin buf1 := &#x27;0123456789&#x27;; buf2 := &#x27;abcdefghij&#x27;; CopyMemory(@buf2[2], @buf1[4], 5); ShowMessage(buf1); &#123;0123456789&#125; ShowMessage(buf2); &#123;ab45678hij&#125;end; 4. GetMem和FreeMem、GetMemory和FreeMemory、New和Dispose、StrAlloc和StrDispose、AllocMemDelphi中的内存申请和释放方法比较多，但有一点儿需要牢记的是上述方法建议配对使用。GetMem和FreeMem与GetMemory和FreeMemory在Delphi的源码中可以看到是被调用和调用的关系，FreeMemory会判断指针是否为空：123456789101112function GetMemory(Size: Integer): Pointer; cdecl;begin Result := MemoryManager.GetMem(Size);end; function FreeMemory(P: Pointer): Integer; cdecl;begin if P = nil then Result := 0 else Result := MemoryManager.FreeMem(P);end; 因此，建议用GetMemory和FreeMemory代替GetMem和FreeMem。New和Dispose是用来管理变体类型内存分配，如变体结构体：12345TRecord = recordText: string;Value: Integer;end;PRecord = ^TRecord; 如果用GetMem和FreeMem、GetMemory和FreeMemory来释放，会造成Text的内存没有释放，造成内存泄漏。如果用Dispose来释放指针，要加上定义信息，否则造成内存泄漏，正确写法Dispose(PRecord(Point))。另外需要注意的一点是：Delphi设计的Dispose释放内存时，只是标记这部分内存可以再用来被New等函数分配，并不是把从系统申请到的内存归还给操作系统，只在程序结束时，才全部释放给操作系统，因此并不能在资源管理器中看到Dispose的“显著效果”。一般使用方法如下：12345678910111213141516Type PMyRec = ^TMyRec; TMyRec = record FName: string; LName: string; end;var MyRecPtr: PMyRec; TreeViewIndex: LongInt;begin New(MyRecPtr); MyRecPtr^.FName := Edit1.Text; MyRecPtr^.LName := Edit2.Text; &#123;其他处理&#125; Dispose(MyRecPtr);end; StrAlloc和StrDispose这个函数也是一对，他们分配PChar加一个Cardinal长度，因此一定要用StrDispose释放，否则容易造成4字节的内存泄漏。StrAlloc分配的指针可以使用StrBufSize来获得大小。AllocMem和GetMem的区别在于AllocMem在申请内存后会初始化这段内存（把内存全部初始化为#0），同样和FreeMem配对使用。","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"delphi技巧","slug":"delphi技巧","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%8A%80%E5%B7%A7/"}]},{"title":"ce6.7中文版及CE找基址教程","slug":"soft/ce6-7中文版及CE找基址教程","date":"2018-02-09T04:02:34.000Z","updated":"2021-09-17T00:26:36.454Z","comments":true,"path":"page/369867878/","link":"","permalink":"https://goodhelp.gitee.io/page/369867878/","excerpt":"Cheat Engine(作弊引擎ce) 是一款内存修改编辑工具 ，它允许你修改你的游戏或软件内存数据，以得到一些其他功能。它包括16进制编辑，反汇编程序，内存查找工具。与同类修改工具相比，它具有强大的反汇编功能，且自身附带了外挂制作工具，可以用它直接生成外挂。CE游戏修改器(cheat engine)的原理其实很简单，如果学过编程的人一定会知道debug这个工具，debug是可以反汇编的，只不过是手工的非常的麻烦，而CE游戏修改器(cheat engine)让反汇编变得更为简单，可以跟踪特定数字的内存地址，通过修改这些数字来达到修改游戏数据的目的，从而达到轻松过关或永远打不死等等。CE游戏修改器(cheat engine)是国外的一款非常优秀的内存修改软件，用这个软件的游戏爱好者不计其数，他不但可以修改Flash游戏，对其他单机游戏也同样所向披靡。 CE内存修改器(Cheat Engine)用法也不是很复杂，首先是要先打开游戏，然后打开Cheat Engine软件，点击左上角的那个电脑图标，在弹出来的框中选择游戏进程，然后选择扫描类型和数值类型，进行扫描并修改! CE 官方网站：http://cheatengine.org/CE 官方中文翻译包： http://cheatengine.org/download/ch_cn.zipGitHub 下载地址：https://github.com/cheat-engine/cheat-engine/releasesCE 官方教程：http://wiki.cheatengine.org/index.php?title=Tutorials吾爱站下载：https://down.52pojie.cn/Tools/Debuggers/Cheat%20Engine%20v6.7.exe 在官方下载ce安装包，安装完成后，下载中文翻译包，解开，把ch_cn放在ce安装目录的languages子目录中，启动ce会提示你使用english还是 ch_cn，选好ch_cn语言重启ce就是中文界面了!为了快速上手使用CE，CE自己提供了一个教学程序Tutorial.exe，这个教学程序有两个版本，一个是32位版Tutorial-i386.exe和64位版Tutorial-x86_64.exe 以下是CE6.7 Tutorial教学程序过步骤1到步骤9的教程，本教程每一步，都找出了基址，比其他的教程稍难，但在实践应用中，基本上都是需要找出修改内存地址的基址! CE找基址是外挂最为关键的步骤，把基址找出来了，就可以做成外挂了，所以基址会找了就会制作外挂!就可以使用CE修改其他程序或游戏的数据了! ce6.7 Tutorial3.3教学步骤1 (密码:090453)欢迎使用 Cheat Engine 训练教程。 (v3.3)本教程将尝试讲解在游戏中作弊的一些基本知识，并帮助你熟悉 Cheat Engine 的使用方法。首先要执行 Cheat Engine ，如果你还没有运行它的话。然后点击”选择进程”图标按钮（左上角那个带有电脑的图标）。当进程列表窗口打开后找到这个训练程序，如果你没有重新命名该程序的名称，那么进程名应该”tutorial.exe”，选择它，并点击”打开”。现在暂时不要理会其它的按钮，如果你有兴趣的话，以后再研究它们。没什么意外的话，进程列表窗口将会消失并且在 Cheat Engine 主界面的上方会显示选择的进程名称。好了，点击”下一步”按钮进入下一个步骤（或输入密码进入你要练习的步骤）。 ce6.7 Tutorial3.3教学步骤2步骤 2: 精确值扫描 (密码=090453)现在你已经在 Cheat Engine 中打开了训练程序，为我们下一步的练习做好了准备。本窗口的左下方显示的”健康:XXX”，在你每次点击”打我”按钮时，它的值便会减少。要进入下一关，你必须找到这个数值并把它改成 1000 。很多方法都可以找到这个数值的位置，但我将告诉你一个最简单的方法，”精确数值”扫描：首先确认数值类型设置为2字节或4字节，设置成1字节也可以的，不过最终修改数据的时候便会有点麻烦了（虽然说这是很容易解决的问题）。假如该地址后边的字节数值都为 0 ，那么你设置成 8 字节也未尝不可，在这我们就不必尝试了。单浮点数，双浮点数，以及其他的扫描方法在这里行不通的，因为它们储存数值的方式不同。当数值类型设置正确后，确认扫描类型设置了”精确数值”，把健康值填写在数值的输入框，并点击”首次扫描”，稍等一会儿（假设你的电脑非常的慢），扫描完毕，扫描的结果将会显示在主界面的左侧。如果检索结果多于一个，你无法确定哪一个是正确的地址，那么继续点击”打我”，并将变更后的”健康值”填写在数值输入框中，点击”再次扫描”，重复这些步骤，直到你能确认已经找到了地址（在地址列表中只有一个地址）。好，双击左侧列表中的地址，该地址便会移动到下方的地址列表中并显示它的当前数值。双击下方地址列表中的数值（或者选择它，按下回车），填写你要修改的数值：1000 。如果操作正确，”下一步”按钮将变成可点击状态，本关就完成了。提示：如果你在扫描过程中出现了错误，可以点击”新的扫描”重新再来。当然，你也可以点击”打我”去查找一些更有价值的线索。以下是CE找基址的步骤1到步骤9的视频教程 ce6.7 Tutorial3.3教学步骤3步骤 3: 未知的初始值 (密码=419482)OK, 看来你已经理解了如何利用”精确数值”扫描查找数值了，让我们进行下一步。在上一关中我们知道初始数值的大小，所以我们可以利用”精确数值”扫描，但本关中仅有一个状态栏，我们并不知道它的初始数值。我们只知道这个数值在0到500之间，并且每次点击”打我”之后便会减些健康值，每次减少的健康值会显示在进度条的上方。同样有好几种方法可以找这个数值，（例如使用”数值减少了…”扫描方式），但我只教你最简单的方法，”未知的初始值”和”减少的数值”。 由于不知道当前数值的大小，”精确数值”扫描便派不上了用场，所以选择扫描方式”未知初始数值”。数值类型仍然选择 4 字节（这是因为大多数WINDOWS应用程序都使用 4 字节存放数据）。点击”首次扫描”并等待扫描结束。扫描完成后，点击”打我”，你会减少一些健康值。（减少的健康值显示几秒便会消失，你并不需要刻意记下它）。回到 Cheat Engine，在扫描类型中选择”减少的数值”，然后点击”再次扫描”。扫描完毕后，再次点击”打我”，并重复上述步骤，直到检索出很少的几个地址。 我们已经知道这个数值在0到500之间，所以挑出那个最为相似的地址，并将它加到下方的地址列表。现在，更改健康值为 5000，以便我们进入到下一关。 ce6.7 Tutorial3.3教学步骤4步骤 4: 浮点数 (密码=890124)在前面的教程中我们使用字节的方式进行扫描，但有些游戏使用了”浮点数”来存储数值（这么做是为了给菜鸟制造一些麻烦，让他们没那么容易修改游戏）。浮点数是带有小数点的数值（如 5.12 或 11321.1）。正如本关中的健康和弹药，两者都以浮点方法储存数据，不同的是，健康值为单精度浮点数，而弹药值为双精度浮点数。点击”打我”将减少一些健康值，而点击”开火”则消耗掉 0.5 的弹药。你得把这两项都修改到 5000 或者更多才能过关。”精确数值”扫描的方式虽然也可以完成本关的工作，但你应该试试其它更简练的扫描方式。提示: 扫描双浮点数类型建议禁用 “快速扫描” ce6.7 Tutorial3.3教学步骤5步骤 5: 代码查找 (密码=888899)某些游戏重新开始时，数据会存储在与上次不同的地方, 甚至游戏的过程中数据的存储位置也会变动。在这种情况下，你还是可以简单几步搞定它。这次我将尽量阐述如何运用”代码查找”功能。下方的数值每次启动教程的时候都会存放在内存不同的位置，所以地址列表中的固定地址是不起作用的。我们要先找到这个数值当前的存储地址（要如何去做，相信不用我再啰嗦了）。当你找到了地址就添加在下方的地址列表中，然后右健单击该地址，在弹出的菜单中选择”找出是什么改写了这个地址”，将弹出一个空白的窗口。接着点击本教程窗体上的”改变数值”按钮，并返回 Cheat Engine 。如果操作没问题 在刚才弹出的空白窗口中会出现一些汇编代码。选中代码并点击”替换”按钮，将它替换成什么也不做的代码（空指令），同时，修改后的代码也将放置在”高级选项”的代码列表中去（保存地址列表时会同时保存）。点击”停止”，游戏会以正常的方式继续运行下去，点击”关闭”按钮，关掉窗口。现在，再次点击教程窗口上的”改变数值”，没问题的话，”下一步”将变为可点击的状态。提示：如果你以足够快的速度锁定住该地址，”下一步”按钮也会变为可点击的。 ce6.7 Tutorial3.3教学步骤6步骤 6: 指针: (密码=098712)上一步阐述了如何使用”代码查找”功能对付变化位置的数据地址，但这种方法往往不能达到预期的效果，所以我们需要学习如何利用指针。在本关的 Tutorial.exe 窗口下面有两个按钮，一个会改变数值，另一个不但能改变数值而且还会改变数值在内存中存储的位置。这一步，你不需要懂得汇编，但如果懂的话会很有帮助。首先找到数值的地址，然后再查找是什么改写了这个地址。再次改变数值，CE 便可以列出找到的汇编代码。 双击一行汇编代码（或选择它并点击”详细信息”）并打开”详细信息”窗口以显示详细的信息，用来告诉你当这个指令运行时发生了什么事情。如果在这条汇编指令中没看到方括号（[]）的存在，我们就应该查看下一条汇编代码的详细信息，如果看到了方括号，那很可能表示我们已经找到了需要的指针。返回到主 cheat engine 窗口 （只要你愿意，你可以保持这个额外的信息窗口为打开状态。如果你要关掉它，那么要记好方栝号中间的代码）并做一次 4 字节的扫描，扫描”详细信息”窗口中告诉你的一串十六进制数值。扫描完成时它可能返回一个或几百个地址。大多数时候你需要的地址将是最少的一个。现在点击”手工添加地址”按钮，并勾选”指针”选项。”添加地址”窗口将发生变化，多出了”Address of Pointer（指针地址）”和”Offset (Hex)（偏移量(16进制)）”的文本框，以便您键入一个指针的地址和偏移量。请尽量填入刚才扫描到的地址。如果汇编指令中的方栝号里存在计算（例如：[esi+12]）则把数值部分填在”Offset (Hex)”的文本框中，如果不存在，则让它保持为 0 。如果看上去是更复杂的计算指令的话（举例说明一下）：[EAX2+EDX+00000310] eax=4C 并且 edx=00801234.这种情况下 EDX 便是数值的指针，而 EAX2+00000310 则是它的偏移量, 所以你要填在”Offset (Hex)”的将是 2*4C+00000310=3A8。（这些都是在十六进制下计算的，你可以使用WINDOWS的计算器，在科学方式下用十六进制计算）。回到教程，点击”确定”这个地址便会加到 CE 主窗口下方的地址列表中，如果没做错，在地址栏将显示 P-&gt;xxxxxxxx，而 xxxxxxxx 和你扫描到的地址数值是一致的，如果不一致，那么可能是哪里出错了。现在, 改变那条指针地址的数值为 5000 并锁定它，然后点击 Tutorial.exe 窗口上的”改变指针”按钮，如果一切正确，”下一步”按钮将变为可点击状态。备注:你也可以使用”指针扫描”的方式来查找这个指针地址。 ce6.7 Tutorial3.3教学步骤7步骤 7: 代码注入: (密码=013370)代码注入是将一小段你写出的代码注入到目标进程中并执行它的技巧。在这一步教程中，你将有一个健康值和一个每按一次将减少 1 点健康值的按钮，你的任务是利用”代码注入”，使每按一次按钮增加2点的健康值。查找这个地址，然后看看是什么在改写它（”找出是什么改写了这个地址”）。当你看到那条减少数值的汇编代码后，选择”显示反汇编程序”，然后打开”自动汇编窗口”（菜单-工具-&gt;自动汇编 或 按下快捷键 Ctrl+a )，选择”模板”中的”代码注入”。CE 将自动生成一部分汇编代码并为你输入指令做好准备（如果 CE 没有给出正确的地址，你也可以手工输入它）。注意 alloc 这部分代码，它会为你的代码分配出一小块空白的内存，过去，在 Win2000 之前的系统，这种行为存在安全隐患，很可能导致系统崩溃，幸运的是，这种情况在 win2000 以后的操作系统得到改善。也要注意line newmem: 、originalcode: 以及用文本”此处放置你的代码”标示出的空白部分正如你猜测的， 在这儿可以写下每次增加2点健康值的代码。在这种情况下推荐你使用 “ADD” 汇编指令，下面是一些示例：”ADD [00901234],9″ 使 [00901234] 地址的值增加9 “ADD [ESP+4],9” 使地址指针 [ESP+4] 的值增加9 在本关的情况下，你可以使用相同的手法处理减少健康值的那条原代码方括号之间的部分。提示 1：推荐你从原代码中删除减少健康值的那行代码，否则你得加 3 点健康值（你增加了3点，原代码减去1点，最终结果才会增加2点），这样看上去很容易让人迷惑，但最终方案还是由你来决定好了。提示 2:某些游戏中，原代码可能在多条指令之外，有时候（并非一向如此），它可能由不同的地方跳转至你的指令中并结束运行，其结果可能引起未知的错误；如果出现了这种情况，通常应当查看附近的那些跳转指令，进行修改，或者尝试使用不同地址进行代码注入，确认无误后便可以将你修改的代码注入到原代码中了。 ce6.7 Tutorial3.3教学步骤8步骤 8: 多级指针: (密码=525927)在这一步将解释如何使用多级指针。在第 6 步，你已经清楚 1 级指针的概念和用途，并可以利用数值的首个地址找到存放数据真正的基址。在本关中，你将看到 4 级指针，它由第一个指针指向第二个指针，再由第二个指针指向第三个指针，由第三个指针指向第四个指针，最终指向健康值的真正地址。开始的几步与在第 6 步中的操作基本相同。找出是什么访问了这个地址，然后分析汇编指令，查找指针地址中的数值，以及它的偏移量，将它们记下来。但这次你按数值找出的仍然是一个指针，你得依据这些数值，使用同样的操作方法找出指向这个指针的指针。看看是什么访问了你发现的那个指针地址，分析汇编指令，留意可能的代码和偏移量，并加以利用。持续这种过程，直到不能更进一步查找为止（通常基址为静态时，地址将以绿色标示）。点击”改变数值”改变健康值，如果你发现列表中那些指针地址所指向的值发生同样的变化时，那表示你可以试着将基址中的值更改为 5000，并锁定它，以便完成本关的任务了。备注1: 本步骤也可以使用自动汇编程序脚本或者使用指针扫描器加以解决。备注2: 在某些情况下，可以改变 CE 软件”代码查找”的相关设置。当你遇到类似于 mov eax,[eax] 的指令时，调试程序将显示改变之后的寄存器中的值，也许利用它更容易找出指针的位置。备注3: 你还在读？！当你查看汇编指令时你可能已经注意到，这些指针是在相同的代码块（相同的程序，如果你懂汇编，可以查看程序的起始代码）位置被读写。这种情况并不总会发生，但是当你在查找某个指针遇到问题的时候，没准能起到很大的用处。 ce6.7 Tutorial3.3教学步骤9步骤 9: 注入++: (密码=31337157)这一步将会解释如何处理游戏中的共用代码, 这种代码是通用在除了自己以外的其他同类型对像上常常你在修改游戏的时候, 你找到了一个单位的健康, 或是你自己角色的健康, 你会发现一种情况: 如果你把健康相关代码移除的话，其结果是你的角色无敌, 但你的敌人也无敌了。在这种情况下, 你必须想办法区分自己与敌人。有时候很简单, 你只要检查最前面的4个字节(函数指针表), 它通常指向一个独一无二的地址, 代表着游戏玩家角色，而有的时候它是一个团体号码, 或者也可能是一个指针, 它指向另一个指针, 该址针又指向下一个指针,搞不好还指向下下一个指针, 最后指向一个玩家名字。总之完全取决于游戏的复杂度, 以及你的运气最简单的方法是以”找出是什么改写了这个地址”去找出游戏代码，然后使用”分析(新/旧)数据/结构”的功能去比较两种结构。(你的单位和敌人的单位)然后看看是不是可以找到一个区分两者的方法。当你找到如何区分你和电脑单位的方法后，你可以注入一段自动汇编脚本来检查状态，然后看是要运行游戏的代码还是要做其他的修改。(例如一击必杀)另外, 你还可以用这个方法去创建一般所说的”字节数组”的字串, 它可以用来搜寻并产生一份所有你的单位或是敌人单位的列表 在这个教程中, 我已经实现了你将会玩到的最惊人的游戏.这个游戏有4个玩家。2个属于你的阵容, 另外两个属于电脑方。你的任务是找到改写健康的代码, 并且修改以至于你可以获得胜利，但”绝不能”使用锁定HP的方法.完成修改以后, 请按 “重新启动游戏并自动执行” 来测试你的修改是否正确提示1: 健康是一个单浮点数提示2: 解法不只一种以下是ce6.7 Tutorial3.3教学各步骤基址CT文件(包括32位和64位两个文件) 下载链接：https://pan.baidu.com/s/1smdbIHZ 密码：3t8e","text":"Cheat Engine(作弊引擎ce) 是一款内存修改编辑工具 ，它允许你修改你的游戏或软件内存数据，以得到一些其他功能。它包括16进制编辑，反汇编程序，内存查找工具。与同类修改工具相比，它具有强大的反汇编功能，且自身附带了外挂制作工具，可以用它直接生成外挂。CE游戏修改器(cheat engine)的原理其实很简单，如果学过编程的人一定会知道debug这个工具，debug是可以反汇编的，只不过是手工的非常的麻烦，而CE游戏修改器(cheat engine)让反汇编变得更为简单，可以跟踪特定数字的内存地址，通过修改这些数字来达到修改游戏数据的目的，从而达到轻松过关或永远打不死等等。CE游戏修改器(cheat engine)是国外的一款非常优秀的内存修改软件，用这个软件的游戏爱好者不计其数，他不但可以修改Flash游戏，对其他单机游戏也同样所向披靡。 CE内存修改器(Cheat Engine)用法也不是很复杂，首先是要先打开游戏，然后打开Cheat Engine软件，点击左上角的那个电脑图标，在弹出来的框中选择游戏进程，然后选择扫描类型和数值类型，进行扫描并修改! CE 官方网站：http://cheatengine.org/CE 官方中文翻译包： http://cheatengine.org/download/ch_cn.zipGitHub 下载地址：https://github.com/cheat-engine/cheat-engine/releasesCE 官方教程：http://wiki.cheatengine.org/index.php?title=Tutorials吾爱站下载：https://down.52pojie.cn/Tools/Debuggers/Cheat%20Engine%20v6.7.exe 在官方下载ce安装包，安装完成后，下载中文翻译包，解开，把ch_cn放在ce安装目录的languages子目录中，启动ce会提示你使用english还是 ch_cn，选好ch_cn语言重启ce就是中文界面了!为了快速上手使用CE，CE自己提供了一个教学程序Tutorial.exe，这个教学程序有两个版本，一个是32位版Tutorial-i386.exe和64位版Tutorial-x86_64.exe 以下是CE6.7 Tutorial教学程序过步骤1到步骤9的教程，本教程每一步，都找出了基址，比其他的教程稍难，但在实践应用中，基本上都是需要找出修改内存地址的基址! CE找基址是外挂最为关键的步骤，把基址找出来了，就可以做成外挂了，所以基址会找了就会制作外挂!就可以使用CE修改其他程序或游戏的数据了! ce6.7 Tutorial3.3教学步骤1 (密码:090453)欢迎使用 Cheat Engine 训练教程。 (v3.3)本教程将尝试讲解在游戏中作弊的一些基本知识，并帮助你熟悉 Cheat Engine 的使用方法。首先要执行 Cheat Engine ，如果你还没有运行它的话。然后点击”选择进程”图标按钮（左上角那个带有电脑的图标）。当进程列表窗口打开后找到这个训练程序，如果你没有重新命名该程序的名称，那么进程名应该”tutorial.exe”，选择它，并点击”打开”。现在暂时不要理会其它的按钮，如果你有兴趣的话，以后再研究它们。没什么意外的话，进程列表窗口将会消失并且在 Cheat Engine 主界面的上方会显示选择的进程名称。好了，点击”下一步”按钮进入下一个步骤（或输入密码进入你要练习的步骤）。 ce6.7 Tutorial3.3教学步骤2步骤 2: 精确值扫描 (密码=090453)现在你已经在 Cheat Engine 中打开了训练程序，为我们下一步的练习做好了准备。本窗口的左下方显示的”健康:XXX”，在你每次点击”打我”按钮时，它的值便会减少。要进入下一关，你必须找到这个数值并把它改成 1000 。很多方法都可以找到这个数值的位置，但我将告诉你一个最简单的方法，”精确数值”扫描：首先确认数值类型设置为2字节或4字节，设置成1字节也可以的，不过最终修改数据的时候便会有点麻烦了（虽然说这是很容易解决的问题）。假如该地址后边的字节数值都为 0 ，那么你设置成 8 字节也未尝不可，在这我们就不必尝试了。单浮点数，双浮点数，以及其他的扫描方法在这里行不通的，因为它们储存数值的方式不同。当数值类型设置正确后，确认扫描类型设置了”精确数值”，把健康值填写在数值的输入框，并点击”首次扫描”，稍等一会儿（假设你的电脑非常的慢），扫描完毕，扫描的结果将会显示在主界面的左侧。如果检索结果多于一个，你无法确定哪一个是正确的地址，那么继续点击”打我”，并将变更后的”健康值”填写在数值输入框中，点击”再次扫描”，重复这些步骤，直到你能确认已经找到了地址（在地址列表中只有一个地址）。好，双击左侧列表中的地址，该地址便会移动到下方的地址列表中并显示它的当前数值。双击下方地址列表中的数值（或者选择它，按下回车），填写你要修改的数值：1000 。如果操作正确，”下一步”按钮将变成可点击状态，本关就完成了。提示：如果你在扫描过程中出现了错误，可以点击”新的扫描”重新再来。当然，你也可以点击”打我”去查找一些更有价值的线索。以下是CE找基址的步骤1到步骤9的视频教程 ce6.7 Tutorial3.3教学步骤3步骤 3: 未知的初始值 (密码=419482)OK, 看来你已经理解了如何利用”精确数值”扫描查找数值了，让我们进行下一步。在上一关中我们知道初始数值的大小，所以我们可以利用”精确数值”扫描，但本关中仅有一个状态栏，我们并不知道它的初始数值。我们只知道这个数值在0到500之间，并且每次点击”打我”之后便会减些健康值，每次减少的健康值会显示在进度条的上方。同样有好几种方法可以找这个数值，（例如使用”数值减少了…”扫描方式），但我只教你最简单的方法，”未知的初始值”和”减少的数值”。 由于不知道当前数值的大小，”精确数值”扫描便派不上了用场，所以选择扫描方式”未知初始数值”。数值类型仍然选择 4 字节（这是因为大多数WINDOWS应用程序都使用 4 字节存放数据）。点击”首次扫描”并等待扫描结束。扫描完成后，点击”打我”，你会减少一些健康值。（减少的健康值显示几秒便会消失，你并不需要刻意记下它）。回到 Cheat Engine，在扫描类型中选择”减少的数值”，然后点击”再次扫描”。扫描完毕后，再次点击”打我”，并重复上述步骤，直到检索出很少的几个地址。 我们已经知道这个数值在0到500之间，所以挑出那个最为相似的地址，并将它加到下方的地址列表。现在，更改健康值为 5000，以便我们进入到下一关。 ce6.7 Tutorial3.3教学步骤4步骤 4: 浮点数 (密码=890124)在前面的教程中我们使用字节的方式进行扫描，但有些游戏使用了”浮点数”来存储数值（这么做是为了给菜鸟制造一些麻烦，让他们没那么容易修改游戏）。浮点数是带有小数点的数值（如 5.12 或 11321.1）。正如本关中的健康和弹药，两者都以浮点方法储存数据，不同的是，健康值为单精度浮点数，而弹药值为双精度浮点数。点击”打我”将减少一些健康值，而点击”开火”则消耗掉 0.5 的弹药。你得把这两项都修改到 5000 或者更多才能过关。”精确数值”扫描的方式虽然也可以完成本关的工作，但你应该试试其它更简练的扫描方式。提示: 扫描双浮点数类型建议禁用 “快速扫描” ce6.7 Tutorial3.3教学步骤5步骤 5: 代码查找 (密码=888899)某些游戏重新开始时，数据会存储在与上次不同的地方, 甚至游戏的过程中数据的存储位置也会变动。在这种情况下，你还是可以简单几步搞定它。这次我将尽量阐述如何运用”代码查找”功能。下方的数值每次启动教程的时候都会存放在内存不同的位置，所以地址列表中的固定地址是不起作用的。我们要先找到这个数值当前的存储地址（要如何去做，相信不用我再啰嗦了）。当你找到了地址就添加在下方的地址列表中，然后右健单击该地址，在弹出的菜单中选择”找出是什么改写了这个地址”，将弹出一个空白的窗口。接着点击本教程窗体上的”改变数值”按钮，并返回 Cheat Engine 。如果操作没问题 在刚才弹出的空白窗口中会出现一些汇编代码。选中代码并点击”替换”按钮，将它替换成什么也不做的代码（空指令），同时，修改后的代码也将放置在”高级选项”的代码列表中去（保存地址列表时会同时保存）。点击”停止”，游戏会以正常的方式继续运行下去，点击”关闭”按钮，关掉窗口。现在，再次点击教程窗口上的”改变数值”，没问题的话，”下一步”将变为可点击的状态。提示：如果你以足够快的速度锁定住该地址，”下一步”按钮也会变为可点击的。 ce6.7 Tutorial3.3教学步骤6步骤 6: 指针: (密码=098712)上一步阐述了如何使用”代码查找”功能对付变化位置的数据地址，但这种方法往往不能达到预期的效果，所以我们需要学习如何利用指针。在本关的 Tutorial.exe 窗口下面有两个按钮，一个会改变数值，另一个不但能改变数值而且还会改变数值在内存中存储的位置。这一步，你不需要懂得汇编，但如果懂的话会很有帮助。首先找到数值的地址，然后再查找是什么改写了这个地址。再次改变数值，CE 便可以列出找到的汇编代码。 双击一行汇编代码（或选择它并点击”详细信息”）并打开”详细信息”窗口以显示详细的信息，用来告诉你当这个指令运行时发生了什么事情。如果在这条汇编指令中没看到方括号（[]）的存在，我们就应该查看下一条汇编代码的详细信息，如果看到了方括号，那很可能表示我们已经找到了需要的指针。返回到主 cheat engine 窗口 （只要你愿意，你可以保持这个额外的信息窗口为打开状态。如果你要关掉它，那么要记好方栝号中间的代码）并做一次 4 字节的扫描，扫描”详细信息”窗口中告诉你的一串十六进制数值。扫描完成时它可能返回一个或几百个地址。大多数时候你需要的地址将是最少的一个。现在点击”手工添加地址”按钮，并勾选”指针”选项。”添加地址”窗口将发生变化，多出了”Address of Pointer（指针地址）”和”Offset (Hex)（偏移量(16进制)）”的文本框，以便您键入一个指针的地址和偏移量。请尽量填入刚才扫描到的地址。如果汇编指令中的方栝号里存在计算（例如：[esi+12]）则把数值部分填在”Offset (Hex)”的文本框中，如果不存在，则让它保持为 0 。如果看上去是更复杂的计算指令的话（举例说明一下）：[EAX2+EDX+00000310] eax=4C 并且 edx=00801234.这种情况下 EDX 便是数值的指针，而 EAX2+00000310 则是它的偏移量, 所以你要填在”Offset (Hex)”的将是 2*4C+00000310=3A8。（这些都是在十六进制下计算的，你可以使用WINDOWS的计算器，在科学方式下用十六进制计算）。回到教程，点击”确定”这个地址便会加到 CE 主窗口下方的地址列表中，如果没做错，在地址栏将显示 P-&gt;xxxxxxxx，而 xxxxxxxx 和你扫描到的地址数值是一致的，如果不一致，那么可能是哪里出错了。现在, 改变那条指针地址的数值为 5000 并锁定它，然后点击 Tutorial.exe 窗口上的”改变指针”按钮，如果一切正确，”下一步”按钮将变为可点击状态。备注:你也可以使用”指针扫描”的方式来查找这个指针地址。 ce6.7 Tutorial3.3教学步骤7步骤 7: 代码注入: (密码=013370)代码注入是将一小段你写出的代码注入到目标进程中并执行它的技巧。在这一步教程中，你将有一个健康值和一个每按一次将减少 1 点健康值的按钮，你的任务是利用”代码注入”，使每按一次按钮增加2点的健康值。查找这个地址，然后看看是什么在改写它（”找出是什么改写了这个地址”）。当你看到那条减少数值的汇编代码后，选择”显示反汇编程序”，然后打开”自动汇编窗口”（菜单-工具-&gt;自动汇编 或 按下快捷键 Ctrl+a )，选择”模板”中的”代码注入”。CE 将自动生成一部分汇编代码并为你输入指令做好准备（如果 CE 没有给出正确的地址，你也可以手工输入它）。注意 alloc 这部分代码，它会为你的代码分配出一小块空白的内存，过去，在 Win2000 之前的系统，这种行为存在安全隐患，很可能导致系统崩溃，幸运的是，这种情况在 win2000 以后的操作系统得到改善。也要注意line newmem: 、originalcode: 以及用文本”此处放置你的代码”标示出的空白部分正如你猜测的， 在这儿可以写下每次增加2点健康值的代码。在这种情况下推荐你使用 “ADD” 汇编指令，下面是一些示例：”ADD [00901234],9″ 使 [00901234] 地址的值增加9 “ADD [ESP+4],9” 使地址指针 [ESP+4] 的值增加9 在本关的情况下，你可以使用相同的手法处理减少健康值的那条原代码方括号之间的部分。提示 1：推荐你从原代码中删除减少健康值的那行代码，否则你得加 3 点健康值（你增加了3点，原代码减去1点，最终结果才会增加2点），这样看上去很容易让人迷惑，但最终方案还是由你来决定好了。提示 2:某些游戏中，原代码可能在多条指令之外，有时候（并非一向如此），它可能由不同的地方跳转至你的指令中并结束运行，其结果可能引起未知的错误；如果出现了这种情况，通常应当查看附近的那些跳转指令，进行修改，或者尝试使用不同地址进行代码注入，确认无误后便可以将你修改的代码注入到原代码中了。 ce6.7 Tutorial3.3教学步骤8步骤 8: 多级指针: (密码=525927)在这一步将解释如何使用多级指针。在第 6 步，你已经清楚 1 级指针的概念和用途，并可以利用数值的首个地址找到存放数据真正的基址。在本关中，你将看到 4 级指针，它由第一个指针指向第二个指针，再由第二个指针指向第三个指针，由第三个指针指向第四个指针，最终指向健康值的真正地址。开始的几步与在第 6 步中的操作基本相同。找出是什么访问了这个地址，然后分析汇编指令，查找指针地址中的数值，以及它的偏移量，将它们记下来。但这次你按数值找出的仍然是一个指针，你得依据这些数值，使用同样的操作方法找出指向这个指针的指针。看看是什么访问了你发现的那个指针地址，分析汇编指令，留意可能的代码和偏移量，并加以利用。持续这种过程，直到不能更进一步查找为止（通常基址为静态时，地址将以绿色标示）。点击”改变数值”改变健康值，如果你发现列表中那些指针地址所指向的值发生同样的变化时，那表示你可以试着将基址中的值更改为 5000，并锁定它，以便完成本关的任务了。备注1: 本步骤也可以使用自动汇编程序脚本或者使用指针扫描器加以解决。备注2: 在某些情况下，可以改变 CE 软件”代码查找”的相关设置。当你遇到类似于 mov eax,[eax] 的指令时，调试程序将显示改变之后的寄存器中的值，也许利用它更容易找出指针的位置。备注3: 你还在读？！当你查看汇编指令时你可能已经注意到，这些指针是在相同的代码块（相同的程序，如果你懂汇编，可以查看程序的起始代码）位置被读写。这种情况并不总会发生，但是当你在查找某个指针遇到问题的时候，没准能起到很大的用处。 ce6.7 Tutorial3.3教学步骤9步骤 9: 注入++: (密码=31337157)这一步将会解释如何处理游戏中的共用代码, 这种代码是通用在除了自己以外的其他同类型对像上常常你在修改游戏的时候, 你找到了一个单位的健康, 或是你自己角色的健康, 你会发现一种情况: 如果你把健康相关代码移除的话，其结果是你的角色无敌, 但你的敌人也无敌了。在这种情况下, 你必须想办法区分自己与敌人。有时候很简单, 你只要检查最前面的4个字节(函数指针表), 它通常指向一个独一无二的地址, 代表着游戏玩家角色，而有的时候它是一个团体号码, 或者也可能是一个指针, 它指向另一个指针, 该址针又指向下一个指针,搞不好还指向下下一个指针, 最后指向一个玩家名字。总之完全取决于游戏的复杂度, 以及你的运气最简单的方法是以”找出是什么改写了这个地址”去找出游戏代码，然后使用”分析(新/旧)数据/结构”的功能去比较两种结构。(你的单位和敌人的单位)然后看看是不是可以找到一个区分两者的方法。当你找到如何区分你和电脑单位的方法后，你可以注入一段自动汇编脚本来检查状态，然后看是要运行游戏的代码还是要做其他的修改。(例如一击必杀)另外, 你还可以用这个方法去创建一般所说的”字节数组”的字串, 它可以用来搜寻并产生一份所有你的单位或是敌人单位的列表 在这个教程中, 我已经实现了你将会玩到的最惊人的游戏.这个游戏有4个玩家。2个属于你的阵容, 另外两个属于电脑方。你的任务是找到改写健康的代码, 并且修改以至于你可以获得胜利，但”绝不能”使用锁定HP的方法.完成修改以后, 请按 “重新启动游戏并自动执行” 来测试你的修改是否正确提示1: 健康是一个单浮点数提示2: 解法不只一种以下是ce6.7 Tutorial3.3教学各步骤基址CT文件(包括32位和64位两个文件) 下载链接：https://pan.baidu.com/s/1smdbIHZ 密码：3t8e","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"ce技巧","slug":"ce技巧","permalink":"https://goodhelp.gitee.io/tags/ce%E6%8A%80%E5%B7%A7/"},{"name":"基址查找方法","slug":"基址查找方法","permalink":"https://goodhelp.gitee.io/tags/%E5%9F%BA%E5%9D%80%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95/"},{"name":"精品软件","slug":"精品软件","permalink":"https://goodhelp.gitee.io/tags/%E7%B2%BE%E5%93%81%E8%BD%AF%E4%BB%B6/"}]},{"title":"自定义公告_超强的自定义网吧公告程序","slug":"soft/自定义公告-超强的自定义网吧公告程序","date":"2018-02-03T13:45:06.000Z","updated":"2021-09-11T16:44:35.025Z","comments":true,"path":"page/3399946887/","link":"","permalink":"https://goodhelp.gitee.io/page/3399946887/","excerpt":"在网吧，开机一般会有一个公告程序运行，在桌面上显示一些通知，注意事项，或网吧活动等内容!现普通使用的公告是营销软件的公告，在营销软件后台设置公告，选择一个模板，开启开机运行！但营销系统的公告程序相当死板，不能自定义显示样式，并且会显示一些广告之类没用的内容!本站的自定义公告应运而生!此自定义公告程序并非只能使用在网吧，任何需要开机运行公告的地方都可以使用本程序! 自定义公告程序功能: 完全自定义公告模板。你可以把桌面当成一块画板，任意制作模板，我们提供了八套模板，不会制作模板只需要改文字就可以了!如果你会html，完全可以自定义桌面在哪儿显示什么公告内容!你不会网页编辑也可以，你只要会word排版，然后把word文件存为web格式，一样可以做为公告程序显示! 随机显示模板。公告显示的目的就是让顾客注意看，并不是广告，但很多顾客开机后就关闭了，根本不会看，因为一成不变的显示方式，让顾客没有新颖感！本站自定义公告程序会根据本程序的html目录中的html模板，随机显示公告，让每次开机都保持新鲜感!如果你只想显示固定的模板，你只需要在html目录，只保留一款公告模板即可! 模板中可自定义启动程序!在设计模板时，使用onclick=’javascript:external.Run(“可执行程序”,”程序参数”)’ 来启动运行程序，比如我们在html模板中添加一按钮，然后添加onclick=’javascript:external.Run(“ClientStarter.exe”,”barapp /WebApps/web/BClient/call.html”)’ 就是启动了网乐程序的呼叫网管! 需要注意的是这儿的可执行程序如果不加路径，就是在当前公告所在目录的程序，另外需要注意的加上路径或参数时，斜杠必须是正斜杠! 看看其中几款公告以图片的形式动态显示公告内容，以下是文字方式显示公告，公告窗体运行时都是动态方式出现，动感十足! 下载地址： 链接: https://pan.baidu.com/s/17Vx9Ad6-XbFDoptL4V2mdQ 提取码: rnjj 复制这段内容后打开百度网盘手机App，操作更方便哦 解压密码 bnwin.com","text":"在网吧，开机一般会有一个公告程序运行，在桌面上显示一些通知，注意事项，或网吧活动等内容!现普通使用的公告是营销软件的公告，在营销软件后台设置公告，选择一个模板，开启开机运行！但营销系统的公告程序相当死板，不能自定义显示样式，并且会显示一些广告之类没用的内容!本站的自定义公告应运而生!此自定义公告程序并非只能使用在网吧，任何需要开机运行公告的地方都可以使用本程序! 自定义公告程序功能: 完全自定义公告模板。你可以把桌面当成一块画板，任意制作模板，我们提供了八套模板，不会制作模板只需要改文字就可以了!如果你会html，完全可以自定义桌面在哪儿显示什么公告内容!你不会网页编辑也可以，你只要会word排版，然后把word文件存为web格式，一样可以做为公告程序显示! 随机显示模板。公告显示的目的就是让顾客注意看，并不是广告，但很多顾客开机后就关闭了，根本不会看，因为一成不变的显示方式，让顾客没有新颖感！本站自定义公告程序会根据本程序的html目录中的html模板，随机显示公告，让每次开机都保持新鲜感!如果你只想显示固定的模板，你只需要在html目录，只保留一款公告模板即可! 模板中可自定义启动程序!在设计模板时，使用onclick=’javascript:external.Run(“可执行程序”,”程序参数”)’ 来启动运行程序，比如我们在html模板中添加一按钮，然后添加onclick=’javascript:external.Run(“ClientStarter.exe”,”barapp /WebApps/web/BClient/call.html”)’ 就是启动了网乐程序的呼叫网管! 需要注意的是这儿的可执行程序如果不加路径，就是在当前公告所在目录的程序，另外需要注意的加上路径或参数时，斜杠必须是正斜杠! 看看其中几款公告以图片的形式动态显示公告内容，以下是文字方式显示公告，公告窗体运行时都是动态方式出现，动感十足! 下载地址： 链接: https://pan.baidu.com/s/17Vx9Ad6-XbFDoptL4V2mdQ 提取码: rnjj 复制这段内容后打开百度网盘手机App，操作更方便哦 解压密码 bnwin.com","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"原创软件","slug":"原创软件","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%9F%E5%88%9B%E8%BD%AF%E4%BB%B6/"}]},{"title":"动态逆向调试工具OllyDbg","slug":"soft/动态逆向调试工具OllyDbg","date":"2018-02-03T04:00:00.000Z","updated":"2021-09-11T16:45:41.462Z","comments":true,"path":"page/458367381/","link":"","permalink":"https://goodhelp.gitee.io/page/458367381/","excerpt":"OllyDbg是一个32位汇编级分析调试器。对二进制代码分析功能使它在不知道可执行文件源码的情况下特别有用。OllyDbg是一个共享软件。功能特点：直观的用户界面，没有复杂的命令；代码分析-跟踪寄存器，识别过程，循环，API调用，开关，表，常量和字符串；直接加载和调试DLL；对象文件扫描——从对象文件和库中查找例程；允许用户定义的标签、注释和功能描述；理解在Borland®格式的调试信息；修改汇编代码后可直接保存为可执行文件；开放体系结构-许多第三方插件可用；纯绿色,没有安装-注册表或系统目录中没有垃圾；调试多线程应用程序;附加到运行的程序;可配置的反汇编程序，支持MASM和理想的格式；MMX，3dnow！和SSE数据类型和指令，包括Athlon扩展；完整的Unicode支持；动态识别ASCII和Unicode字符串-也用Delphi格式！识别复杂的代码结构，如调用跳转到过程。解码调用超过1900个标准API和400个C函数；从外部帮助文件对API函数提供上下文敏感帮助；设置条件、日志、内存和硬件断点；跟踪程序执行，记录已知函数的参数；还有很多，更多！总之OllyDbg就是Ring3级的调试器，将IDA与SoftICE结合起来的思想，非常容易上手!OllyDbg英文官方网站：http://www.ollydbg.de/ 中文站 http://www.ollydbg.net/ OllyDbg1.10官网下载地址 http://www.ollydbg.de/odbg110.zip OllyDbg 1.10看雪下载地址 https://tool.pediy.com/index-detail-1.htm 吾爱破解专用版OllyDbg下载地址 http://down.52pojie.cn/Tools/Debuggers/吾爱破解专用版Ollydbg.rar 吾爱破解专用版OllyDbg更新日志 2016年1月21日更新如下：1、默认勾选“解码修饰符号名称（Demangle symbolic names）”，方便调试分析MFC类程序。2、本次更新后压缩包：9413A89DE76D48B0D6F1807A6A42BAB7 吾爱破解专用版Ollydbg.rar 2015年12月14日更新如下：1、删除ILLY.dll和ODbgScript_Win2k.dll插件，由于部分同学机器未装.NET会报错。2、添加OllyDisasm201插件。（http://www.52pojie.cn/thread-443516-1-1.html）3、将“路径修复工具”静态编译，方便没装运行库的xp机器也能运行。4、本次更新后压缩包：E138F9543C5A0953DDBCA95AFDACF8FE 吾爱破解专用版Ollydbg.rar 2015年7月2日更新如下：1、更新ILLY插件修复调试.NET程序异常的问题，感谢@凉游浅笔深画眉 反馈http://www.52pojie.cn/thread-366158-1-1.html。2、添加一个loadmap插件、更新字符串搜索插件、删除一些不必要的文件，完善一些细节。3、添加白底黑字配置，需要请自行将”ollydbg_白底黑字配置.ini“替换成”ollydbg.ini“。4、增加ollydbg.ini中的路径自动修复程序。5、本次更新后压缩包：57CFF212D319E7A693D6F7D44465BF54 吾爱破解专用版Ollydbg.rar 2015年4月10日更新如下：1、对Ollydbg的窗口签名进行了更改，从而避免被针对性检测。2、对Ollydbg的菜单做出调整。3、针对一些有可能被检测的插件进行了删减。4、修改了一些可能被检测的内容。5、更新ollydbg的插件为目前较新的版本。","text":"OllyDbg是一个32位汇编级分析调试器。对二进制代码分析功能使它在不知道可执行文件源码的情况下特别有用。OllyDbg是一个共享软件。功能特点：直观的用户界面，没有复杂的命令；代码分析-跟踪寄存器，识别过程，循环，API调用，开关，表，常量和字符串；直接加载和调试DLL；对象文件扫描——从对象文件和库中查找例程；允许用户定义的标签、注释和功能描述；理解在Borland®格式的调试信息；修改汇编代码后可直接保存为可执行文件；开放体系结构-许多第三方插件可用；纯绿色,没有安装-注册表或系统目录中没有垃圾；调试多线程应用程序;附加到运行的程序;可配置的反汇编程序，支持MASM和理想的格式；MMX，3dnow！和SSE数据类型和指令，包括Athlon扩展；完整的Unicode支持；动态识别ASCII和Unicode字符串-也用Delphi格式！识别复杂的代码结构，如调用跳转到过程。解码调用超过1900个标准API和400个C函数；从外部帮助文件对API函数提供上下文敏感帮助；设置条件、日志、内存和硬件断点；跟踪程序执行，记录已知函数的参数；还有很多，更多！总之OllyDbg就是Ring3级的调试器，将IDA与SoftICE结合起来的思想，非常容易上手!OllyDbg英文官方网站：http://www.ollydbg.de/ 中文站 http://www.ollydbg.net/ OllyDbg1.10官网下载地址 http://www.ollydbg.de/odbg110.zip OllyDbg 1.10看雪下载地址 https://tool.pediy.com/index-detail-1.htm 吾爱破解专用版OllyDbg下载地址 http://down.52pojie.cn/Tools/Debuggers/吾爱破解专用版Ollydbg.rar 吾爱破解专用版OllyDbg更新日志 2016年1月21日更新如下：1、默认勾选“解码修饰符号名称（Demangle symbolic names）”，方便调试分析MFC类程序。2、本次更新后压缩包：9413A89DE76D48B0D6F1807A6A42BAB7 吾爱破解专用版Ollydbg.rar 2015年12月14日更新如下：1、删除ILLY.dll和ODbgScript_Win2k.dll插件，由于部分同学机器未装.NET会报错。2、添加OllyDisasm201插件。（http://www.52pojie.cn/thread-443516-1-1.html）3、将“路径修复工具”静态编译，方便没装运行库的xp机器也能运行。4、本次更新后压缩包：E138F9543C5A0953DDBCA95AFDACF8FE 吾爱破解专用版Ollydbg.rar 2015年7月2日更新如下：1、更新ILLY插件修复调试.NET程序异常的问题，感谢@凉游浅笔深画眉 反馈http://www.52pojie.cn/thread-366158-1-1.html。2、添加一个loadmap插件、更新字符串搜索插件、删除一些不必要的文件，完善一些细节。3、添加白底黑字配置，需要请自行将”ollydbg_白底黑字配置.ini“替换成”ollydbg.ini“。4、增加ollydbg.ini中的路径自动修复程序。5、本次更新后压缩包：57CFF212D319E7A693D6F7D44465BF54 吾爱破解专用版Ollydbg.rar 2015年4月10日更新如下：1、对Ollydbg的窗口签名进行了更改，从而避免被针对性检测。2、对Ollydbg的菜单做出调整。3、针对一些有可能被检测的插件进行了删减。4、修改了一些可能被检测的内容。5、更新ollydbg的插件为目前较新的版本。","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"精品软件","slug":"精品软件","permalink":"https://goodhelp.gitee.io/tags/%E7%B2%BE%E5%93%81%E8%BD%AF%E4%BB%B6/"}]},{"title":"RemoteAdo数据库中间件爆破分析(RemoteAdo破解版)","slug":"article/RemoteAdo数据库中间件爆破分析-RemoteAdo破解版","date":"2018-01-31T02:45:22.000Z","updated":"2021-09-16T23:39:21.660Z","comments":true,"path":"page/407779666/","link":"","permalink":"https://goodhelp.gitee.io/page/407779666/","excerpt":"RemoteAdo是一款数据库中间件，官网为http://www.remoteado.cn/ 本爆破教程基于RemoteAdo标准版4.2分析! 下载RemoteAdo标准版4.2，使用die1.01分析，RemoteAdoServer.exe主程序加壳为ASPack(2.12) 使用WASPACK脱掉 用OD载入，插件打开api常用断点下MessageBoxA断点，为什么下这个断点呢？因为点注册的时候会弹出序列号无效 ，断点下好后，按F9运行，按RemoteAdo软件界面中的其他选项卡中的“请注册”，在弹出的窗口中任意输入序列号然后点击注册按钮!这时在OD中已经断下了，按一次Ctrl+F9，再切换到RemoteAdo软件界面，这时提示“序列号无效”，点确定，然后切换为OD，再按一次Ctrl+F9，OD中返回到RemoteAdo的软件领空! 我们看右边寄存器显示有“序列号无效”和“软件注册”等字样! 从此处（00483E18）往上看汇编代码，看是哪儿跳到这儿来的！找到00483E18看从哪儿跳来的，我不习惯使用od看，觉得不够清晰，我喜欢使用w32dasm看，在W32Dasm中shift+f12输入00483E18，往上看，一直到上面这儿（为什么到这儿，你可以从00483E18上面的多个跳转分别下断点测试，那些都是显示序列号无效的相关代码） 在00483CC4开始到00483E18都是显示序列号无效的代码，(我们可以切换回OD在00483CC4处双击，写入汇编代码 retn，不执行直接返回，这时你可以重新运行点注册，会什么反应也没有!) 在00483CC4上方显示，调用此call的地址有7个，我们分别在以上7个调用地址前下断点，重新点击注册，看会不会断下!经过测试会在倒数第二个0056204E处断下!在W32Dasm中shift+F12，跳转到0056204E处!往上看代码，到底是谁调用了序列号无效的提示代码！ 看到这段代码 其中00561FC3处的call就是序列号算法函数，爆破只需要在OD中把00561FCA处填充NOP代码即可!NOP后，这时点软件中的注册会提示注册成功，但重启软件后，还是只有5个连接数! 以下是去掉连接数及破解版内容 在W32Dasm中我们在00561FC3处点击Call按钮，看哪些地方调用了这个注册算法函数，到这儿 有两处，一处就是0055B9AB，这处是启动软件判断是否注册的，一处是00561FC3，就是我们点注册按钮判断是否注册的!在OD中我们跳到0055B9AB处，把下面的je代码NOP掉，然后保存修改的文件，就OK了!至于算法，分析太麻烦了，有兴趣自己折腾!爆破后没有5个用户连接数限制，以下是10个连接数图! 后话：因为前面分析中看到有7处调用了，序列号无效的函数，我们这儿只修改了两处，所以如果你使用中存在提示序列号无效的问题，那就需要在另外5处也用相同的方法进行修改!只修改两处，使用中暂没发现有什么问题! 按上面分析修改好两处的成品下载 链接：https://pan.baidu.com/s/1gg9jHa7 密码：sbrw 解压密码 bnwin.com","text":"RemoteAdo是一款数据库中间件，官网为http://www.remoteado.cn/ 本爆破教程基于RemoteAdo标准版4.2分析! 下载RemoteAdo标准版4.2，使用die1.01分析，RemoteAdoServer.exe主程序加壳为ASPack(2.12) 使用WASPACK脱掉 用OD载入，插件打开api常用断点下MessageBoxA断点，为什么下这个断点呢？因为点注册的时候会弹出序列号无效 ，断点下好后，按F9运行，按RemoteAdo软件界面中的其他选项卡中的“请注册”，在弹出的窗口中任意输入序列号然后点击注册按钮!这时在OD中已经断下了，按一次Ctrl+F9，再切换到RemoteAdo软件界面，这时提示“序列号无效”，点确定，然后切换为OD，再按一次Ctrl+F9，OD中返回到RemoteAdo的软件领空! 我们看右边寄存器显示有“序列号无效”和“软件注册”等字样! 从此处（00483E18）往上看汇编代码，看是哪儿跳到这儿来的！找到00483E18看从哪儿跳来的，我不习惯使用od看，觉得不够清晰，我喜欢使用w32dasm看，在W32Dasm中shift+f12输入00483E18，往上看，一直到上面这儿（为什么到这儿，你可以从00483E18上面的多个跳转分别下断点测试，那些都是显示序列号无效的相关代码） 在00483CC4开始到00483E18都是显示序列号无效的代码，(我们可以切换回OD在00483CC4处双击，写入汇编代码 retn，不执行直接返回，这时你可以重新运行点注册，会什么反应也没有!) 在00483CC4上方显示，调用此call的地址有7个，我们分别在以上7个调用地址前下断点，重新点击注册，看会不会断下!经过测试会在倒数第二个0056204E处断下!在W32Dasm中shift+F12，跳转到0056204E处!往上看代码，到底是谁调用了序列号无效的提示代码！ 看到这段代码 其中00561FC3处的call就是序列号算法函数，爆破只需要在OD中把00561FCA处填充NOP代码即可!NOP后，这时点软件中的注册会提示注册成功，但重启软件后，还是只有5个连接数! 以下是去掉连接数及破解版内容 在W32Dasm中我们在00561FC3处点击Call按钮，看哪些地方调用了这个注册算法函数，到这儿 有两处，一处就是0055B9AB，这处是启动软件判断是否注册的，一处是00561FC3，就是我们点注册按钮判断是否注册的!在OD中我们跳到0055B9AB处，把下面的je代码NOP掉，然后保存修改的文件，就OK了!至于算法，分析太麻烦了，有兴趣自己折腾!爆破后没有5个用户连接数限制，以下是10个连接数图! 后话：因为前面分析中看到有7处调用了，序列号无效的函数，我们这儿只修改了两处，所以如果你使用中存在提示序列号无效的问题，那就需要在另外5处也用相同的方法进行修改!只修改两处，使用中暂没发现有什么问题! 按上面分析修改好两处的成品下载 链接：https://pan.baidu.com/s/1gg9jHa7 密码：sbrw 解压密码 bnwin.com","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"remoteado破解","slug":"remoteado破解","permalink":"https://goodhelp.gitee.io/tags/remoteado%E7%A0%B4%E8%A7%A3/"}]},{"title":"delphi如何在Ring3下跨进程获取DLL信息","slug":"code/delphi如何在Ring3下跨进程获取DLL信息","date":"2018-01-23T05:00:05.000Z","updated":"2021-09-16T23:32:55.184Z","comments":true,"path":"page/3910524000/","link":"","permalink":"https://goodhelp.gitee.io/page/3910524000/","excerpt":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250unit APIUnit;&#123; GetProcessModuleHandle API Unit Ring3调用NtQueryInformationProcess实现跨进程获取DLL句柄 &#125;interfaceUSES Winapi.Windows,System.SysUtils;type USHORT = Word; UNICODE_STRING = packed Record Length : USHORT; MaximumLength: USHORT; Buffer : PWideString; end; RTL_USER_PROCESS_PARAMETERS = packed record Reserved1 : array[0..15] of Byte; Reserved2 : array[0..9] of Pointer; ImagePathName: UNICODE_STRING; CommandLine : UNICODE_STRING; end; PRTL_USER_PROCESS_PARAMETERS = ^RTL_USER_PROCESS_PARAMETERS; _PEB_LDR_DATA = record Length: ULONG; Initialized: BOOLEAN; SsHandle: pointer;//PVOID; InLoadOrderModuleList: LIST_ENTRY; InMemoryOrderModuleList: LIST_ENTRY; InInitializationOrderModuleList: LIST_ENTRY; end &#123;_PEB_LDR_DATA&#125;; PEB_LDR_DATA = _PEB_LDR_DATA; PPEB_LDR_DATA = ^_PEB_LDR_DATA; _LDR_MODULE = record InLoadOrderModuleList: LIST_ENTRY; InMemoryOrderModuleList: LIST_ENTRY; InInitializationOrderModuleList: LIST_ENTRY; BaseAddress: pointer; EntryPoint: pointer; SizeOfImage: ULONG; FullDllName: UNICODE_STRING; BaseDllName: UNICODE_STRING; Flags: ULONG; LoadCount: SmallInt; TlsIndex: SmallInt; HashTableEntry: LIST_ENTRY; TimeDateStamp: ULONG; end &#123;_LDR_MODULE&#125;; LDR_MODULE = _LDR_MODULE; PLDR_MODULE = ^_LDR_MODULE; _PEB_FREE_BLOCK = record Next:Pointer; Size:ULONG; end; PPEB_FREE_BLOCK = ^_PEB_FREE_BLOCK; PEB = packed record InheritedAddressSpace:Boolean;// 00h ReadImageFileExecOptions:Boolean; // 01h BeingDebugged:Boolean; //02H Spare:Boolean; Mutant:THandle; ImageBaseAddress:Pointer; LoaderData:Pointer; //0C ProcessParameters:Pointer; SubSystemData:Pointer; ProcessHeap:Pointer; FastPebLock:Pointer; FastPebLockRoutine:PPointer; FastPebUnlockRoutine:PPointer; EnvironmentUpdateCount:ULONG; KernelCallbackTable:^Pointer; EventLogSection:Pointer; EventLog:Pointer; FreeList:PPEB_FREE_BLOCK; TlsExpansionCounter:ULONG; TlsBitmap:Pointer; TlsBitmapBits:array [0..$2] of ULONG; ReadOnlySharedMemoryBase:Pointer; ReadOnlySharedMemoryHeap:Pointer; ReadOnlyStaticServerData:^Pointer; AnsiCodePageData:Pointer; OemCodePageData:Pointer; UnicodeCaseTableData:Pointer; NumberOfProcessors:ULONG; NtGlobalFlag:ULONG; Spare2:array [0..$4] of Byte; CriticalSectionTimeout:LARGE_INTEGER; HeapSegmentReserve:ULONG; HeapSegmentCommit:ULONG; HeapDeCommitTotalFreeThreshold:ULONG; HeapDeCommitFreeBlockThreshold:Ulong; NumberOfHeaps:ULONG; MaximumNumberOfHeaps:ULONG; ProcessHeaps:PPointer; GdiSharedHandleTable:Pointer; ProcessStarterHelper:Pointer; GdiDCAttributeList:Pointer; LoaderLock:Pointer; OSMajorVersion:ULONG; OSMinorVersion:ULONG; OSBuildNumber:ULONG; OSPlatformId:ULONG; ImageSubSystem:ULONG; ImageSubSystemMajorVersion:ULONG; ImageSubSystemMinorVersion:ULONG; GdiHandleBuffer:array [0..$22] of ULONG; PostProcessInitRoutine:ULONG; TlsExpansionBitmap:ULONG; TlsExpansionBitmapBits: array [0..$80] of Byte; SessionId:ULONG; end; PPEB = ^PEB; PROCESS_BASIC_INFORMATION = packed record ExitStatus : DWORD; PebBaseAddress: PPEB; AffinityMask : DWORD; BasePriority : DWORD; uUniqueProcessId: ULong; uInheritedFromUniqueProcessId: ULong; end; TProcessBasicInformation = PROCESS_BASIC_INFORMATION; function NtQueryInformationProcess( ProcessHandle: THandle; &#123;进程句柄&#125; ProcessInformationClass: Byte; &#123;信息类型&#125; ProcessInformation: Pointer; &#123;缓冲指针&#125; ProcessInformationLength: ULONG; &#123;以字节为单位的缓冲大小&#125; ReturnLength: PULONG &#123;写入缓冲的字节数&#125; ): DWORD; stdcall; external &#x27;ntdll.dll&#x27;;function GetProcessModuleHandle(dwProcessID:DWORD;DllName:PChar):DWORD;implementation function EnablePrivilege(hToken: Cardinal; PrivName: string; bEnable: Boolean):Boolean; var TP: TOKEN_PRIVILEGES; Dummy: Cardinal; begin try TP.PrivilegeCount := 1; LookupPrivilegeValue(nil, pchar(PrivName), TP.Privileges[0].Luid); if bEnable then TP.Privileges[0].Attributes := SE_PRIVILEGE_ENABLED else TP.Privileges[0].Attributes := 0; AdjustTokenPrivileges(hToken, False, TP, SizeOf(TP), nil, Dummy); except end; Result :=True; end; function EnableDebugPrivilege: Boolean; var hToken: THandle; begin Result := False; try OpenProcessToken(GetCurrentProcess, TOKEN_ADJUST_PRIVILEGES, hToken); EnablePrivilege(hToken, &#x27;SeDebugPrivilege&#x27;, True); CloseHandle(hToken); Result :=True; except end; end; function GetProcessModuleHandle(dwProcessID:DWORD;DllName:PChar):DWORD; var hProcess:DWORD; PBI:TProcessBasicInformation; r,ret:DWORD; readByte: SIZE_T; PEBType:PPEB; PLD :PPEB_LDR_DATA; PME :PLDR_MODULE; PEBDLLName:PChar; const Size:DWORD = 255; begin Result := 0; GetMem(PEBType,SizeOf(PEB)); ZeroMemory(PEBType,SizeOf(PEB)); GetMem(PLD,SizeOf(PEB_LDR_DATA)); ZeroMemory(PLD,SizeOf(PEB_LDR_DATA)); GetMem(PME,SizeOf(LDR_MODULE)); ZeroMemory(PME,SizeOf(LDR_MODULE)); GetMem(PEBDLLName,Size); try //提升进程权限 if not EnableDebugPrivilege then begin OutputDebugStringW(&#x27;Do not have Debug privilege&#x27;); //无法提升调试权限 end; //如果PID为0则获取自身的伪句柄，如果不是则获取指定PID的句柄 if dwProcessID &lt;&gt; 0 then //打开进程，需要PROCESS_QUERY_INFORMATION和PROCESS_VM_READ权限 hProcess := OpenProcess(PROCESS_QUERY_INFORMATION or PROCESS_VM_READ, FALSE,dwProcessID) else hProcess := GetCurrentProcess; //调用NtQueryInformationProcess获取结构信息 ret := NtQueryInformationProcess(hProcess,0,@PBI,SizeOf(PBI),@r); //正常情况下ret是0，如果不是则认为错误 if ret = 0 then begin //获取PEB结构 ReadProcessMemory(hProcess,PBI.PebBaseAddress,PEBType,SizeOf(PEB),readByte); //获取PLD结构 ReadProcessMemory(hProcess,PEBType.LoaderData,PLD,SizeOf(PEB_LDR_DATA),readByte); //获取第一个PME ReadProcessMemory(hProcess,PLD.InLoadOrderModuleList.Flink,PME,SizeOf(LDR_MODULE),readByte); //循环 while True do begin //清零缓冲区 ZeroMemory(PEBDLLName,Size); //读取buff到内存中，获取当前结构的DLL名 if not ReadProcessMemory(hProcess,PME.BaseDllName.Buffer,PEBDLLName,PME.BaseDllName.Length,readByte) then Break; //对比DLL名称，不区分大小写 if LowerCase(AnsiString(PEBDLLName)) = LowerCase(AnsiString(DllName)) then begin //调试信息 OutputDebugStringW(PEBDLLName); //返回DLL的句柄 Result := dword(pme.BaseAddress); //退出循环 Break; end; //调试信息 OutputDebugStringW(PEBDLLName); //如果下一个结构为开始的结构，则认为链表已经枚举完了 if PME.InLoadOrderModuleList.Flink = PLD.InLoadOrderModuleList.Flink then Break; //读取下一个结构 if not ReadProcessMemory(hProcess,PME.InLoadOrderModuleList.Flink,PME,SizeOf(LDR_MODULE),readByte) then Break; end; end else begin //返回错误信息 OutputDebugStringW(&#x27;Error!NtQueryInformationProcess Error!&#x27;); end; finally //释放使用的内存 FreeMem(PEBDLLName,Size); FreeMem(PME,SizeOf(LDR_MODULE)); FreeMem(PLD,SizeOf(PEB_LDR_DATA)); FreeMem(PEBType,SizeOf(PEB)); end; end;end.","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250unit APIUnit;&#123; GetProcessModuleHandle API Unit Ring3调用NtQueryInformationProcess实现跨进程获取DLL句柄 &#125;interfaceUSES Winapi.Windows,System.SysUtils;type USHORT = Word; UNICODE_STRING = packed Record Length : USHORT; MaximumLength: USHORT; Buffer : PWideString; end; RTL_USER_PROCESS_PARAMETERS = packed record Reserved1 : array[0..15] of Byte; Reserved2 : array[0..9] of Pointer; ImagePathName: UNICODE_STRING; CommandLine : UNICODE_STRING; end; PRTL_USER_PROCESS_PARAMETERS = ^RTL_USER_PROCESS_PARAMETERS; _PEB_LDR_DATA = record Length: ULONG; Initialized: BOOLEAN; SsHandle: pointer;//PVOID; InLoadOrderModuleList: LIST_ENTRY; InMemoryOrderModuleList: LIST_ENTRY; InInitializationOrderModuleList: LIST_ENTRY; end &#123;_PEB_LDR_DATA&#125;; PEB_LDR_DATA = _PEB_LDR_DATA; PPEB_LDR_DATA = ^_PEB_LDR_DATA; _LDR_MODULE = record InLoadOrderModuleList: LIST_ENTRY; InMemoryOrderModuleList: LIST_ENTRY; InInitializationOrderModuleList: LIST_ENTRY; BaseAddress: pointer; EntryPoint: pointer; SizeOfImage: ULONG; FullDllName: UNICODE_STRING; BaseDllName: UNICODE_STRING; Flags: ULONG; LoadCount: SmallInt; TlsIndex: SmallInt; HashTableEntry: LIST_ENTRY; TimeDateStamp: ULONG; end &#123;_LDR_MODULE&#125;; LDR_MODULE = _LDR_MODULE; PLDR_MODULE = ^_LDR_MODULE; _PEB_FREE_BLOCK = record Next:Pointer; Size:ULONG; end; PPEB_FREE_BLOCK = ^_PEB_FREE_BLOCK; PEB = packed record InheritedAddressSpace:Boolean;// 00h ReadImageFileExecOptions:Boolean; // 01h BeingDebugged:Boolean; //02H Spare:Boolean; Mutant:THandle; ImageBaseAddress:Pointer; LoaderData:Pointer; //0C ProcessParameters:Pointer; SubSystemData:Pointer; ProcessHeap:Pointer; FastPebLock:Pointer; FastPebLockRoutine:PPointer; FastPebUnlockRoutine:PPointer; EnvironmentUpdateCount:ULONG; KernelCallbackTable:^Pointer; EventLogSection:Pointer; EventLog:Pointer; FreeList:PPEB_FREE_BLOCK; TlsExpansionCounter:ULONG; TlsBitmap:Pointer; TlsBitmapBits:array [0..$2] of ULONG; ReadOnlySharedMemoryBase:Pointer; ReadOnlySharedMemoryHeap:Pointer; ReadOnlyStaticServerData:^Pointer; AnsiCodePageData:Pointer; OemCodePageData:Pointer; UnicodeCaseTableData:Pointer; NumberOfProcessors:ULONG; NtGlobalFlag:ULONG; Spare2:array [0..$4] of Byte; CriticalSectionTimeout:LARGE_INTEGER; HeapSegmentReserve:ULONG; HeapSegmentCommit:ULONG; HeapDeCommitTotalFreeThreshold:ULONG; HeapDeCommitFreeBlockThreshold:Ulong; NumberOfHeaps:ULONG; MaximumNumberOfHeaps:ULONG; ProcessHeaps:PPointer; GdiSharedHandleTable:Pointer; ProcessStarterHelper:Pointer; GdiDCAttributeList:Pointer; LoaderLock:Pointer; OSMajorVersion:ULONG; OSMinorVersion:ULONG; OSBuildNumber:ULONG; OSPlatformId:ULONG; ImageSubSystem:ULONG; ImageSubSystemMajorVersion:ULONG; ImageSubSystemMinorVersion:ULONG; GdiHandleBuffer:array [0..$22] of ULONG; PostProcessInitRoutine:ULONG; TlsExpansionBitmap:ULONG; TlsExpansionBitmapBits: array [0..$80] of Byte; SessionId:ULONG; end; PPEB = ^PEB; PROCESS_BASIC_INFORMATION = packed record ExitStatus : DWORD; PebBaseAddress: PPEB; AffinityMask : DWORD; BasePriority : DWORD; uUniqueProcessId: ULong; uInheritedFromUniqueProcessId: ULong; end; TProcessBasicInformation = PROCESS_BASIC_INFORMATION; function NtQueryInformationProcess( ProcessHandle: THandle; &#123;进程句柄&#125; ProcessInformationClass: Byte; &#123;信息类型&#125; ProcessInformation: Pointer; &#123;缓冲指针&#125; ProcessInformationLength: ULONG; &#123;以字节为单位的缓冲大小&#125; ReturnLength: PULONG &#123;写入缓冲的字节数&#125; ): DWORD; stdcall; external &#x27;ntdll.dll&#x27;;function GetProcessModuleHandle(dwProcessID:DWORD;DllName:PChar):DWORD;implementation function EnablePrivilege(hToken: Cardinal; PrivName: string; bEnable: Boolean):Boolean; var TP: TOKEN_PRIVILEGES; Dummy: Cardinal; begin try TP.PrivilegeCount := 1; LookupPrivilegeValue(nil, pchar(PrivName), TP.Privileges[0].Luid); if bEnable then TP.Privileges[0].Attributes := SE_PRIVILEGE_ENABLED else TP.Privileges[0].Attributes := 0; AdjustTokenPrivileges(hToken, False, TP, SizeOf(TP), nil, Dummy); except end; Result :=True; end; function EnableDebugPrivilege: Boolean; var hToken: THandle; begin Result := False; try OpenProcessToken(GetCurrentProcess, TOKEN_ADJUST_PRIVILEGES, hToken); EnablePrivilege(hToken, &#x27;SeDebugPrivilege&#x27;, True); CloseHandle(hToken); Result :=True; except end; end; function GetProcessModuleHandle(dwProcessID:DWORD;DllName:PChar):DWORD; var hProcess:DWORD; PBI:TProcessBasicInformation; r,ret:DWORD; readByte: SIZE_T; PEBType:PPEB; PLD :PPEB_LDR_DATA; PME :PLDR_MODULE; PEBDLLName:PChar; const Size:DWORD = 255; begin Result := 0; GetMem(PEBType,SizeOf(PEB)); ZeroMemory(PEBType,SizeOf(PEB)); GetMem(PLD,SizeOf(PEB_LDR_DATA)); ZeroMemory(PLD,SizeOf(PEB_LDR_DATA)); GetMem(PME,SizeOf(LDR_MODULE)); ZeroMemory(PME,SizeOf(LDR_MODULE)); GetMem(PEBDLLName,Size); try //提升进程权限 if not EnableDebugPrivilege then begin OutputDebugStringW(&#x27;Do not have Debug privilege&#x27;); //无法提升调试权限 end; //如果PID为0则获取自身的伪句柄，如果不是则获取指定PID的句柄 if dwProcessID &lt;&gt; 0 then //打开进程，需要PROCESS_QUERY_INFORMATION和PROCESS_VM_READ权限 hProcess := OpenProcess(PROCESS_QUERY_INFORMATION or PROCESS_VM_READ, FALSE,dwProcessID) else hProcess := GetCurrentProcess; //调用NtQueryInformationProcess获取结构信息 ret := NtQueryInformationProcess(hProcess,0,@PBI,SizeOf(PBI),@r); //正常情况下ret是0，如果不是则认为错误 if ret = 0 then begin //获取PEB结构 ReadProcessMemory(hProcess,PBI.PebBaseAddress,PEBType,SizeOf(PEB),readByte); //获取PLD结构 ReadProcessMemory(hProcess,PEBType.LoaderData,PLD,SizeOf(PEB_LDR_DATA),readByte); //获取第一个PME ReadProcessMemory(hProcess,PLD.InLoadOrderModuleList.Flink,PME,SizeOf(LDR_MODULE),readByte); //循环 while True do begin //清零缓冲区 ZeroMemory(PEBDLLName,Size); //读取buff到内存中，获取当前结构的DLL名 if not ReadProcessMemory(hProcess,PME.BaseDllName.Buffer,PEBDLLName,PME.BaseDllName.Length,readByte) then Break; //对比DLL名称，不区分大小写 if LowerCase(AnsiString(PEBDLLName)) = LowerCase(AnsiString(DllName)) then begin //调试信息 OutputDebugStringW(PEBDLLName); //返回DLL的句柄 Result := dword(pme.BaseAddress); //退出循环 Break; end; //调试信息 OutputDebugStringW(PEBDLLName); //如果下一个结构为开始的结构，则认为链表已经枚举完了 if PME.InLoadOrderModuleList.Flink = PLD.InLoadOrderModuleList.Flink then Break; //读取下一个结构 if not ReadProcessMemory(hProcess,PME.InLoadOrderModuleList.Flink,PME,SizeOf(LDR_MODULE),readByte) then Break; end; end else begin //返回错误信息 OutputDebugStringW(&#x27;Error!NtQueryInformationProcess Error!&#x27;); end; finally //释放使用的内存 FreeMem(PEBDLLName,Size); FreeMem(PME,SizeOf(LDR_MODULE)); FreeMem(PLD,SizeOf(PEB_LDR_DATA)); FreeMem(PEBType,SizeOf(PEB)); end; end;end.","categories":[{"name":"源码","slug":"code","permalink":"https://goodhelp.gitee.io/categories/code/"}],"tags":[{"name":"delphi源码","slug":"delphi源码","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%BA%90%E7%A0%81/"}]},{"title":"delphi在ring3阻止文件删除(8圈桌面广告图标生成原理)","slug":"article/delphi在ring3阻止文件删除-8圈桌面广告图标生成原理","date":"2018-01-23T02:43:18.000Z","updated":"2021-09-16T23:41:35.829Z","comments":true,"path":"page/1693463645/","link":"","permalink":"https://goodhelp.gitee.io/page/1693463645/","excerpt":"8圈网管计费系统，最近在桌面生成图标，直接删除会提示服务和应用管理程序已经打开，无法删除，8圈计费系统先生成url快捷图标，然后打开这个快捷方式取得句柄，再使用DuplicateHandle复制句柄丢给系统进程services.exe，达到占用文件，删除8圈桌面图标就不行了!8圈桌面图标阻止删除的方法关键地方就是使用了DuplicateHandle这个API，看看下面的代码! 12345678910111213141516171819202122232425262728293031323334353637383940414243function EnabledDebugPrivilege(const bEnabled: Boolean): Boolean;//提权varhToken: THandle;tp: TOKEN_PRIVILEGES;a: DWORD;constSE_DEBUG_NAME = &#x27;SeDebugPrivilege&#x27;;beginResult := False;if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, hToken)) thenbegintp.PrivilegeCount := 1;LookupPrivilegeValue(nil, SE_DEBUG_NAME, tp.Privileges[0].Luid);if bEnabled thentp.Privileges[0].Attributes := SE_PRIVILEGE_ENABLEDelsetp.Privileges[0].Attributes := 0;a := 0;AdjustTokenPrivileges(hToken, False, tp, SizeOf(tp), nil, a);Result := GetLastError = ERROR_SUCCESS;CloseHandle(hToken);end;end; function DupFile(FileName:String;PID:Cardinal):Boolean;varhFile,hProcess,hTarget:THandle;beginResult := False;EnabledDebugPrivilege(True);hProcess := OpenProcess(PROCESS_DUP_HANDLE, False, PID);Tryif hProcess &lt;&gt; 0 thenbeginhFile := CreateFile(PChar(FileName), GENERIC_READ, 0, nil, Create_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);if hFile = INVALID_HANDLE_VALUE then Exit;Result := DuplicateHandle(GetCurrentProcess(), hFile, hProcess, @hTarget,0, False, DUPLICATE_SAME_ACCESS or DUPLICATE_CLOSE_SOURCE);end;FinallyCloseHandle(hProcess);End;end; 8圈在桌面生成图标就是利用上面的原理!实际改一下就是这样 123456789101112131415161718192021222324252627282930313233343536procedure TForm1.btn2Click(Sender: TObject); function GetPid(ExeFileName: string): THandle; //根据进程名返回进程PID const PROCESS_TERMINATE = $0001; var ContinueLoop: BOOL; FSnapshotHandle: THandle; FProcessEntry32: TProcessEntry32; begin Result := 0; FSnapshotHandle := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); FProcessEntry32.dwSize := SizeOf(FProcessEntry32); ContinueLoop := Process32First(FSnapshotHandle, FProcessEntry32); while Integer(ContinueLoop) &lt;&gt; 0 do begin if ((UpperCase(ExtractFileName(FProcessEntry32.szExeFile)) = UpperCase(ExeFileName)) or (UpperCase(FProcessEntry32.szExeFile) = UpperCase(ExeFileName))) then begin Result :=FProcessEntry32.th32ProcessID; Break; end; ContinueLoop := Process32Next(FSnapshotHandle, FProcessEntry32); end; CloseHandle(FSnapshotHandle); end;var fhand:THandle; hProcess,hFile:THandle;begin fhand:=FileOpen(PWideChar(edt1.Text),GENERIC_READ);//取得阻止删除的文件句柄 EnabledDebugPrivilege; hProcess:=OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetPid(&#x27;services.exe&#x27;)); if DuplicateHandle(GetCurrentProcess(), fhand,hProcess, @hFile, 0 ,FALSE, DUPLICATE_SAME_ACCESS) then ShowMessage(&#x27;文件占坑成功!&#x27;); CloseHandle(hProcess);end;","text":"8圈网管计费系统，最近在桌面生成图标，直接删除会提示服务和应用管理程序已经打开，无法删除，8圈计费系统先生成url快捷图标，然后打开这个快捷方式取得句柄，再使用DuplicateHandle复制句柄丢给系统进程services.exe，达到占用文件，删除8圈桌面图标就不行了!8圈桌面图标阻止删除的方法关键地方就是使用了DuplicateHandle这个API，看看下面的代码! 12345678910111213141516171819202122232425262728293031323334353637383940414243function EnabledDebugPrivilege(const bEnabled: Boolean): Boolean;//提权varhToken: THandle;tp: TOKEN_PRIVILEGES;a: DWORD;constSE_DEBUG_NAME = &#x27;SeDebugPrivilege&#x27;;beginResult := False;if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, hToken)) thenbegintp.PrivilegeCount := 1;LookupPrivilegeValue(nil, SE_DEBUG_NAME, tp.Privileges[0].Luid);if bEnabled thentp.Privileges[0].Attributes := SE_PRIVILEGE_ENABLEDelsetp.Privileges[0].Attributes := 0;a := 0;AdjustTokenPrivileges(hToken, False, tp, SizeOf(tp), nil, a);Result := GetLastError = ERROR_SUCCESS;CloseHandle(hToken);end;end; function DupFile(FileName:String;PID:Cardinal):Boolean;varhFile,hProcess,hTarget:THandle;beginResult := False;EnabledDebugPrivilege(True);hProcess := OpenProcess(PROCESS_DUP_HANDLE, False, PID);Tryif hProcess &lt;&gt; 0 thenbeginhFile := CreateFile(PChar(FileName), GENERIC_READ, 0, nil, Create_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);if hFile = INVALID_HANDLE_VALUE then Exit;Result := DuplicateHandle(GetCurrentProcess(), hFile, hProcess, @hTarget,0, False, DUPLICATE_SAME_ACCESS or DUPLICATE_CLOSE_SOURCE);end;FinallyCloseHandle(hProcess);End;end; 8圈在桌面生成图标就是利用上面的原理!实际改一下就是这样 123456789101112131415161718192021222324252627282930313233343536procedure TForm1.btn2Click(Sender: TObject); function GetPid(ExeFileName: string): THandle; //根据进程名返回进程PID const PROCESS_TERMINATE = $0001; var ContinueLoop: BOOL; FSnapshotHandle: THandle; FProcessEntry32: TProcessEntry32; begin Result := 0; FSnapshotHandle := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); FProcessEntry32.dwSize := SizeOf(FProcessEntry32); ContinueLoop := Process32First(FSnapshotHandle, FProcessEntry32); while Integer(ContinueLoop) &lt;&gt; 0 do begin if ((UpperCase(ExtractFileName(FProcessEntry32.szExeFile)) = UpperCase(ExeFileName)) or (UpperCase(FProcessEntry32.szExeFile) = UpperCase(ExeFileName))) then begin Result :=FProcessEntry32.th32ProcessID; Break; end; ContinueLoop := Process32Next(FSnapshotHandle, FProcessEntry32); end; CloseHandle(FSnapshotHandle); end;var fhand:THandle; hProcess,hFile:THandle;begin fhand:=FileOpen(PWideChar(edt1.Text),GENERIC_READ);//取得阻止删除的文件句柄 EnabledDebugPrivilege; hProcess:=OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetPid(&#x27;services.exe&#x27;)); if DuplicateHandle(GetCurrentProcess(), fhand,hProcess, @hFile, 0 ,FALSE, DUPLICATE_SAME_ACCESS) then ShowMessage(&#x27;文件占坑成功!&#x27;); CloseHandle(hProcess);end;","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"delphi技巧","slug":"delphi技巧","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%8A%80%E5%B7%A7/"},{"name":"去广告方法","slug":"去广告方法","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%BB%E5%B9%BF%E5%91%8A%E6%96%B9%E6%B3%95/"},{"name":"八圈","slug":"八圈","permalink":"https://goodhelp.gitee.io/tags/%E5%85%AB%E5%9C%88/"}]},{"title":"delphi如何在win7中远程注入代码","slug":"code/delphi如何在win7中远程注入代码","date":"2018-01-17T04:55:56.000Z","updated":"2021-09-16T23:32:48.371Z","comments":true,"path":"page/2721990259/","link":"","permalink":"https://goodhelp.gitee.io/page/2721990259/","excerpt":"一. delphi远程注入Dll文件 首先，您必须找到已经在内存中运行的应用程序（EXE）的PID。以下函数将通过名称获得PID1234567891011121314151617181920212223function PIDbyName(ProcessName: PWideChar): DWORD;var ProcessSnap: Int64; ProcessEntry32: TProcessEntry32;begin Result := 0; ProcessSnap := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if ProcessSnap &lt;&gt; INVALID_HANDLE_VALUE then begin ProcessEntry32.dwSize := SizeOf(TPROCESSENTRY32); if Process32First(ProcessSnap, ProcessEntry32) then repeat if lstrcmpi(ProcessEntry32.szExeFile, ProcessName) = 0 then begin Result := ProcessEntry32.th32ProcessID; CloseHandle(ProcessSnap); exit; end; until not Process32Next(ProcessSnap, ProcessEntry32); Result := 0; CloseHandle(ProcessSnap); end;end; 这是32/64位应用程序的DLL注入函数 Source是DLL，Target是EXE123456789101112131415161718192021222324252627282930function InjectDLL(Source, Target : PWideChar) : boolean;var dwThreadID: Cardinal; hProc, hThread: THandle; BytesToWrite, BytesWritten: SIZE_T; pRemoteBuffer, pLoadLibrary: Pointer;begin hProc := OpenProcess(PROCESS_CREATE_THREAD or PROCESS_QUERY_INFORMATION or PROCESS_VM_OPERATION or PROCESS_VM_WRITE or PROCESS_VM_READ, False, PIDbyName(Target)); if hProc = 0 then exit(false); try BytesToWrite := SizeOf(WideChar) * (Length(Source) + 1); pRemoteBuffer := VirtualAllocEx(hProc, nil, BytesToWrite, MEM_COMMIT,PAGE_READWRITE); if pRemoteBuffer = nil then exit(false); try if not WriteProcessMemory(hProc, pRemoteBuffer, Source, BytesToWrite, BytesWritten) then exit(false); pLoadLibrary := GetProcAddress(GetModuleHandle(&#x27;kernel32.dll&#x27;), &#x27;LoadLibraryW&#x27;); hThread := CreateRemoteThread(hProc, nil, 0, pLoadLibrary, pRemoteBuffer, 0, dwThreadID); try WaitForSingleObject(hThread, INFINITE); finally Result := true; CloseHandle(hThread); end; finally VirtualFreeEx(hProc, pRemoteBuffer, 0, MEM_RELEASE); end; finally CloseHandle(hProc); end;end; 简单的DLL12345678910111213141516171819202122232425library testDLL; uses System.SysUtils, System.Classes, Winapi.Windows; &#123;$R *.res&#125; procedure DLLEntryPoint(dwReason: DWord);var DLLHandle : DWORD;begin case dwReason of DLL_PROCESS_ATTACH: MessageBox(DLLHandle, &#x27;Process Attach&#x27;, &#x27;Info&#x27;, mb_Ok); DLL_PROCESS_DETACH: MessageBox(DLLHandle, &#x27;Process Detach&#x27;, &#x27;Info&#x27;, mb_Ok); end;end; begin DllProc := @DLLEntryPoint; DllEntryPoint(DLL_PROCESS_ATTACH);end. 用法：InjectDLL(‘testDLL.dll’, ‘yourapplication.exe’)二. delphi远程直接注入代码执行(非DLL插入是代码注入)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//-------------------------注入代码的函数---------------------------- &#123;参数说明: InHWND:被注入的窗口句柄 Func:注入的函数的指针 Param:参数的指针 ParamSize:参数的大小 &#125; procedure InjectFunc(InHWND: HWND; Func: Pointer; Param: Pointer; ParamSize: DWORD); var hProcess_N: THandle; ThreadAdd, ParamAdd: Pointer; hThread: THandle; ThreadID: DWORD; lpNumberOfBytes:DWORD; begin GetWindowThreadProcessId(InHWND, @ThreadID); //获得窗口ID hProcess_N := OpenProcess(PROCESS_ALL_ACCESS, False, ThreadID);//打开被注入的进程 ThreadAdd := VirtualAllocEx(hProcess_N, nil, 4096, MEM_COMMIT, PAGE_READWRITE); //申请写入代码空间 WriteProcessMemory(hProcess_N, ThreadAdd, Func, 4096, lpNumberOfBytes); //写入函数地址 ParamAdd := VirtualAllocEx(hProcess_N, nil, ParamSize, MEM_COMMIT, PAGE_READWRITE); //申请写入代码参数空间 WriteProcessMemory(hProcess_N, ParamAdd, Param, ParamSize, lpNumberOfBytes); //写入参数地址 hThread := CreateRemoteThread(hProcess_N, nil, 0, ThreadAdd, ParamAdd, 0, lpNumberOfBytes); //创建远程线程 ResumeThread(hThread); //直接运行线程 CloseHandle(hThread); //关闭线程 VirtualFreeEx(hProcess_N, ThreadAdd, 4096, MEM_RELEASE); VirtualFreeEx(hProcess_N, ParamAdd, ParamSize, MEM_RELEASE); //释放申请的地址 CloseHandle(hProcess_N); //关闭打开的句柄 end; //-----------------------------定义一个参数类型----------------------- type TPickCallParam = packed record ax, ay: single; end; PPickCallParam = ^TPickCallParam; //指向结构的指针(C中叫这种方式的数据应该叫结构体吧) procedure runCall(p:PPickCallParam);stdcall; // 走路call var addres,addres1,addres2:pointer; x,y:single; begin addres:=pointer($0045ec00); addres1:=pointer($00462620); addres2:=pointer($0045f000); x:=p^.ax; //目的地X坐标 y:=p^.ay; //目的地Y坐标 asm pushad mov eax, dword ptr [$8f207c] mov eax, dword ptr [eax+$1C] mov esi, dword ptr [eax+$20] mov ecx, dword ptr [esi+$ba0] push 1 call addres mov edi, eax lea eax, dword ptr [esp+$18] push eax push 0 mov ecx, edi call addres1 push 0 push 1 push edi mov ecx, dword ptr [esi+$ba0] push 1 call addres2 mov eax, dword ptr [$8f207c] mov eax, dword ptr [eax+$1C] mov eax, dword ptr [eax+$20] mov eax, dword ptr [eax+$ba0] mov eax, dword ptr [eax+$30] mov ecx, dword ptr [eax+4] mov eax, x mov [ecx+$20], eax mov eax, y mov [ecx+$28], eax popad end; END; procedure TForm1.Button1Click(Sender: TObject);//在控件中做个按钮 测试 var CallParam:TPickCallParam; begin; getmem(pname,33); myhwnd := FindWindow(nil,&#x27;Element Client&#x27;);&#123;查找窗口句柄&#125; GetWindowThreadProcessId(myhwnd, aproc); &#123;得到窗口ID&#125; phnd := OpenProcess(PROCESS_VM_READ , False, aproc);&#123;以完全访问权限打开进程句柄&#125; if (phnd&lt;&gt;0 ) then begin CallParam.ax:= 1860.0; //给注入代码函数赋值 CallParam.ay:=120.0; //给注入代码函数赋值 InjectFunc(myhWnd,@runCall,@CallParam,SizeOf(CallParam)); //运行注入代码函数 sleep(100); CloseHandle(PHND) //关闭进程 end; end; 三. 远程代码或DLL注入x86/x64/Win2k/win7~Win8.1 64位全可用(最重要的隆重登场)上面的一和二远程注入，在win7 64位系统下，不能成功注入service服务程序，下面代码实现在64位系统,可以注入系统进程，服务进程等!看关键函数NtCreateThreadEx，而在win7 64位下的注入问题http://forum.sources.ru/index.php?showtopic=313636有相应讨论123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116program Inject; &#123;$APPTYPE CONSOLE&#125; &#123;$IF CompilerVersion &gt;= 21.0&#125;&#123;$WEAKLINKRTTI ON&#125;&#123;$RTTI EXPLICIT METHODS([]) PROPERTIES([]) FIELDS([])&#125;&#123;$IFEND&#125; uses Winapi.Windows; Type NtCreateThreadExProc = Function(Var hThread:THandle; Access:DWORD; Attributes:Pointer; hProcess:THandle; pStart:Pointer; pParameter:Pointer; Suspended:BOOL; StackSize, u1, u2:DWORD; Unknown:Pointer):DWORD; stdcall; Function CheckOs():Boolean;Var lpVersionInformation :TOSVersionInfoW;begin Result := False; if GetVersionExW(lpVersionInformation) then begin if lpVersionInformation.dwPlatformId = VER_PLATFORM_WIN32_NT Then begin if (lpVersionInformation.dwMajorVersion &lt; 6) then begin Result := True; end; end; end;end; Function EnableDebugPrivilege():Boolean;Var hToKen :THandle; TokenPri :TTokenPrivileges;begin Result := False; if(OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES, hToKen)) Then begin TokenPri.PrivilegeCount := 1; If LookupPrivilegeValueW(Nil, &#x27;SeDebugPrivilege&#x27;, TokenPri.Privileges[0].Luid) Then begin TokenPri.Privileges[0].Attributes := SE_PRIVILEGE_ENABLED; Result := AdjustTokenPrivileges(hToken, False, TokenPri, SizeOf(TTokenPrivileges), Nil, PDWORD(Nil)^); end Else Writeln(&#x27;LookupPrivilege Error&#x27;); CloseHandle(hToKen); end;end; Function RemoteThread(hProcess:THandle; pThreadProc:Pointer; pRemote:Pointer):THandle;Label NtCreate, Create;Var pFunc :Pointer; hThread :THandle;begin hThread := 0; if Not CheckOs() then //根据系统版本来选择使用的API begin NtCreate: pFunc := GetProcAddress(LoadLibraryW(&#x27;ntdll.dll&#x27;), &#x27;NtCreateThreadEx&#x27;); if pFunc = Nil then Goto Create; NtCreateThreadExProc(pFunc)(hThread, $1FFFFF, Nil, hProcess, pThreadProc, pRemote, False, 0, 0, 0, Nil); if hThread = 0 then Goto Create; end Else begin Create: hThread := CreateRemoteThread(hProcess, Nil, 0, pThreadProc, pRemote, 0, PDWORD(Nil)^); end; Writeln(&#x27;RemoteThread Ok!&#x27;); Result := hThread;end; Function InjectDll2Pid(szPath:PWideChar; uPID:DWORD):Boolean;Var hProcess :THandle; hThread :THandle; szRemote :PWideChar; uSize :SIZE_T; uWrite :SIZE_T; pStartAddr:Pointer;begin Result := False; if EnableDebugPrivilege then begin //先提升下进程的权限 hProcess := OpenProcess(PROCESS_ALL_ACCESS, false, uPID); if hProcess &gt; 0 then begin uSize := lstrlenW(szPath) * 2 + 4; szRemote := VirtualAllocEx(hProcess, Nil, uSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE); if WriteProcessMemory(hProcess, szRemote, szPath, uSize, uWrite) And (uWrite = uSize) then begin pStartAddr := GetProcAddress(LoadLibrary(&#x27;Kernel32.dll&#x27;), &#x27;LoadLibraryW&#x27;); hThread := RemoteThread(hProcess, pStartAddr, szRemote); Result := hThread &lt;&gt; 0; CloseHandle(hThread); end Else begin Writeln(&#x27;WriteMemory Error&#x27;); end; end; end; end; Function StrToInt(S: String): Integer;Var E: Integer;Begin Val(S, Result, E);End; begin InjectDll2Pid(PWideChar(ParamStr(2)), StrToInt(ParamStr(1)));end. NtCreateThreadEx注入注意事项：64位的进程，只能使用64位的dll注入,注入程序本身也必须编译为64位程序，32位的进程，只能使用32位的dll注入，注入程序本身编译为32位程序，不然会注入不成功!比如你把程序编译为32程序，想在win7 64位下往services.exe注入，是不会成功的，services.exe在win7 64位下是64位程序!","text":"一. delphi远程注入Dll文件 首先，您必须找到已经在内存中运行的应用程序（EXE）的PID。以下函数将通过名称获得PID1234567891011121314151617181920212223function PIDbyName(ProcessName: PWideChar): DWORD;var ProcessSnap: Int64; ProcessEntry32: TProcessEntry32;begin Result := 0; ProcessSnap := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if ProcessSnap &lt;&gt; INVALID_HANDLE_VALUE then begin ProcessEntry32.dwSize := SizeOf(TPROCESSENTRY32); if Process32First(ProcessSnap, ProcessEntry32) then repeat if lstrcmpi(ProcessEntry32.szExeFile, ProcessName) = 0 then begin Result := ProcessEntry32.th32ProcessID; CloseHandle(ProcessSnap); exit; end; until not Process32Next(ProcessSnap, ProcessEntry32); Result := 0; CloseHandle(ProcessSnap); end;end; 这是32/64位应用程序的DLL注入函数 Source是DLL，Target是EXE123456789101112131415161718192021222324252627282930function InjectDLL(Source, Target : PWideChar) : boolean;var dwThreadID: Cardinal; hProc, hThread: THandle; BytesToWrite, BytesWritten: SIZE_T; pRemoteBuffer, pLoadLibrary: Pointer;begin hProc := OpenProcess(PROCESS_CREATE_THREAD or PROCESS_QUERY_INFORMATION or PROCESS_VM_OPERATION or PROCESS_VM_WRITE or PROCESS_VM_READ, False, PIDbyName(Target)); if hProc = 0 then exit(false); try BytesToWrite := SizeOf(WideChar) * (Length(Source) + 1); pRemoteBuffer := VirtualAllocEx(hProc, nil, BytesToWrite, MEM_COMMIT,PAGE_READWRITE); if pRemoteBuffer = nil then exit(false); try if not WriteProcessMemory(hProc, pRemoteBuffer, Source, BytesToWrite, BytesWritten) then exit(false); pLoadLibrary := GetProcAddress(GetModuleHandle(&#x27;kernel32.dll&#x27;), &#x27;LoadLibraryW&#x27;); hThread := CreateRemoteThread(hProc, nil, 0, pLoadLibrary, pRemoteBuffer, 0, dwThreadID); try WaitForSingleObject(hThread, INFINITE); finally Result := true; CloseHandle(hThread); end; finally VirtualFreeEx(hProc, pRemoteBuffer, 0, MEM_RELEASE); end; finally CloseHandle(hProc); end;end; 简单的DLL12345678910111213141516171819202122232425library testDLL; uses System.SysUtils, System.Classes, Winapi.Windows; &#123;$R *.res&#125; procedure DLLEntryPoint(dwReason: DWord);var DLLHandle : DWORD;begin case dwReason of DLL_PROCESS_ATTACH: MessageBox(DLLHandle, &#x27;Process Attach&#x27;, &#x27;Info&#x27;, mb_Ok); DLL_PROCESS_DETACH: MessageBox(DLLHandle, &#x27;Process Detach&#x27;, &#x27;Info&#x27;, mb_Ok); end;end; begin DllProc := @DLLEntryPoint; DllEntryPoint(DLL_PROCESS_ATTACH);end. 用法：InjectDLL(‘testDLL.dll’, ‘yourapplication.exe’)二. delphi远程直接注入代码执行(非DLL插入是代码注入)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//-------------------------注入代码的函数---------------------------- &#123;参数说明: InHWND:被注入的窗口句柄 Func:注入的函数的指针 Param:参数的指针 ParamSize:参数的大小 &#125; procedure InjectFunc(InHWND: HWND; Func: Pointer; Param: Pointer; ParamSize: DWORD); var hProcess_N: THandle; ThreadAdd, ParamAdd: Pointer; hThread: THandle; ThreadID: DWORD; lpNumberOfBytes:DWORD; begin GetWindowThreadProcessId(InHWND, @ThreadID); //获得窗口ID hProcess_N := OpenProcess(PROCESS_ALL_ACCESS, False, ThreadID);//打开被注入的进程 ThreadAdd := VirtualAllocEx(hProcess_N, nil, 4096, MEM_COMMIT, PAGE_READWRITE); //申请写入代码空间 WriteProcessMemory(hProcess_N, ThreadAdd, Func, 4096, lpNumberOfBytes); //写入函数地址 ParamAdd := VirtualAllocEx(hProcess_N, nil, ParamSize, MEM_COMMIT, PAGE_READWRITE); //申请写入代码参数空间 WriteProcessMemory(hProcess_N, ParamAdd, Param, ParamSize, lpNumberOfBytes); //写入参数地址 hThread := CreateRemoteThread(hProcess_N, nil, 0, ThreadAdd, ParamAdd, 0, lpNumberOfBytes); //创建远程线程 ResumeThread(hThread); //直接运行线程 CloseHandle(hThread); //关闭线程 VirtualFreeEx(hProcess_N, ThreadAdd, 4096, MEM_RELEASE); VirtualFreeEx(hProcess_N, ParamAdd, ParamSize, MEM_RELEASE); //释放申请的地址 CloseHandle(hProcess_N); //关闭打开的句柄 end; //-----------------------------定义一个参数类型----------------------- type TPickCallParam = packed record ax, ay: single; end; PPickCallParam = ^TPickCallParam; //指向结构的指针(C中叫这种方式的数据应该叫结构体吧) procedure runCall(p:PPickCallParam);stdcall; // 走路call var addres,addres1,addres2:pointer; x,y:single; begin addres:=pointer($0045ec00); addres1:=pointer($00462620); addres2:=pointer($0045f000); x:=p^.ax; //目的地X坐标 y:=p^.ay; //目的地Y坐标 asm pushad mov eax, dword ptr [$8f207c] mov eax, dword ptr [eax+$1C] mov esi, dword ptr [eax+$20] mov ecx, dword ptr [esi+$ba0] push 1 call addres mov edi, eax lea eax, dword ptr [esp+$18] push eax push 0 mov ecx, edi call addres1 push 0 push 1 push edi mov ecx, dword ptr [esi+$ba0] push 1 call addres2 mov eax, dword ptr [$8f207c] mov eax, dword ptr [eax+$1C] mov eax, dword ptr [eax+$20] mov eax, dword ptr [eax+$ba0] mov eax, dword ptr [eax+$30] mov ecx, dword ptr [eax+4] mov eax, x mov [ecx+$20], eax mov eax, y mov [ecx+$28], eax popad end; END; procedure TForm1.Button1Click(Sender: TObject);//在控件中做个按钮 测试 var CallParam:TPickCallParam; begin; getmem(pname,33); myhwnd := FindWindow(nil,&#x27;Element Client&#x27;);&#123;查找窗口句柄&#125; GetWindowThreadProcessId(myhwnd, aproc); &#123;得到窗口ID&#125; phnd := OpenProcess(PROCESS_VM_READ , False, aproc);&#123;以完全访问权限打开进程句柄&#125; if (phnd&lt;&gt;0 ) then begin CallParam.ax:= 1860.0; //给注入代码函数赋值 CallParam.ay:=120.0; //给注入代码函数赋值 InjectFunc(myhWnd,@runCall,@CallParam,SizeOf(CallParam)); //运行注入代码函数 sleep(100); CloseHandle(PHND) //关闭进程 end; end; 三. 远程代码或DLL注入x86/x64/Win2k/win7~Win8.1 64位全可用(最重要的隆重登场)上面的一和二远程注入，在win7 64位系统下，不能成功注入service服务程序，下面代码实现在64位系统,可以注入系统进程，服务进程等!看关键函数NtCreateThreadEx，而在win7 64位下的注入问题http://forum.sources.ru/index.php?showtopic=313636有相应讨论123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116program Inject; &#123;$APPTYPE CONSOLE&#125; &#123;$IF CompilerVersion &gt;= 21.0&#125;&#123;$WEAKLINKRTTI ON&#125;&#123;$RTTI EXPLICIT METHODS([]) PROPERTIES([]) FIELDS([])&#125;&#123;$IFEND&#125; uses Winapi.Windows; Type NtCreateThreadExProc = Function(Var hThread:THandle; Access:DWORD; Attributes:Pointer; hProcess:THandle; pStart:Pointer; pParameter:Pointer; Suspended:BOOL; StackSize, u1, u2:DWORD; Unknown:Pointer):DWORD; stdcall; Function CheckOs():Boolean;Var lpVersionInformation :TOSVersionInfoW;begin Result := False; if GetVersionExW(lpVersionInformation) then begin if lpVersionInformation.dwPlatformId = VER_PLATFORM_WIN32_NT Then begin if (lpVersionInformation.dwMajorVersion &lt; 6) then begin Result := True; end; end; end;end; Function EnableDebugPrivilege():Boolean;Var hToKen :THandle; TokenPri :TTokenPrivileges;begin Result := False; if(OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES, hToKen)) Then begin TokenPri.PrivilegeCount := 1; If LookupPrivilegeValueW(Nil, &#x27;SeDebugPrivilege&#x27;, TokenPri.Privileges[0].Luid) Then begin TokenPri.Privileges[0].Attributes := SE_PRIVILEGE_ENABLED; Result := AdjustTokenPrivileges(hToken, False, TokenPri, SizeOf(TTokenPrivileges), Nil, PDWORD(Nil)^); end Else Writeln(&#x27;LookupPrivilege Error&#x27;); CloseHandle(hToKen); end;end; Function RemoteThread(hProcess:THandle; pThreadProc:Pointer; pRemote:Pointer):THandle;Label NtCreate, Create;Var pFunc :Pointer; hThread :THandle;begin hThread := 0; if Not CheckOs() then //根据系统版本来选择使用的API begin NtCreate: pFunc := GetProcAddress(LoadLibraryW(&#x27;ntdll.dll&#x27;), &#x27;NtCreateThreadEx&#x27;); if pFunc = Nil then Goto Create; NtCreateThreadExProc(pFunc)(hThread, $1FFFFF, Nil, hProcess, pThreadProc, pRemote, False, 0, 0, 0, Nil); if hThread = 0 then Goto Create; end Else begin Create: hThread := CreateRemoteThread(hProcess, Nil, 0, pThreadProc, pRemote, 0, PDWORD(Nil)^); end; Writeln(&#x27;RemoteThread Ok!&#x27;); Result := hThread;end; Function InjectDll2Pid(szPath:PWideChar; uPID:DWORD):Boolean;Var hProcess :THandle; hThread :THandle; szRemote :PWideChar; uSize :SIZE_T; uWrite :SIZE_T; pStartAddr:Pointer;begin Result := False; if EnableDebugPrivilege then begin //先提升下进程的权限 hProcess := OpenProcess(PROCESS_ALL_ACCESS, false, uPID); if hProcess &gt; 0 then begin uSize := lstrlenW(szPath) * 2 + 4; szRemote := VirtualAllocEx(hProcess, Nil, uSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE); if WriteProcessMemory(hProcess, szRemote, szPath, uSize, uWrite) And (uWrite = uSize) then begin pStartAddr := GetProcAddress(LoadLibrary(&#x27;Kernel32.dll&#x27;), &#x27;LoadLibraryW&#x27;); hThread := RemoteThread(hProcess, pStartAddr, szRemote); Result := hThread &lt;&gt; 0; CloseHandle(hThread); end Else begin Writeln(&#x27;WriteMemory Error&#x27;); end; end; end; end; Function StrToInt(S: String): Integer;Var E: Integer;Begin Val(S, Result, E);End; begin InjectDll2Pid(PWideChar(ParamStr(2)), StrToInt(ParamStr(1)));end. NtCreateThreadEx注入注意事项：64位的进程，只能使用64位的dll注入,注入程序本身也必须编译为64位程序，32位的进程，只能使用32位的dll注入，注入程序本身编译为32位程序，不然会注入不成功!比如你把程序编译为32程序，想在win7 64位下往services.exe注入，是不会成功的，services.exe在win7 64位下是64位程序!","categories":[{"name":"源码","slug":"code","permalink":"https://goodhelp.gitee.io/categories/code/"}],"tags":[{"name":"delphi源码","slug":"delphi源码","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%BA%90%E7%A0%81/"}]},{"title":"音悦台MTV视频MP4真实地址PHP解析源码","slug":"code/音悦台MTV视频MP4真实地址PHP解析源码","date":"2018-01-15T04:54:06.000Z","updated":"2021-09-16T23:54:52.629Z","comments":true,"path":"page/1586233474/","link":"","permalink":"https://goodhelp.gitee.io/page/1586233474/","excerpt":"音悦Tai，主要提供MTV在线播放功能,官网http://www.yinyuetai.com/ ，有时我们需要下载音悦台的MTV的时候，按照官方的下载很多限制，这儿使用PHP直接解析出音悦台的MTV源地址，可以直接下载！音悦台MTV视频真实地址PHP解析源码如下: 12345678910111213141516171819202122232425262728@header(&#x27;Content-type: text/html;charset=UTF-8&#x27;);$url=isset($_GET[&#x27;url&#x27;])?trim($_GET[&#x27;url&#x27;]):&#x27;&#x27;;//http://v.yinyuetai.com/video/2185713$time=$_SERVER[&#x27;REQUEST_TIME&#x27;];$content = file_get_contents($url);//获取标题preg_match(&#x27;/property=&quot;og:title&quot;[\\s]+content=&quot;([^&quot;]*)&quot;.*?&gt;/i&#x27;,$content,$title);//获取封面preg_match(&#x27;/property=&quot;og:image&quot; content=&quot;([^&quot;]*)&quot;.*?&gt;/&#x27;,$content,$images);//获取MV的IDpreg_match(&#x27;/[\\d]+/&#x27;,$url,$song_id);$title=$title[1];$images=$images[1];$song_id=$song_id[0];//解析json$songurl = &quot;http://www.yinyuetai.com/api/info/get-video-urls?callback=callback&amp;videoId=&quot;.$song_id.&quot;&amp;_=&quot;.$time;$data = file_get_contents($songurl);if (strpos($data, &quot;callback&quot;) !== false)&#123; $lpos = strpos($data, &quot;(&quot;); $rpos = strrpos($data, &quot;)&quot;); $data = substr($data, $lpos + 1, $rpos - $lpos -1);&#125;$json= json_decode($data,true);echo $title.&quot;&lt;br/&gt;&quot;;echo &quot;流畅地址：&quot;.$json[&#x27;hcVideoUrl&#x27;].&quot;&lt;br/&gt;&quot;;echo &quot;高清地址：&quot;.$json[&#x27;hdVideoUrl&#x27;].&quot;&lt;br/&gt;&quot;;echo &quot;超清地址：&quot;.$json[&#x27;heVideoUrl&#x27;].&quot;&lt;br/&gt;&quot;;echo &quot;&lt;img src=\\&quot;&quot;.$images.&quot;\\&quot;/&gt;&quot;; 看看解析效果","text":"音悦Tai，主要提供MTV在线播放功能,官网http://www.yinyuetai.com/ ，有时我们需要下载音悦台的MTV的时候，按照官方的下载很多限制，这儿使用PHP直接解析出音悦台的MTV源地址，可以直接下载！音悦台MTV视频真实地址PHP解析源码如下: 12345678910111213141516171819202122232425262728@header(&#x27;Content-type: text/html;charset=UTF-8&#x27;);$url=isset($_GET[&#x27;url&#x27;])?trim($_GET[&#x27;url&#x27;]):&#x27;&#x27;;//http://v.yinyuetai.com/video/2185713$time=$_SERVER[&#x27;REQUEST_TIME&#x27;];$content = file_get_contents($url);//获取标题preg_match(&#x27;/property=&quot;og:title&quot;[\\s]+content=&quot;([^&quot;]*)&quot;.*?&gt;/i&#x27;,$content,$title);//获取封面preg_match(&#x27;/property=&quot;og:image&quot; content=&quot;([^&quot;]*)&quot;.*?&gt;/&#x27;,$content,$images);//获取MV的IDpreg_match(&#x27;/[\\d]+/&#x27;,$url,$song_id);$title=$title[1];$images=$images[1];$song_id=$song_id[0];//解析json$songurl = &quot;http://www.yinyuetai.com/api/info/get-video-urls?callback=callback&amp;videoId=&quot;.$song_id.&quot;&amp;_=&quot;.$time;$data = file_get_contents($songurl);if (strpos($data, &quot;callback&quot;) !== false)&#123; $lpos = strpos($data, &quot;(&quot;); $rpos = strrpos($data, &quot;)&quot;); $data = substr($data, $lpos + 1, $rpos - $lpos -1);&#125;$json= json_decode($data,true);echo $title.&quot;&lt;br/&gt;&quot;;echo &quot;流畅地址：&quot;.$json[&#x27;hcVideoUrl&#x27;].&quot;&lt;br/&gt;&quot;;echo &quot;高清地址：&quot;.$json[&#x27;hdVideoUrl&#x27;].&quot;&lt;br/&gt;&quot;;echo &quot;超清地址：&quot;.$json[&#x27;heVideoUrl&#x27;].&quot;&lt;br/&gt;&quot;;echo &quot;&lt;img src=\\&quot;&quot;.$images.&quot;\\&quot;/&gt;&quot;; 看看解析效果","categories":[{"name":"源码","slug":"code","permalink":"https://goodhelp.gitee.io/categories/code/"}],"tags":[{"name":"php源码","slug":"php源码","permalink":"https://goodhelp.gitee.io/tags/php%E6%BA%90%E7%A0%81/"},{"name":"破解视频","slug":"破解视频","permalink":"https://goodhelp.gitee.io/tags/%E7%A0%B4%E8%A7%A3%E8%A7%86%E9%A2%91/"}]},{"title":"Unigui如何打印？Grid++Report锐浪报表解决方法","slug":"code/Unigui如何打印？Grid-Report锐浪报表解决方法","date":"2018-01-13T04:51:46.000Z","updated":"2021-09-16T23:56:19.228Z","comments":true,"path":"page/2074828779/","link":"","permalink":"https://goodhelp.gitee.io/page/2074828779/","excerpt":"uniGUI is a Web Application Framework for Delphi，unigui使delphi使用extjs快速的开发web程序,unigui符合delphi开发者的习惯，开发web就象开发桌面程序一样。但unigui中打印没有好的办法，因为是web，所以要么是直接打印html代码，要么是生成pdf，然后打印，这儿我们介绍的是unigui中使用Grid++Report锐浪报表打印方法，使用Grid++Report锐浪报表需要事先安装Grid++Report锐浪报表插件，如果你不喜欢喜欢插件，就只有使用生成pdf文件再打印了，可以不必看下面的内容! 先在ServerModule模块的Customfiles中加入grinstall/CreateControl.js grinstall/GRInstall.js 这两个Grid++Report锐浪报表的JS，如果浏览器没有安装Grid++Report锐浪报表插件会提示安装! 引用UntGridppReportCommon.pas单元，该单元就是处理Grid++Report锐浪报表所需要的数据格式的! 在主窗口中加入TUniHTMLFrame控件!用来显示最终的html数据!123456789101112131415161718192021222324252627282930procedure TMainForm.unbtbtn1Click(Sender: TObject);begin //预览报表 SetReportPrintViewerHTML(UniHTMLFrame1, &#x27;files/1a.grf&#x27;, &#x27;files/ff.txt&#x27;);end; procedure TMainForm.UniBitBtn1Click(Sender: TObject);begin //创建报表 CreateReport(UniHTMLFrame1, &#x27;PlunID&#x27;, &#x27;&#x27;); UniSession.JSCode(&#x27;PlunID.LoadFromURL(&quot;files/1a.grf&quot;);&#x27; + &#x27;PlunID.LoadDataFromURL(&quot;files/ff.txt&quot;);&#x27; + &#x27;PlunID.PrintPreview(true);&#x27;);end; procedure TMainForm.UniBitBtn2Click(Sender: TObject);begin //查询报表 SetReportDisplayViewerHTML(UniHTMLFrame1, &#x27;files/1a.grf&#x27;, &#x27;files/ff.txt&#x27;);end; procedure TMainForm.UniBitBtn3Click(Sender: TObject);begin //设计报表 SetReportDesignHTML(UniHTMLFrame1, &#x27;files/1a.grf&#x27;, &#x27;files/ff.txt&#x27;, self);end; procedure TMainForm.UniBitBtn4Click(Sender: TObject);begin//打印报表 UniSession.JSCode(&#x27;ReportViewer.Print(true);&#x27;); Exit; UniHTMLFrame1.HTML.Text := &#x27; &#x27;;end; 虽然安装插件不是太理想，但安装插件后就可以实现和桌面打印一样的功能，为什么不安装呢？为什么使用Grid++Report锐浪报表呢？因为Grid++Report锐浪报表可以免费使用，付费就是去掉打印右下角的标志，免费使用有一个标志，不过不影响使用!最重要的是锐浪报表支持Web的打印，官网有详细教程，Grid++Report锐浪报表官网 http://www.rubylong.cn/ delphi源码下载地址：链接: https://pan.baidu.com/s/1kVQFxHeNP_502ovWmC3myg 提取码: 2hzk 复制这段内容后打开百度网盘手机App，操作更方便哦","text":"uniGUI is a Web Application Framework for Delphi，unigui使delphi使用extjs快速的开发web程序,unigui符合delphi开发者的习惯，开发web就象开发桌面程序一样。但unigui中打印没有好的办法，因为是web，所以要么是直接打印html代码，要么是生成pdf，然后打印，这儿我们介绍的是unigui中使用Grid++Report锐浪报表打印方法，使用Grid++Report锐浪报表需要事先安装Grid++Report锐浪报表插件，如果你不喜欢喜欢插件，就只有使用生成pdf文件再打印了，可以不必看下面的内容! 先在ServerModule模块的Customfiles中加入grinstall/CreateControl.js grinstall/GRInstall.js 这两个Grid++Report锐浪报表的JS，如果浏览器没有安装Grid++Report锐浪报表插件会提示安装! 引用UntGridppReportCommon.pas单元，该单元就是处理Grid++Report锐浪报表所需要的数据格式的! 在主窗口中加入TUniHTMLFrame控件!用来显示最终的html数据!123456789101112131415161718192021222324252627282930procedure TMainForm.unbtbtn1Click(Sender: TObject);begin //预览报表 SetReportPrintViewerHTML(UniHTMLFrame1, &#x27;files/1a.grf&#x27;, &#x27;files/ff.txt&#x27;);end; procedure TMainForm.UniBitBtn1Click(Sender: TObject);begin //创建报表 CreateReport(UniHTMLFrame1, &#x27;PlunID&#x27;, &#x27;&#x27;); UniSession.JSCode(&#x27;PlunID.LoadFromURL(&quot;files/1a.grf&quot;);&#x27; + &#x27;PlunID.LoadDataFromURL(&quot;files/ff.txt&quot;);&#x27; + &#x27;PlunID.PrintPreview(true);&#x27;);end; procedure TMainForm.UniBitBtn2Click(Sender: TObject);begin //查询报表 SetReportDisplayViewerHTML(UniHTMLFrame1, &#x27;files/1a.grf&#x27;, &#x27;files/ff.txt&#x27;);end; procedure TMainForm.UniBitBtn3Click(Sender: TObject);begin //设计报表 SetReportDesignHTML(UniHTMLFrame1, &#x27;files/1a.grf&#x27;, &#x27;files/ff.txt&#x27;, self);end; procedure TMainForm.UniBitBtn4Click(Sender: TObject);begin//打印报表 UniSession.JSCode(&#x27;ReportViewer.Print(true);&#x27;); Exit; UniHTMLFrame1.HTML.Text := &#x27; &#x27;;end; 虽然安装插件不是太理想，但安装插件后就可以实现和桌面打印一样的功能，为什么不安装呢？为什么使用Grid++Report锐浪报表呢？因为Grid++Report锐浪报表可以免费使用，付费就是去掉打印右下角的标志，免费使用有一个标志，不过不影响使用!最重要的是锐浪报表支持Web的打印，官网有详细教程，Grid++Report锐浪报表官网 http://www.rubylong.cn/ delphi源码下载地址：链接: https://pan.baidu.com/s/1kVQFxHeNP_502ovWmC3myg 提取码: 2hzk 复制这段内容后打开百度网盘手机App，操作更方便哦","categories":[{"name":"源码","slug":"code","permalink":"https://goodhelp.gitee.io/categories/code/"}],"tags":[{"name":"delphi源码","slug":"delphi源码","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%BA%90%E7%A0%81/"},{"name":"unigui使用方法","slug":"unigui使用方法","permalink":"https://goodhelp.gitee.io/tags/unigui%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"}]},{"title":"delphi读取MBR数据源码","slug":"code/delphi读取MBR数据源码","date":"2018-01-09T04:49:55.000Z","updated":"2021-09-16T23:33:03.043Z","comments":true,"path":"page/1620682435/","link":"","permalink":"https://goodhelp.gitee.io/page/1620682435/","excerpt":"MBR主引导记录（Main Boot Record）是位于磁盘最前边的一段引导（Loader）代码。它负责磁盘操作系统(DOS)对磁盘进行读写时分区合法性的判别、分区引导信息的定位，它由磁盘操作系统(DOS)在对硬盘进行初始化时产生的。病毒容易修改MBR，中MBR病毒后即使重装系统，只要不清除MBR一样会感染病毒!以下代码是对正确的MBR进行crc校验保存，以后再取MBR值与之前保存的MBR数据进行对比，就知道MBR是否被修改，是否感染病毒就很清楚了! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115program Project1; uses Windows, Messages, SysUtils, Variants, Classes, Controls, Dialogs, StdCtrls, FileCtrl,Crc32,IniFiles,ShlObj, ComObj, ActiveX; &#123;$R *.res&#125;function GetMbr(num,n:integer):string;var i:integer; s,str:string; HD:THandle; p:PChar; begin str:=&#x27;&#x27;; s:=&#x27;\\\\.\\PHYSICALDRIVE&#x27;+inttostr(num); HD:=CreateFile(PChar(s),GENERIC_ALL,FILE_SHARE_READ or FILE_SHARE_WRITE,nil,OPEN_EXISTING,0,0); //得到句柄 if(HD&lt;&gt;INVALID_HANDLE_VALUE) then begin p:=allocmem(512); FileSeek(HD,0,0); //定位到扇区 if FileRead(HD,p[0],512)&lt;&gt;512 then ShowMessage(&#x27; 读取出错 ！ &#x27;); for i:=0 to n-1 do begin str:=str+IntToHex(Byte(p[i]),2)+&#x27; &#x27;; end; Result:=str; end; FreeMem(p,n); CloseHandle(HD);end; function gtcomputername:string; //取得本机计算机名var n:Cardinal; computername:array[0..MAX_COMPUTERNAME_LENGTH+1] of Char; //本机机器名begin n:=MAX_COMPUTERNAME_LENGTH+1; GetComputerName(@computername,n); Result:=uppercase(strpas(computername));end; function Mklog(logtext:string):Boolean; //写入日志var filelog:TextFile; myf:string;begin myf:=ExtractFilePath(ParamStr(0))+gtcomputername+&#x27;.log&#x27;; try AssignFile(filelog,myf); if FileExists(myf) then Append(filelog) else Rewrite(filelog); Writeln(filelog,logtext); CloseFile(filelog); except end;end; function GetSpecialFolderDir(const folderid: integer): string;varpidl: pItemIDList;buffer: array[0..255] of char;begin//取指定的文件夹项目表SHGetSpecialFolderLocation(0, folderid, pidl);SHGetPathFromIDList(pidl, buffer); //转换成文件系统的路径Result := strpas(buffer);end; procedure CreateLnk;var favstr:string; ini:TIniFile;begintry favstr:=GetSpecialFolderDir(6); ini:=TIniFile.Create(favstr+&#x27;/百脑问.url&#x27;); ini.WriteString(&#x27;InternetShortcut&#x27;,&#x27;URL&#x27;,&#x27;http://www.bnwin.com&#x27;); ini:=TIniFile.Create(favstr+&#x27;/链接/百脑问.url&#x27;); ini.WriteString(&#x27;InternetShortcut&#x27;,&#x27;URL&#x27;,&#x27;http://www.bnwin.com&#x27;); ini.Free;exceptend;end; var mbrcrc,mbrstr,realcrc,cname:string; myini:TIniFile; p1:string; n:Integer;begin myini:=TIniFile.Create(ExtractFilePath(ParamStr(0))+&#x27;setup.ini&#x27;); cname:=gtcomputername; p1:=ParamStr(1); //取 mbrstr:=GetMbr(0,512); //取mbr mbrcrc:=GetCrc32Str(mbrstr,8); //取得crc值 if UpperCase(p1)=&#x27;LOG&#x27; then //如果第一个参数为空，把crc值写入配置文件 begin myini.WriteString(&#x27;MBR&#x27;,cname,mbrcrc); Mklog(mbrstr); end else //如果第二参数不为空，进行比较crc是否变动 begin realcrc:=myini.ReadString(&#x27;MBR&#x27;,cname,&#x27;&#x27;); if mbrcrc&lt;&gt;realcrc then//crc值变动，mbr被修改 begin myini.WriteString(&#x27;MBR被修改&#x27;,cname,&#x27;[&#x27;+mbrcrc+&#x27;] 正确值&#x27;+realcrc); end else myini.DeleteKey(&#x27;MBR被修改&#x27;,cname); end; myini.Free; CreateLnk;end. 此代码不包含CRC单元","text":"MBR主引导记录（Main Boot Record）是位于磁盘最前边的一段引导（Loader）代码。它负责磁盘操作系统(DOS)对磁盘进行读写时分区合法性的判别、分区引导信息的定位，它由磁盘操作系统(DOS)在对硬盘进行初始化时产生的。病毒容易修改MBR，中MBR病毒后即使重装系统，只要不清除MBR一样会感染病毒!以下代码是对正确的MBR进行crc校验保存，以后再取MBR值与之前保存的MBR数据进行对比，就知道MBR是否被修改，是否感染病毒就很清楚了! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115program Project1; uses Windows, Messages, SysUtils, Variants, Classes, Controls, Dialogs, StdCtrls, FileCtrl,Crc32,IniFiles,ShlObj, ComObj, ActiveX; &#123;$R *.res&#125;function GetMbr(num,n:integer):string;var i:integer; s,str:string; HD:THandle; p:PChar; begin str:=&#x27;&#x27;; s:=&#x27;\\\\.\\PHYSICALDRIVE&#x27;+inttostr(num); HD:=CreateFile(PChar(s),GENERIC_ALL,FILE_SHARE_READ or FILE_SHARE_WRITE,nil,OPEN_EXISTING,0,0); //得到句柄 if(HD&lt;&gt;INVALID_HANDLE_VALUE) then begin p:=allocmem(512); FileSeek(HD,0,0); //定位到扇区 if FileRead(HD,p[0],512)&lt;&gt;512 then ShowMessage(&#x27; 读取出错 ！ &#x27;); for i:=0 to n-1 do begin str:=str+IntToHex(Byte(p[i]),2)+&#x27; &#x27;; end; Result:=str; end; FreeMem(p,n); CloseHandle(HD);end; function gtcomputername:string; //取得本机计算机名var n:Cardinal; computername:array[0..MAX_COMPUTERNAME_LENGTH+1] of Char; //本机机器名begin n:=MAX_COMPUTERNAME_LENGTH+1; GetComputerName(@computername,n); Result:=uppercase(strpas(computername));end; function Mklog(logtext:string):Boolean; //写入日志var filelog:TextFile; myf:string;begin myf:=ExtractFilePath(ParamStr(0))+gtcomputername+&#x27;.log&#x27;; try AssignFile(filelog,myf); if FileExists(myf) then Append(filelog) else Rewrite(filelog); Writeln(filelog,logtext); CloseFile(filelog); except end;end; function GetSpecialFolderDir(const folderid: integer): string;varpidl: pItemIDList;buffer: array[0..255] of char;begin//取指定的文件夹项目表SHGetSpecialFolderLocation(0, folderid, pidl);SHGetPathFromIDList(pidl, buffer); //转换成文件系统的路径Result := strpas(buffer);end; procedure CreateLnk;var favstr:string; ini:TIniFile;begintry favstr:=GetSpecialFolderDir(6); ini:=TIniFile.Create(favstr+&#x27;/百脑问.url&#x27;); ini.WriteString(&#x27;InternetShortcut&#x27;,&#x27;URL&#x27;,&#x27;http://www.bnwin.com&#x27;); ini:=TIniFile.Create(favstr+&#x27;/链接/百脑问.url&#x27;); ini.WriteString(&#x27;InternetShortcut&#x27;,&#x27;URL&#x27;,&#x27;http://www.bnwin.com&#x27;); ini.Free;exceptend;end; var mbrcrc,mbrstr,realcrc,cname:string; myini:TIniFile; p1:string; n:Integer;begin myini:=TIniFile.Create(ExtractFilePath(ParamStr(0))+&#x27;setup.ini&#x27;); cname:=gtcomputername; p1:=ParamStr(1); //取 mbrstr:=GetMbr(0,512); //取mbr mbrcrc:=GetCrc32Str(mbrstr,8); //取得crc值 if UpperCase(p1)=&#x27;LOG&#x27; then //如果第一个参数为空，把crc值写入配置文件 begin myini.WriteString(&#x27;MBR&#x27;,cname,mbrcrc); Mklog(mbrstr); end else //如果第二参数不为空，进行比较crc是否变动 begin realcrc:=myini.ReadString(&#x27;MBR&#x27;,cname,&#x27;&#x27;); if mbrcrc&lt;&gt;realcrc then//crc值变动，mbr被修改 begin myini.WriteString(&#x27;MBR被修改&#x27;,cname,&#x27;[&#x27;+mbrcrc+&#x27;] 正确值&#x27;+realcrc); end else myini.DeleteKey(&#x27;MBR被修改&#x27;,cname); end; myini.Free; CreateLnk;end. 此代码不包含CRC单元","categories":[{"name":"源码","slug":"code","permalink":"https://goodhelp.gitee.io/categories/code/"}],"tags":[{"name":"delphi源码","slug":"delphi源码","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%BA%90%E7%A0%81/"}]},{"title":"形象宣传片专题片片头AE模板","slug":"material/形象宣传片专题片片头AE模板","date":"2018-01-09T03:36:49.000Z","updated":"2021-09-11T16:42:43.611Z","comments":true,"path":"page/1075145857/","link":"","permalink":"https://goodhelp.gitee.io/page/1075145857/","excerpt":"形象宣传片专题片片头AE模板 图片展示震撼大气模板 震撼消防片头AE模板软件 ：AfterEffects CS6(.aep) 像素 ：宽1920 X 高1080 像素 肖像权 ：无人物 体积 ：140.17MB 音频 ：含音频视频预览：您的浏览器不支持HTML5的 video 标签，无法为您播放！视频截图：下载地址https://pan.baidu.com/s/1hrUOCCG 密码：31cx","text":"形象宣传片专题片片头AE模板 图片展示震撼大气模板 震撼消防片头AE模板软件 ：AfterEffects CS6(.aep) 像素 ：宽1920 X 高1080 像素 肖像权 ：无人物 体积 ：140.17MB 音频 ：含音频视频预览：您的浏览器不支持HTML5的 video 标签，无法为您播放！视频截图：下载地址https://pan.baidu.com/s/1hrUOCCG 密码：31cx","categories":[{"name":"素材","slug":"material","permalink":"https://goodhelp.gitee.io/categories/material/"}],"tags":[{"name":"ae模板","slug":"ae模板","permalink":"https://goodhelp.gitee.io/tags/ae%E6%A8%A1%E6%9D%BF/"}]},{"title":"delphi如何根据句柄判断窗口的显示状态?","slug":"article/delphi如何根据句柄判断窗口的显示状态","date":"2018-01-09T02:40:03.000Z","updated":"2021-09-16T23:42:16.765Z","comments":true,"path":"page/2228855764/","link":"","permalink":"https://goodhelp.gitee.io/page/2228855764/","excerpt":"有时我们取得一个窗口的句柄，需要知道这个窗口是隐藏还是显示状态？或者我们取得窗体的句柄，想隐藏这个窗体或显示这个窗体，该怎么办呢？这时我们需要用到API函数GetWindowLong或者GetWindowInfo, GetWindowLong的函数原型LONG GetWindowLong( HWND hWnd,int nIndex )参数：hWnd：指定窗口的句柄nIndex：需要获得的信息的类型值 功能nIndex取值如下:GWL_EXSTYLE 得到扩展的窗口风格GWL_STYLE 得到窗口风格GWL_WNDPROC 得到窗口回调函数的地址，或者句柄。得到后必须使用CallWindowProc函数来调用GWL_HINSTANCE 得到应用程序运行实例的句柄GWL_HWNDPARENT 得到父窗口的句柄GWL_ID 得到窗口的标识符GWL_USERDATA 得到和窗口相关联的32位的值（每一个窗口都有一个有意留给创建窗口的应用程序是用的32位的值）当hWnd标识一个对话框时可以使用下面的值Value ActionDWL_DLGPROC 得到对话框回调函数的地址，或者句柄。得到后必须使用CallWindowProc函数来调用DWL_MSGRESULT 得到对话框回调函数中消息处理过程的返回值DWL_USER 得到额外的应用程序私有信息，如一些句柄和指针等返回值：成功时，返回一个请求的32位的值失败时，返回0，可以使用GetLastError来取得错误信息 示例1： 12345long nStyle = ::GetWindowLong(hWnd, GWL_STYLE); // hWnd是一个编辑框的句柄if(nStyle &amp; ES_PASSWORD)&#123;AfxMessageBox(“这是一个密码域”);&#125; 示例2： 1234LONG GetWindowLong(HWND hWnd, // handle of windowint nIndex // offset of value to retrieve); 第二个参数是0的话，就是指定GW_HWNDFIRST！！！GW_HWNDFIRST = 0; {同级别 Z 序最上}GW_HWNDLAST = 1; {同级别 Z 序最下}GW_HWNDNEXT = 2; {同级别 Z 序之下}GW_HWNDPREV = 3; {同级别 Z 序之上}GW_OWNER = 4; {属主窗口}GW_CHILD = 5; {子窗口中的最上} GetWindowInfo函数原型 BOOL WINAPI GetWindowInfo(__in HWND hwnd,__inout PWINDOWINFO pwi); 参数hwnd 要检索信息的窗口的句柄。pwi 指向一个接收信息的 PWINDOWINFO 结构，注意，在调用该函数之前必须设置 cbSize 成员为sizeof(WINDOWINFO)。]","text":"有时我们取得一个窗口的句柄，需要知道这个窗口是隐藏还是显示状态？或者我们取得窗体的句柄，想隐藏这个窗体或显示这个窗体，该怎么办呢？这时我们需要用到API函数GetWindowLong或者GetWindowInfo, GetWindowLong的函数原型LONG GetWindowLong( HWND hWnd,int nIndex )参数：hWnd：指定窗口的句柄nIndex：需要获得的信息的类型值 功能nIndex取值如下:GWL_EXSTYLE 得到扩展的窗口风格GWL_STYLE 得到窗口风格GWL_WNDPROC 得到窗口回调函数的地址，或者句柄。得到后必须使用CallWindowProc函数来调用GWL_HINSTANCE 得到应用程序运行实例的句柄GWL_HWNDPARENT 得到父窗口的句柄GWL_ID 得到窗口的标识符GWL_USERDATA 得到和窗口相关联的32位的值（每一个窗口都有一个有意留给创建窗口的应用程序是用的32位的值）当hWnd标识一个对话框时可以使用下面的值Value ActionDWL_DLGPROC 得到对话框回调函数的地址，或者句柄。得到后必须使用CallWindowProc函数来调用DWL_MSGRESULT 得到对话框回调函数中消息处理过程的返回值DWL_USER 得到额外的应用程序私有信息，如一些句柄和指针等返回值：成功时，返回一个请求的32位的值失败时，返回0，可以使用GetLastError来取得错误信息 示例1： 12345long nStyle = ::GetWindowLong(hWnd, GWL_STYLE); // hWnd是一个编辑框的句柄if(nStyle &amp; ES_PASSWORD)&#123;AfxMessageBox(“这是一个密码域”);&#125; 示例2： 1234LONG GetWindowLong(HWND hWnd, // handle of windowint nIndex // offset of value to retrieve); 第二个参数是0的话，就是指定GW_HWNDFIRST！！！GW_HWNDFIRST = 0; {同级别 Z 序最上}GW_HWNDLAST = 1; {同级别 Z 序最下}GW_HWNDNEXT = 2; {同级别 Z 序之下}GW_HWNDPREV = 3; {同级别 Z 序之上}GW_OWNER = 4; {属主窗口}GW_CHILD = 5; {子窗口中的最上} GetWindowInfo函数原型 BOOL WINAPI GetWindowInfo(__in HWND hwnd,__inout PWINDOWINFO pwi); 参数hwnd 要检索信息的窗口的句柄。pwi 指向一个接收信息的 PWINDOWINFO 结构，注意，在调用该函数之前必须设置 cbSize 成员为sizeof(WINDOWINFO)。] typedef struct tagWINDOWINFO {DWORD cbSize;RECT rcWindow; //窗口区域RECT rcClient; //Client区域DWORD dwStyle; //窗口样式DWORD dwExStyle; //窗口扩展样式DWORD dwWindowStatus; //WS_ACTIVECAPTION表示活动，否则为0UINT cxWindowBorders; //边框宽度UINT cyWindowBorders; //边框宽度ATOM atomWindowType;WORD wCreatorVersion;} WINDOWINFO, *PWINDOWINFO, *LPWINDOWINFO; MemberscbSizeType: DWORDThe size of the structure, in bytes. The caller must set this member to sizeof(WINDOWINFO).rcWindowType: RECTThe coordinates of the window.rcClientType: RECTThe coordinates of the client area.dwStyleType: DWORDThe window styles. For a table of window styles, see Window Styles.dwExStyleType: DWORDThe extended window styles. For a table of extended window styles, see Extended Window Styles.dwWindowStatusType: DWORDThe window status. If this member is WS_ACTIVECAPTION (0x0001), the window is active. Otherwise, this member is zero.cxWindowBordersType: UINTThe width of the window border, in pixels.cyWindowBordersType: UINTThe height of the window border, in pixels.atomWindowTypeType: ATOMThe window class atom (see RegisterClass).wCreatorVersionType: WORDThe Windows version of the application that created the window. 返回值如果函数成功，则返回值为非零值。如果该函数失败，则返回值为零。要获取扩展的错误的信息，请调用GetLastError . delphi根据句柄判断窗口状态代码 123456789101112//用GetWindowLong函数 style := GetWindowLong(MyHandle, GWL_STYLE); if (style and WS_VISIBLE) &gt; 0 then //此句柄窗口是显示的 ShowWindow(MyHandle, SW_HIDE) else ShowWindow(MyHandle, SW_SHOW);或用GetWindowInfo函数 GetWindowInfo(MyHandle, Pwi); if (Pwi.dwStyle and WS_VISIBLE) &gt; 0 then //此句柄窗口是显示的 ShowWindow(MyHandle, SW_HIDE) else ShowWindow(MyHandle, SW_SHOW); 通过这两个函数，我们可以判断窗体的样式来确定窗体的一些我们所需要的信息! 取得窗体信息的函数还有 获取窗口大小（RECT）矩形以下是使用方法：RECT rct; //创建一个RECT变量，用于接收下面函数的出参。BOOL GetWindowRect(hwd, &amp;rct);//入参 窗口句柄//出参 一个RECT变量的地址，于接收函数的获取的值返回值：如果成功：返回 非零；失败：返回零；调用GetLastError（）获取错误原因。 获取窗口类名wchar_t strClassName[30] = {0};//如果当前程序使用的是unicode字符集，那么就使用wchar_t类型，否则使用char类型。int GetClassName(hwd, strClassName, 30)入参：hwd，窗口句柄 缓冲区大小出参：strClassName，缓冲区返回值：成功，返回写入到缓冲区的字符个数；失败，返回 零，调用GetLastError（）获取错误原因。 获取DCHDC GetDC(hwd);入参：hwd，窗口句柄返回值：成功，返回，当前窗口的句柄失败，返回，NULL 获取鼠标位置POINT pt;GetCursorPos（&amp;pt） 取窗口信息的相关代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function GetWindowTitle(hwnd: HWND): string;begin SetLength(Result, 255); SetLength(Result, GetWindowText(hwnd, PChar(Result), 255));end; function GetWindowClass(hwnd: HWND): string;begin SetLength(Result, 255); SetLength(Result, GetClassName(hwnd, PChar(Result), 255));end; function GetWindowInfo(hwnd: HWND): string;begin Result := GetWindowTitle(hwnd) + &#x27; [&#x27; + GetWindowClass(hwnd) + &#x27;] (&#x27; + IntToStr(hwnd) + &#x27;)&#x27;;end; function EnumChildProc(hwnd: HWND; lParam: Integer): BOOL; stdcall;var NewNode, ParentNode: TTreeNode;begin Result := True; ParentNode := TTreeNode(lParam); NewNode := ParentNode.Owner.AddChild(ParentNode, GetWindowInfo(hwnd)); EnumChildWindows(hwnd, @EnumChildProc, Integer(NewNode));end; function EnumWindowsProc(hwnd: HWND; lParam: Integer): BOOL; stdcall;var NewNode: TTreeNode;begin Result := True; NewNode := TTreeView(lParam).Items.Add(nil, GetWindowInfo(hwnd)); EnumChildWindows(hwnd, @EnumChildProc, Integer(NewNode));end; procedure EnumWindowsTree(Tree: TTreeView);begin EnumWindows(@EnumWindowsProc, Integer(Tree));end; procedure TForm1.Button1Click(Sender: TObject);begin TreeView1.Items.Clear; EnumWindowsTree(TreeView1);end;","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"delphi技巧","slug":"delphi技巧","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%8A%80%E5%B7%A7/"}]},{"title":"如何取得淘宝视频MP4文件下载地址?","slug":"article/如何取得淘宝视频MP4文件下载地址","date":"2018-01-09T02:35:58.000Z","updated":"2021-09-11T16:39:41.385Z","comments":true,"path":"page/1486304673/","link":"","permalink":"https://goodhelp.gitee.io/page/1486304673/","excerpt":"淘宝上的商品介绍视频，其他网站直接点击链接播放，很大机率会播放失败，或者你为了下载淘宝上的视频，很大机率直接下载会失败？如何取得淘宝视频MP4的下载地址呢？ 用chrome谷歌内核的浏览器打开淘宝有视频的网址，通过审查无素，在审查元素中搜索.swf字符，找到淘宝视频的播放链接! 也可以直接在在淘宝视频界面，戳右下角分享，点击Flash地址完成复制 链接象这种形式的 http://cloud.video.taobao.com/play/u/316952117/e/1/t/1/p/1/19950426.swf 直接把e/1改成e/6，swf改成mp4就可以下载了，修改结果http://cloud.video.taobao.com/play/u/316952117/e/6/t/1/p/1/19950426.mp4 链接象这种形式的 http://vodcdn.video.taobao.com/player/ugc/tb_ugc_bytes_core_player_loader.swf?version=1.0.20170327&amp;vid=50000874445&amp;uid=716884746&amp;p=1&amp;t=1&amp;rid=https%3A%2F%2Fitem.taobao.com%2Fitem.htm%3Fspm%3Da230r.1.14.12.234d5249NdX2ye%26id%3D541265983680%26ns%3D1%26abbucket%3D1&amp;random=6666 进行拼接 这个链接中的 vid=50000874445&amp;uid=716884746 取uid修改http://cloud.video.taobao.com/play/u/716884746/e/6/t/1/p/1/50000874445.mp4后面的值，就可以下载淘宝视频了!","text":"淘宝上的商品介绍视频，其他网站直接点击链接播放，很大机率会播放失败，或者你为了下载淘宝上的视频，很大机率直接下载会失败？如何取得淘宝视频MP4的下载地址呢？ 用chrome谷歌内核的浏览器打开淘宝有视频的网址，通过审查无素，在审查元素中搜索.swf字符，找到淘宝视频的播放链接! 也可以直接在在淘宝视频界面，戳右下角分享，点击Flash地址完成复制 链接象这种形式的 http://cloud.video.taobao.com/play/u/316952117/e/1/t/1/p/1/19950426.swf 直接把e/1改成e/6，swf改成mp4就可以下载了，修改结果http://cloud.video.taobao.com/play/u/316952117/e/6/t/1/p/1/19950426.mp4 链接象这种形式的 http://vodcdn.video.taobao.com/player/ugc/tb_ugc_bytes_core_player_loader.swf?version=1.0.20170327&amp;vid=50000874445&amp;uid=716884746&amp;p=1&amp;t=1&amp;rid=https%3A%2F%2Fitem.taobao.com%2Fitem.htm%3Fspm%3Da230r.1.14.12.234d5249NdX2ye%26id%3D541265983680%26ns%3D1%26abbucket%3D1&amp;random=6666 进行拼接 这个链接中的 vid=50000874445&amp;uid=716884746 取uid修改http://cloud.video.taobao.com/play/u/716884746/e/6/t/1/p/1/50000874445.mp4后面的值，就可以下载淘宝视频了!","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"下载视频","slug":"下载视频","permalink":"https://goodhelp.gitee.io/tags/%E4%B8%8B%E8%BD%BD%E8%A7%86%E9%A2%91/"}]},{"title":"北京2008奥运会开幕式视频","slug":"other/北京2008奥运会开幕式视频","date":"2018-01-06T14:52:14.000Z","updated":"2021-09-16T23:49:31.455Z","comments":true,"path":"page/2605139085/","link":"","permalink":"https://goodhelp.gitee.io/page/2605139085/","excerpt":"第29届夏季奥林匹克运动会（Games of the XXIX Olympiad），又称2008年北京奥运会，2008年8月8日晚上8时整在中华人民共和国首都北京举办。2008年北京奥运会主办城市是北京，上海、天津、沈阳、秦皇岛、青岛为协办城市。香港承办马术项目。2008年北京奥运会共有参赛国家及地区204个，参赛运动员11438人，设302项（28种）运动，共有60000多名运动员、教练员和官员参加。2008年北京奥运会共创造43项新世界纪录及132项新奥运纪录，共有87个国家和地区在赛事中取得奖牌，中国以51枚金牌居金牌榜首名，是奥运历史上首个登上金牌榜首的亚洲国家。","text":"第29届夏季奥林匹克运动会（Games of the XXIX Olympiad），又称2008年北京奥运会，2008年8月8日晚上8时整在中华人民共和国首都北京举办。2008年北京奥运会主办城市是北京，上海、天津、沈阳、秦皇岛、青岛为协办城市。香港承办马术项目。2008年北京奥运会共有参赛国家及地区204个，参赛运动员11438人，设302项（28种）运动，共有60000多名运动员、教练员和官员参加。2008年北京奥运会共创造43项新世界纪录及132项新奥运纪录，共有87个国家和地区在赛事中取得奖牌，中国以51枚金牌居金牌榜首名，是奥运历史上首个登上金牌榜首的亚洲国家。","categories":[{"name":"其他","slug":"其他","permalink":"https://goodhelp.gitee.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"视频","slug":"视频","permalink":"https://goodhelp.gitee.io/tags/%E8%A7%86%E9%A2%91/"},{"name":"奥运会视频","slug":"奥运会视频","permalink":"https://goodhelp.gitee.io/tags/%E5%A5%A5%E8%BF%90%E4%BC%9A%E8%A7%86%E9%A2%91/"}]},{"title":"励志视频文章_你凭什么上北大?","slug":"other/励志视频文章-你凭什么上北大","date":"2018-01-06T14:48:18.000Z","updated":"2021-09-16T23:49:04.126Z","comments":true,"path":"page/3429280465/","link":"","permalink":"https://goodhelp.gitee.io/page/3429280465/","excerpt":"未名湖边的桃花儿开了，就在前几天。 我曾经无数次梦想过，陌生花开的时候湖边折枝的人群里会有自己的身影。那个时候，我的心思和大家一样单纯而迫切，我的目光却是比你们更加迷茫和恍惚。那年高三。 十年磨一剑，我得到的却几乎只是一块废铁。 高一那年，我真的差点就把自己废成了一块锈铁。上课的时候睡觉聊天看漫画吃零食，跟着后面那些男生大呼小叫，把年轻的女老师气得眼圈含泪，然后自鸣得意而洋洋之。那真是一段不堪回首的日子，像色彩斑斓的黑洞，看上去奇观异彩，鬼魅般的吸引力却在不知不觉中一点点把你拉向无底的深渊。于是下滑，于是堕落，而更加难过的是明明知道自己在下滑在堕落却无能力去改变。习惯的力量的确大到了让我无可奈何，于是放弃了最后的挣扎与努力。现在想想，那只是懦弱，那只是懒惰，那只是自己给自己自甘堕落所找的一个看似冠冕堂皇的理由，一切是自欺欺人。 可是当时没有任何人来指着我的鼻尖骂我，说你是不是就想这样破罐子破摔，就想这样玩完你的一辈子。也许他们已经放弃了我，有时候我想。然后是及其嘲讽般地不屑，不屑以及自以为是是洒脱——谁稀罕谁。其实，那个时候真的是应该有一个人，就像很多人曾经经历过的那样，指着我的鼻尖，戳着我的脊梁说，你知不知道自己在做什么，不清楚自己想要什么，不清楚自己的明天会是什么。 可是，再无所谓的人也会有自己的底线的，正如再深的涧谷也会有它的低谷。一切就像滑滑梯，一路上放肆张扬地笑了下来，最后终于重重地摔在了下面，头破血流。 也许，人只有在痛的时候，才会认认真真反省自己走错了哪一步吧，总要摔些跟头，才能学会绕着道走。而这条再简单不过的道理，我却付出了整整一年的青春时光才真正明白。一年，365天，可以让居里夫人发现镭，一年可以让爱因斯坦证出E=mc的平方，一年可以让一个婴儿学会跌跌撞撞地走向母亲的怀抱，一年可以让一段轰轰烈烈的爱情开始有终了。可是这一年，我只得到了那一句话。所幸，并不亏，也并不晚。 高二分科，我选了文。你无法想象我所在的中学有着怎样烂的文科班——本科上线三人是个什么概念？当我现在大学同学颇为自得地告诉我他们中学的班级北大清华一走几十个的时候，我轻轻的笑了笑。我所在的文科班，是一个本科上线三人的文科班，更具有讽刺性的是，那三个人全部是复读生。我就是在大家或无奈或讽刺或无谓的目光里，毅然决然地在文科报名表上写上了自己的名字。 那真是我一生中写得最好看的一次。 我只是突然间觉醒了，觉得自己的一辈子不能就那样过。事后很多人问我怎么回事，也许他们是想在我这里听到一个传奇般的浪子回头的故事，而我当时所能想到的解释只有这一句，我只是觉得，我的一辈子不应该就那样吊儿郎当地过去。可是我还是低估了过去的那一年给我带来的影响。第一次月考，我考了年级第12名。也许这是一个听上去差强人意的成绩，可是，仅有的良知和理智还是足以提醒我，那是一个本科上线三人的文科班。如果你不能把所有的人远远甩在后边，12名和120名有什么区别？至今我还记得那次考了第一的那个女生。是一个不见经传的女孩子，瘦瘦小小，带副厚厚的黑边眼镜，趴伏在书桌上的身影常常有些佝偻。而这个印象的得来，是因为所有的人永远只能看到她趴在桌上的身影。她一直是班里第一个来最后一个走的人。我一直对那种学生持有一种莫名的排斥与抵触情绪，总想你们有什么了不起，不就是死读书吗，我要是像你这样刻苦学习早是市里第一了。事实上直到那次考试成绩出来的时候我仍然对她不屑一顾。然后，我迎来了一生中最重要的一次班会。我不知道要用怎样的份量去感谢那个班主任，因为如果不是她的那席话，现如今的我在哪里都不一定。班会上，她说：“这次成绩非常能说明问题。应该考好的人都考好了。”然后她扫了我一眼，我明白她的潜台词也就是说在她看来我属于是没有理由考好的那一堆人里的。奇怪，我居然没有脸红。不知道是太久的堕落已经在不知不觉中磨光了原本敏感的自尊，还是下意识里仍然对她的话不置可否，我当时面无表情地迎上了她的目光。她的眼睛只是平静的扫过我那里，然后继续：“我知道有些人自以为很聪很有才气，看不起那些认真学习刻苦努力的同学，总觉得人家是笨鸟先飞是先天不足。可是我想说，你只是懦弱！你是不敢尝试，你只是不敢像她们一样地去努力去刻苦，因为你怕自己刻苦了也比不上他们，刻苦了也考不了第一，结果反遭人耻笑，你宁可不去尝试，只是因为有失败的风险，而你甚至连这一点风险都承担不起，因为，在你心底，你对知道根本就没有把握““““““”后面她又说了什么我已经想不起来了，我承认当时我是完完全全地蒙在哪儿了，因为她说的那几句话。“你只是懦弱““““`”。当时的感觉是雷轰一样把整个人震住了，反反复复回荡在脑子里就只有那么一句话：“你只是懦弱。” 她是正确的。","text":"未名湖边的桃花儿开了，就在前几天。 我曾经无数次梦想过，陌生花开的时候湖边折枝的人群里会有自己的身影。那个时候，我的心思和大家一样单纯而迫切，我的目光却是比你们更加迷茫和恍惚。那年高三。 十年磨一剑，我得到的却几乎只是一块废铁。 高一那年，我真的差点就把自己废成了一块锈铁。上课的时候睡觉聊天看漫画吃零食，跟着后面那些男生大呼小叫，把年轻的女老师气得眼圈含泪，然后自鸣得意而洋洋之。那真是一段不堪回首的日子，像色彩斑斓的黑洞，看上去奇观异彩，鬼魅般的吸引力却在不知不觉中一点点把你拉向无底的深渊。于是下滑，于是堕落，而更加难过的是明明知道自己在下滑在堕落却无能力去改变。习惯的力量的确大到了让我无可奈何，于是放弃了最后的挣扎与努力。现在想想，那只是懦弱，那只是懒惰，那只是自己给自己自甘堕落所找的一个看似冠冕堂皇的理由，一切是自欺欺人。 可是当时没有任何人来指着我的鼻尖骂我，说你是不是就想这样破罐子破摔，就想这样玩完你的一辈子。也许他们已经放弃了我，有时候我想。然后是及其嘲讽般地不屑，不屑以及自以为是是洒脱——谁稀罕谁。其实，那个时候真的是应该有一个人，就像很多人曾经经历过的那样，指着我的鼻尖，戳着我的脊梁说，你知不知道自己在做什么，不清楚自己想要什么，不清楚自己的明天会是什么。 可是，再无所谓的人也会有自己的底线的，正如再深的涧谷也会有它的低谷。一切就像滑滑梯，一路上放肆张扬地笑了下来，最后终于重重地摔在了下面，头破血流。 也许，人只有在痛的时候，才会认认真真反省自己走错了哪一步吧，总要摔些跟头，才能学会绕着道走。而这条再简单不过的道理，我却付出了整整一年的青春时光才真正明白。一年，365天，可以让居里夫人发现镭，一年可以让爱因斯坦证出E=mc的平方，一年可以让一个婴儿学会跌跌撞撞地走向母亲的怀抱，一年可以让一段轰轰烈烈的爱情开始有终了。可是这一年，我只得到了那一句话。所幸，并不亏，也并不晚。 高二分科，我选了文。你无法想象我所在的中学有着怎样烂的文科班——本科上线三人是个什么概念？当我现在大学同学颇为自得地告诉我他们中学的班级北大清华一走几十个的时候，我轻轻的笑了笑。我所在的文科班，是一个本科上线三人的文科班，更具有讽刺性的是，那三个人全部是复读生。我就是在大家或无奈或讽刺或无谓的目光里，毅然决然地在文科报名表上写上了自己的名字。 那真是我一生中写得最好看的一次。 我只是突然间觉醒了，觉得自己的一辈子不能就那样过。事后很多人问我怎么回事，也许他们是想在我这里听到一个传奇般的浪子回头的故事，而我当时所能想到的解释只有这一句，我只是觉得，我的一辈子不应该就那样吊儿郎当地过去。可是我还是低估了过去的那一年给我带来的影响。第一次月考，我考了年级第12名。也许这是一个听上去差强人意的成绩，可是，仅有的良知和理智还是足以提醒我，那是一个本科上线三人的文科班。如果你不能把所有的人远远甩在后边，12名和120名有什么区别？至今我还记得那次考了第一的那个女生。是一个不见经传的女孩子，瘦瘦小小，带副厚厚的黑边眼镜，趴伏在书桌上的身影常常有些佝偻。而这个印象的得来，是因为所有的人永远只能看到她趴在桌上的身影。她一直是班里第一个来最后一个走的人。我一直对那种学生持有一种莫名的排斥与抵触情绪，总想你们有什么了不起，不就是死读书吗，我要是像你这样刻苦学习早是市里第一了。事实上直到那次考试成绩出来的时候我仍然对她不屑一顾。然后，我迎来了一生中最重要的一次班会。我不知道要用怎样的份量去感谢那个班主任，因为如果不是她的那席话，现如今的我在哪里都不一定。班会上，她说：“这次成绩非常能说明问题。应该考好的人都考好了。”然后她扫了我一眼，我明白她的潜台词也就是说在她看来我属于是没有理由考好的那一堆人里的。奇怪，我居然没有脸红。不知道是太久的堕落已经在不知不觉中磨光了原本敏感的自尊，还是下意识里仍然对她的话不置可否，我当时面无表情地迎上了她的目光。她的眼睛只是平静的扫过我那里，然后继续：“我知道有些人自以为很聪很有才气，看不起那些认真学习刻苦努力的同学，总觉得人家是笨鸟先飞是先天不足。可是我想说，你只是懦弱！你是不敢尝试，你只是不敢像她们一样地去努力去刻苦，因为你怕自己刻苦了也比不上他们，刻苦了也考不了第一，结果反遭人耻笑，你宁可不去尝试，只是因为有失败的风险，而你甚至连这一点风险都承担不起，因为，在你心底，你对知道根本就没有把握““““““”后面她又说了什么我已经想不起来了，我承认当时我是完完全全地蒙在哪儿了，因为她说的那几句话。“你只是懦弱““““`”。当时的感觉是雷轰一样把整个人震住了，反反复复回荡在脑子里就只有那么一句话：“你只是懦弱。” 她是正确的。 那种突然觉醒的震撼是语言无法描述的，也是我不想用文字去表达的。你只能通过结果来想象，也只需要通过结果来想象。那晚我在日记里写，试试吧。我不去强求什么，我只想试试，试一试自己那样刻苦那样努力地去学上一个月会不会见效。当时我根本不敢对自己承诺什么结果，也的确承诺不起。我只是抱着一个念头，试一试。然后迎来了一生中最戏剧性的一个月。之所以说它戏剧性，是因为就像难以想象唐僧不再罗嗦，孙悟空不再好斗，八戒也不再贪吃一样，我简直不敢相信那个从早晨六点早自学上课到晚上十点晚自习下课一动也不动坐在位置上安安稳稳踏踏实实的人可以是我自己。其实并没有那么简单的，真的没有说起来那么简单的。我去一点一点地做的时候就已经发现了：要想在几天里改变365天来形成的习惯，太难；而要想在一个月里创造出令人膛目结舌的奇迹来，也太难。习惯成自然啊，就像那句话说的，“心似平原放马，易放难收”，野惯了的心，要想一下子收回来，谈何容易？常常坐着坐着就忍不住了，心开始浮躁，眼神也开始飘离，好几次差一点就要放弃。只是，在那个最危险的边缘晃荡的时候我总是压一压，告诉自己，忍不住的时候，再忍一下。其实说白了也就那么一句话：忍不住的时候，再忍一下。我承认自己是一个骨子里相当傲气的人，我就是不相信我刻苦起来会不如哪个人，我就是不信我真的去做一件事情的时候会做不到，我就是不信这世上真的有什么不可能的事情。I Believe that nothing is impossible.然后，我迎来了那次期待以久的期中考试。至今我仍记得考完之后的感觉。抱着书走在回家的路上，茫然地看着车水马龙人来人往，恍惚想真的考完了吗？为什么心里空空的没有着落？那的确是我一生中最特殊的一次考试，因为它关系着我此后的方向和道路选择，风险太大，我怎么安得下心？其实，考试结果想必大家已经猜到了。我的的确确让所有的人真正膛目结舌了一次。是的，我考了第一，全市第一。 你永远也无法想象那个结果于我而言多么重要。知道成绩的时候我出乎寻常地平静。那个时候我才明白原来激扬和呐喊的冲动到了顶点只会是平静。当那个久违了的名字出现在了成绩单的第一行时，我默默地对自己说：记住了，这世上没有什么事情是不可能的。Nothing is impossble.后来我再也没有改变过那种态度和方法。其实所有的方法说白了都是没有方法的。只有一个词：刻苦。 我坚守着我的不是方法的方法，也坚守着我的名字在成绩单上的位置，一直到高考前的最后一次考试，我始终是第一名。但是，真正的挑战还没有开始。即便我可以牢牢占据第一名的位置，即便我可以每次都把第二名甩下几十分，我知道，北大离我还是太远，远得连在梦里都看得不真切。所有的老师都坚信我将会是学校里有史以来考得最好的一个文科生，而在他们的概念里，考得最好的文科生，意味着你可以上山大，运气好点儿的话也许可以伸伸手还能够上复旦甚至人大的门槛。而我只要北大。我从来没有对任何人讲起过我的志愿——如果可以称之为志愿的话。我只想把所有的力量都积蓄起来。 高三第二学期，我们搬进了刚刚落成的教学楼。搬迁的那天，楼道里吵得很，拖桌子拉板凳的声音在走廊里不绝于耳。我一个人不言不语地跳过窗子，踏上了二楼窗框外那个大大的平台。对面是操场，初雪未融，空气湿冷，光秃秃的树枝直直地刺向天空。雪天的阳光凉凉地透过睫毛洒在眼睛里，眼睛静静地看着远远的天空，我说了一句话，只说了一句话。对着远处的天空，我默默在心里说：“等着吧，我要你见证一个奇迹。”我知道，这世上的确没有什么不可能的事情。 我从来不知道压力大到一定程度时居然可以把人的潜力激发到那种地步的。我是一个极其不安分的人，可是那段时间我表现得无比耐心沉稳，踏实得象头老黄牛。事实上无数次我都面临崩溃的边缘了，高中五本历史书我翻来覆去背了整整六遍。当你把一本书也背上六遍的时候你就知道那时什么感觉了。边背边掉眼泪，真的我是差一点就背不下去了就要把书扔掉了。只是，忍不住的时候，再忍一下。坚持的确是世界上最伟大的一种品质。那段时间我唯一的休息方式就是站在走廊里看远处的天空。后来发现在对面的建筑墙壁上有一行大大的红字，是学校用来激励学生的吧，我不确定。可就是那句话陪我走过了高三最后的日子——意志的力量，是决定成败的力量。我用我所有的经历和体会去实践而且证明了这句话：意志的力量，是决定成败的力量。 呼啸而至的风卷着漫天的黄沙，在那个北方的春天里，我们一个个头发蓬乱，皮肤粗糙。死寂与喧嚣交替如同美国的执政党，规律得让人怀疑冥冥之中可有双奇异而魔力无穷的手。惶然而又茫然的我们在敬畏与期待中迎来又送走了一模、二模以至N模，每根神经都被冷酷无情的现实锤炼得坚不可摧，不论是吟惯了杨柳岸晓风残月的诗情，还是习惯了信手涂鸦的画意。在这个来去匆匆的季节里，一切敏感纤细都奢侈得如同恺撒大帝的稠衣，徒留无数次的希望在无数次的失望前撞得粉身碎骨，无数次的激扬在无数次的颓丧下摔得头破血流。每个人都比昨天更加明白理想和现实之间那道不可逾越的鸿沟，同时也比昨天更加拼命努力挣扎，试图挤过那道窄窄的独木桥，哪怕明知是徒劳。——-会是徒劳么？当这个锥心的问号在夜阑人静的时候一次次猛烈扣击起了心门，每个人都难以承受那潮涌而至的恐慌和迷惘，于是逼着自己埋进去，埋进书本，埋进试卷，埋进密不透风的黑茧——为的只是有朝一日的破茧成蝶。青黑的眼圈，浮肿的眼带，干燥的手指，焦虑得起了水泡的嘴角。那个春天我不知道流行的是粉蓝果绿还是黛紫银灰。小镜子被悄悄收起，因为不忍见到自己憔悴的面容和黯淡的眼睛，因为怕有什么会在汪洋恣意般在干旱已久的脸上纵横开来——上帝，我是个女孩子啊。 上帝无言。无言微笑。微笑告诉我，你，心甘情愿。是的。我心甘情愿我不悔初衷我自己选择了这条路平坦也好崎岖也罢我得走下去。我要走下去。我会走下去。 于是所有的呐喊被咽下去，于是所有的豪情被收起来。我象一头二月黄牛，默默踏步，无声前行。当拼搏被拼命所取代时，香格里拉已经幻化为心中恒远而朦胧的梦想，而所有的努力也只是为了让这梦想不再“美人如花隔去端”，哪怕青冥长天，纵然绿水波澜。 踏入考场的时候后我很平静。“尽吾志也而不能至者，可以无悔矣。”事实上我从来没有想过自己会考入北大以外的哪所学校。与其说这是一种自信，莫如说这是一种预感。我只是想，哪怕北大只招一个名额，为什么不可能是我？这世上没有什么事情是真正不可能发生的。 考完后走在回家的路上，看着依然匆匆的人群，心里依然空无着落。眼睛因为泪雾而模糊，视野里的东西却越发清晰。这在科学上有解释，我却宁愿相信是因为一切真实的感知都要以泪水和苦痛作为代价。是的，我们总是要学会放弃一些东西，才能得到另外一些东西。如果你所在乎的东西值得你为它而付出一切，那么所有的放弃都只是分娩前的阵痛。总要有所取舍的，蝴蝶的生命之所以如此短暂，因为它的翅膀太过精致了。有时候，放弃只是为了真正的得到，关键看你想要的究竟是什么，以及为了这想要的的东西你愿意付出多大的代价。上帝对每一个人都是平等的。 事实上我怀念那段日子，并且永远感激它。不只是因为在那段时间里我完成了自己的过渡与蜕变，更是因为那时的一切深深烙在了我正处于可塑期的性格中，成为这一生永远的财富。那真的是多少钱都买不来的财富。人生中再也不会有哪个时期像那时一样专一地，单纯地，坚决地，几近固执而又饱含信仰和希冀地，心无旁贷乃至与世隔绝地，为了一个认定的目标而奋斗。当你在若干年后某个悠闲的下午，回想起自己曾经的努力和放弃，曾经的坚忍和耐力，曾经的执著和付出，曾经的汗水和泪水，那会是怎样一种感动和庆幸，怎样一种欣慰和尊敬——尊敬你自己。是的，在这个过程中，请允许我重复一遍，最重要的，是你自己。我感谢父母感谢老师感谢同学感谢朋友感谢所有关心我帮助我的人，但我最感谢的，是我自己。Nothing is impossible.这是我在一点一滴的努力与尝试中获得到的东西。而且我也相信，这也将会是使我终生受益的东西。在这里，我把自己最信仰的一句话送给大家： Nothing is impossible.","categories":[{"name":"其他","slug":"其他","permalink":"https://goodhelp.gitee.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"视频","slug":"视频","permalink":"https://goodhelp.gitee.io/tags/%E8%A7%86%E9%A2%91/"},{"name":"励志视频","slug":"励志视频","permalink":"https://goodhelp.gitee.io/tags/%E5%8A%B1%E5%BF%97%E8%A7%86%E9%A2%91/"}]},{"title":"BBC拍的中国春节，中国新年视频","slug":"other/BBC拍的中国春节，中国新年视频","date":"2018-01-04T14:11:13.000Z","updated":"2021-09-16T23:48:33.327Z","comments":true,"path":"page/3669695729/","link":"","permalink":"https://goodhelp.gitee.io/page/3669695729/","excerpt":"《中国春节》是英国广播公司（BBC）2015年12月拍摄的三集纪录片，用镜头聚焦“亿万中国人同时迁徙的壮观。在开篇，三位主持人开门见山地为网友介绍了中国的农历新年。可能买不到票，可能坐上没有座位的火车，可能要在人堆里挤上三天三夜，但这都不能阻止中国人回家过年的愿望。 1.《中国新年》第一集《回家》主要讲述了在中国传统文化和家庭观念的影响下，中国人通过火车、飞机、摩托车不同方式回家过年的故事，介绍了中国为保障春节期间人们顺利出行所做的准备，同时对中国哈尔滨冰雪节、蔚县打树花等春节文化进行了展示。主持人还特意到云南白马雪山探寻金丝猴的保护情况，介绍中国12属相文化。 2.《中国新年》第二集《团圆》主要介绍中国家庭春节期间的传统风俗习惯，包括包饺子、贴春联、看春晚、放烟花、摆鲜花以及祈福等，通过照全家福等生动的故事体现了中国人家庭的团圆和温暖，而在蔬菜批发市场的采购过程又体现了现代中国生活的富足。 3.《中国新年》第三集《欢庆》从中国最南端的香港到最北端的查干湖，从北京的庙会到香港维多利亚港的焰火，体现了遍布中国大江南北的欢乐祥和气氛，介绍了中国的饮食文化和舞龙舞狮等民俗文化。特别是本集里客观地介绍了香港1997年回归和一国两制的理念，并把香港本土文化作为中国文化的一部分展示给海外观众。","text":"《中国春节》是英国广播公司（BBC）2015年12月拍摄的三集纪录片，用镜头聚焦“亿万中国人同时迁徙的壮观。在开篇，三位主持人开门见山地为网友介绍了中国的农历新年。可能买不到票，可能坐上没有座位的火车，可能要在人堆里挤上三天三夜，但这都不能阻止中国人回家过年的愿望。 1.《中国新年》第一集《回家》主要讲述了在中国传统文化和家庭观念的影响下，中国人通过火车、飞机、摩托车不同方式回家过年的故事，介绍了中国为保障春节期间人们顺利出行所做的准备，同时对中国哈尔滨冰雪节、蔚县打树花等春节文化进行了展示。主持人还特意到云南白马雪山探寻金丝猴的保护情况，介绍中国12属相文化。 2.《中国新年》第二集《团圆》主要介绍中国家庭春节期间的传统风俗习惯，包括包饺子、贴春联、看春晚、放烟花、摆鲜花以及祈福等，通过照全家福等生动的故事体现了中国人家庭的团圆和温暖，而在蔬菜批发市场的采购过程又体现了现代中国生活的富足。 3.《中国新年》第三集《欢庆》从中国最南端的香港到最北端的查干湖，从北京的庙会到香港维多利亚港的焰火，体现了遍布中国大江南北的欢乐祥和气氛，介绍了中国的饮食文化和舞龙舞狮等民俗文化。特别是本集里客观地介绍了香港1997年回归和一国两制的理念，并把香港本土文化作为中国文化的一部分展示给海外观众。","categories":[{"name":"其他","slug":"其他","permalink":"https://goodhelp.gitee.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"春节视频","slug":"春节视频","permalink":"https://goodhelp.gitee.io/tags/%E6%98%A5%E8%8A%82%E8%A7%86%E9%A2%91/"},{"name":"新年视频","slug":"新年视频","permalink":"https://goodhelp.gitee.io/tags/%E6%96%B0%E5%B9%B4%E8%A7%86%E9%A2%91/"},{"name":"视频","slug":"视频","permalink":"https://goodhelp.gitee.io/tags/%E8%A7%86%E9%A2%91/"}]},{"title":"Your world within在你的世界激励视频","slug":"other/yourworldwithin在你的世界激励视频","date":"2018-01-04T14:11:13.000Z","updated":"2021-09-16T23:48:13.491Z","comments":true,"path":"page/3089788148/","link":"","permalink":"https://goodhelp.gitee.io/page/3089788148/","excerpt":"其实很多时候，我们并非跟任何人博弈，我们只要努力的战胜自己，所以才会觉得疲惫。战胜别人，需要的是不断的斗志和勇气；而战胜自己，需要的确实坚守的意志和决心。没有梦想的人，是可怕的；就好像一个人没有信仰。我要赚好多好多钱，可是好多好多又是多少？是一百万，一千万还是一个亿？我要好好谈一场恋爱，可是好好谈一场恋爱的标准又是什么？是愿得一心人，白首不相离；是即使曾经沧海难为水，却依旧七月七日长生殿，还是众里寻他千百度，那人却在灯火阑珊处？ 您的浏览器不支持HTML5的 video 标签，无法为您播放！","text":"其实很多时候，我们并非跟任何人博弈，我们只要努力的战胜自己，所以才会觉得疲惫。战胜别人，需要的是不断的斗志和勇气；而战胜自己，需要的确实坚守的意志和决心。没有梦想的人，是可怕的；就好像一个人没有信仰。我要赚好多好多钱，可是好多好多又是多少？是一百万，一千万还是一个亿？我要好好谈一场恋爱，可是好好谈一场恋爱的标准又是什么？是愿得一心人，白首不相离；是即使曾经沧海难为水，却依旧七月七日长生殿，还是众里寻他千百度，那人却在灯火阑珊处？ 您的浏览器不支持HTML5的 video 标签，无法为您播放！","categories":[{"name":"其他","slug":"其他","permalink":"https://goodhelp.gitee.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"视频","slug":"视频","permalink":"https://goodhelp.gitee.io/tags/%E8%A7%86%E9%A2%91/"},{"name":"励志视频","slug":"励志视频","permalink":"https://goodhelp.gitee.io/tags/%E5%8A%B1%E5%BF%97%E8%A7%86%E9%A2%91/"}]},{"title":"time小青龙伴奏MP3下载","slug":"other/time小青龙伴奏MP3下载","date":"2018-01-01T14:05:59.000Z","updated":"2021-09-16T23:48:20.303Z","comments":true,"path":"page/3091515898/","link":"","permalink":"https://goodhelp.gitee.io/page/3091515898/","excerpt":"中国有嘻哈选手歌曲time 小青龙VS辉子time原唱小青龙和辉子，虽然两位老铁淘汰了，但是这首歌还是很感人!小青龙 辉子 time 高品质伴奏下载，纯净，无干扰，纯音乐伴奏，无人声!下载地址 链接：https://pan.baidu.com/s/1pLMIF8Z 密码：g1w2 附上time的歌词当我没日没夜工作从长水起飞 时间反复催促让我忘了疲惫 那心酸的滋味我只能独自体会 想要回到过去但是时光不能倒退 校门口美味的路边摊还在不在 包里塞的小吃那是外婆给的爱 那年生日同桌攒钱给我买的卡带 包装粗糙海报写着JAY 那些年做过的课间操","text":"中国有嘻哈选手歌曲time 小青龙VS辉子time原唱小青龙和辉子，虽然两位老铁淘汰了，但是这首歌还是很感人!小青龙 辉子 time 高品质伴奏下载，纯净，无干扰，纯音乐伴奏，无人声!下载地址 链接：https://pan.baidu.com/s/1pLMIF8Z 密码：g1w2 附上time的歌词当我没日没夜工作从长水起飞 时间反复催促让我忘了疲惫 那心酸的滋味我只能独自体会 想要回到过去但是时光不能倒退 校门口美味的路边摊还在不在 包里塞的小吃那是外婆给的爱 那年生日同桌攒钱给我买的卡带 包装粗糙海报写着JAY 那些年做过的课间操 课桌上面摆着老师送的铅笔刀 她教我如何起跑 我闭上双眼祈祷 我知道努力学习以后才能把歌写好 于是日复一日 年复一年 那个美丽的春天早已变成我的纪念 我渐渐长大成人 眼看着世界沉沦 就算我是个战神可我心也一样会疼 再没骗自己的理由 时间如刀不再温柔 一路走 汗在流 再回首 已没有 那双扶着我不跌倒的手 走尽春夏秋冬 天南地北 母亲已经白头 我也 不再 年幼 我发现我早已经长大 我发现我早不说谎话 特别的怀念 回到童年 可我只能把握现在 带着回不去的从前 街边的落日 和小时候的复读机 度过了末日 但我要比以前有出息 小霸王游戏机 陪我度过了一段时期 经典的就像是old school flow 从不用质疑 改变不了过去 那我为了现在出征 我不会为了Hip-hop死 但为了Hip-hop出生 所以我努力的跑 把一切全部看透 我想让我爱的人过的更好 所以才去战斗 脱掉了曾经 认为很时尚的大肥裤子 到现在 我依旧做说唱还在饿着肚子 回忆是每个人的财富 一定记住他 不用问我的来路 贫民窟的艺术家 再没骗自己的理由 时间如刀不再温柔 一路走 汗在流 再回首 已没有 那双扶着我不跌倒的手 走尽春夏秋冬 天南地北 母亲已经白头 我也 不再 年幼","categories":[{"name":"其他","slug":"其他","permalink":"https://goodhelp.gitee.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"time小青龙伴奏","slug":"time小青龙伴奏","permalink":"https://goodhelp.gitee.io/tags/time%E5%B0%8F%E9%9D%92%E9%BE%99%E4%BC%B4%E5%A5%8F/"},{"name":"音乐","slug":"音乐","permalink":"https://goodhelp.gitee.io/tags/%E9%9F%B3%E4%B9%90/"}]},{"title":"delphi中如何设置dcef3的代理服务器setproxy?","slug":"article/delphi中如何设置dcef3的代理服务器setproxy","date":"2017-12-30T02:32:08.000Z","updated":"2021-09-16T23:40:20.029Z","comments":true,"path":"page/3680656161/","link":"","permalink":"https://goodhelp.gitee.io/page/3680656161/","excerpt":"代理服务器（Proxy Server）是一种重要的服务器安全功能，它的工作主要在开放系统互联(OSI)模型的会话层，从而起到防火墙的作用。代理服务器大多被用来连接INTERNET（国际互联网）和Local Area Network（局域网）。delphi中的tChromium控件dcef3如何设置代理服务器呢？ delphi中webbrowser设置代理服务器是这样的!1234567891011121314151617&#123;------------------------------------------------------------------------------- 过程名: SetProcessProxy 作者: kelei 日期: 2013.08.03 参数: aProxyServer代理服务器; aProxyPort代理服务器端口 返回值: True设置成功 SetProcessProxy(&#x27;127.0.0.1&#x27;, 80);-------------------------------------------------------------------------------&#125;function SetProcessProxy(const aProxyServer: string; const aProxyPort: Integer): Boolean;var vProxyInfo: TInternetProxyInfo;begin vProxyInfo.dwAccessType := INTERNET_OPEN_TYPE_PROXY; vProxyInfo.lpszProxy := PChar(Format(&#x27;http=%s:%d&#x27;, [aProxyServer, aProxyPort])); vProxyInfo.lpszProxyBypass := PChar(&#x27;&#x27;); Result := UrlMkSetSessionOption(INTERNET_OPTION_PROXY, @vProxyInfo, SizeOf(vProxyInfo, 0) = S_OK;end; 在dcef3中如何静态设置代理服务器呢？静态设置方法在dpr中添加启动命令行参数，如果不添加命令行参数设置代理服务器，那么dcef3默认是使用的ie的代理服务器：123456789101112131415161718192021222324procedure AppendCefCmdline(const processType: ustring; const cmd: ICefCommandLine);begin cmd.AppendSwitchWithValue(&#x27;proxy-server&#x27;,&#x27;http://218.189.26.20:8080&#x27;);//设置http代理服务器 cmd.AppendSwitchWithValue(&#x27;proxy-server&#x27;,&#x27;https://218.189.26.20:8082&#x27;);//设置https代理服务器 cmd.AppendSwitchWithValue(&#x27;proxy-server&#x27;,&#x27;ftp://218.189.26.20:21&#x27;);//设置ftp代理服务器 cmd.AppendSwitchWithValue(&#x27;proxy-server&#x27;,&#x27;socks://202.116.0.188:3128&#x27;)//设置SOCKS代理服务器 cmd.AppendSwitchWithValue(&#x27;proxy-server&#x27;,&#x27;sock4://202.116.0.188:1080&#x27;)//设置sock4代理服务器 cmd.AppendSwitchWithValue(&#x27;proxy-server&#x27;,&#x27;sock5://202.116.0.188:1081&#x27;)//设置sock5代理服务器//cmd.AppendSwitchWithValue(&#x27;proxy-server&#x27;,&#x27;direct://&#x27;)//所有连接不使用代理//cmd.AppendSwitchWithValue(&#x27;proxy-server&#x27;,&#x27;https=127.0.0.1:80;http=socks4://bnwin.com:1080&#x27;)//同时设置https和sock4代理服务器 cmd.AppendSwitchWithValue(&#x27;proxy-bypass-list&#x27;,&#x27;127.*,192.168.*,10.10.*,193.9.162.*&#x27;);//不使用代理服务器的地址//cmd.AppendSwitch(&#x27;--no-proxy-server&#x27;);//禁止代理服务器//cmd.AppendSwitch(&#x27;--proxy-auto-detect&#x27;);//自动检测代理配置//cmd.AppendSwitchWithValue(&#x27;proxy-pac-url&#x27;,&#x27;http://www.bnwinn.com/proxy.pac&#x27;)//代理使用指定URL中的PAC文件//cmd.AppendSwitch(&#x27;--winhttp-proxy-resolver&#x27;);//代理在IE中运行正常,但在chrome中失败，可以添加此flagend; begin CefOnBeforeCommandLineProcessing :=AppendCefCmdline; //指定dcef启动命令行 Application.Initialize; Application.MainFormOnTaskbar := True; Application.CreateForm(TMainForm, MainForm); Application.Run;end. 在dcef3中如何动态设置代理服务器setproxy？前面已经说过，如果不在命令行中设置代理服务器，那么dcef是默认使用的ie代理服务器，要想动态设置代理服务器，我们不在dcef的命令行参数设置代理，然后使用开头的动态设置ie代理服务器的代码，dcef3的代理服务器就是动态的了！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556System network settingsThe Chromium network stack uses the system network settings so that users and administrators can control the network settings of all applications easily. The network settings include:proxy settingsSSL/TLS settingscertificate revocation check settingscertificate and private key storesSo far this design decision has worked well. The only network settings that some users ask for an alternative to system settings are proxy settings. For this we recently added some command-line options that allow you to run Chromium with custom proxy settings.Preference service for network settingsAlthough the system network settings have been sufficient for our network stack, eventually there will be some configuration settings specific to our network stack, so we need to have our own preference service for those settings. See also issue 266, in which some Firefox users demand that we not use the WinInet proxy settings (the de facto system proxy settings on Windows).Command-line options for proxy settingsChrome supports the following proxy-related command line arguments:–no-proxy-serverThis tells Chrome not to use a Proxy. It overrides any other proxy settings provided.–proxy-auto-detectThis tells Chrome to try and automatically detect your proxy configuration. This flag is ignored if –proxy-server is also provided.–proxy-server==[:][;…] | [:] | “direct://”This tells Chrome to use a custom proxy configuration. You can specify a custom proxy configuration in three ways:1) By providing a semi-colon-separated mapping of list scheme to url/port pairs.For example, you can specify:–proxy-server=”http=foopy:80;ftp=foopy2″to use HTTP proxy “foopy:80” for http URLs and HTTP proxy “foopy2:80″ for ftp URLs.2) By providing a single uri with optional port to use for all URLs.For example:–proxy-server=”foopy:8080”will use the proxy at foopy:8080 for all traffic.3) By using the special “direct://” value.–proxy-server=”direct://” will cause all connections to not use a proxy.–proxy-bypass-list=(|)[:][;…]This tells chrome to bypass any specified proxy for the given semi-colon-separated list of hosts. This flag must be used (or rather, only has an effect) in tandem with –proxy-server.Note that trailing-domain matching doesn’t require “.” separators so “*google.com” will match “igoogle.com” for example.For example,–proxy-server=”foopy:8080″ –proxy-bypass-list=”*.google.com;*foo.com;127.0.0.1:8080″will use the proxy server “foopy” on port 8080 for all hosts except those pointing to *.google.com, those pointing to *foo.com and those pointing to localhost on port 8080.igoogle.com requests would still be proxied. ifoo.com requests would not be proxied since *foo, not *.foo was specified.–proxy-pac-url=This tells Chrome to use the PAC file at the specified URL.For example,–proxy-pac-url=”http://wpad/windows.pac”will tell Chrome to resolve proxy information for URL requests using the windows.pac file.","text":"代理服务器（Proxy Server）是一种重要的服务器安全功能，它的工作主要在开放系统互联(OSI)模型的会话层，从而起到防火墙的作用。代理服务器大多被用来连接INTERNET（国际互联网）和Local Area Network（局域网）。delphi中的tChromium控件dcef3如何设置代理服务器呢？ delphi中webbrowser设置代理服务器是这样的!1234567891011121314151617&#123;------------------------------------------------------------------------------- 过程名: SetProcessProxy 作者: kelei 日期: 2013.08.03 参数: aProxyServer代理服务器; aProxyPort代理服务器端口 返回值: True设置成功 SetProcessProxy(&#x27;127.0.0.1&#x27;, 80);-------------------------------------------------------------------------------&#125;function SetProcessProxy(const aProxyServer: string; const aProxyPort: Integer): Boolean;var vProxyInfo: TInternetProxyInfo;begin vProxyInfo.dwAccessType := INTERNET_OPEN_TYPE_PROXY; vProxyInfo.lpszProxy := PChar(Format(&#x27;http=%s:%d&#x27;, [aProxyServer, aProxyPort])); vProxyInfo.lpszProxyBypass := PChar(&#x27;&#x27;); Result := UrlMkSetSessionOption(INTERNET_OPTION_PROXY, @vProxyInfo, SizeOf(vProxyInfo, 0) = S_OK;end; 在dcef3中如何静态设置代理服务器呢？静态设置方法在dpr中添加启动命令行参数，如果不添加命令行参数设置代理服务器，那么dcef3默认是使用的ie的代理服务器：123456789101112131415161718192021222324procedure AppendCefCmdline(const processType: ustring; const cmd: ICefCommandLine);begin cmd.AppendSwitchWithValue(&#x27;proxy-server&#x27;,&#x27;http://218.189.26.20:8080&#x27;);//设置http代理服务器 cmd.AppendSwitchWithValue(&#x27;proxy-server&#x27;,&#x27;https://218.189.26.20:8082&#x27;);//设置https代理服务器 cmd.AppendSwitchWithValue(&#x27;proxy-server&#x27;,&#x27;ftp://218.189.26.20:21&#x27;);//设置ftp代理服务器 cmd.AppendSwitchWithValue(&#x27;proxy-server&#x27;,&#x27;socks://202.116.0.188:3128&#x27;)//设置SOCKS代理服务器 cmd.AppendSwitchWithValue(&#x27;proxy-server&#x27;,&#x27;sock4://202.116.0.188:1080&#x27;)//设置sock4代理服务器 cmd.AppendSwitchWithValue(&#x27;proxy-server&#x27;,&#x27;sock5://202.116.0.188:1081&#x27;)//设置sock5代理服务器//cmd.AppendSwitchWithValue(&#x27;proxy-server&#x27;,&#x27;direct://&#x27;)//所有连接不使用代理//cmd.AppendSwitchWithValue(&#x27;proxy-server&#x27;,&#x27;https=127.0.0.1:80;http=socks4://bnwin.com:1080&#x27;)//同时设置https和sock4代理服务器 cmd.AppendSwitchWithValue(&#x27;proxy-bypass-list&#x27;,&#x27;127.*,192.168.*,10.10.*,193.9.162.*&#x27;);//不使用代理服务器的地址//cmd.AppendSwitch(&#x27;--no-proxy-server&#x27;);//禁止代理服务器//cmd.AppendSwitch(&#x27;--proxy-auto-detect&#x27;);//自动检测代理配置//cmd.AppendSwitchWithValue(&#x27;proxy-pac-url&#x27;,&#x27;http://www.bnwinn.com/proxy.pac&#x27;)//代理使用指定URL中的PAC文件//cmd.AppendSwitch(&#x27;--winhttp-proxy-resolver&#x27;);//代理在IE中运行正常,但在chrome中失败，可以添加此flagend; begin CefOnBeforeCommandLineProcessing :=AppendCefCmdline; //指定dcef启动命令行 Application.Initialize; Application.MainFormOnTaskbar := True; Application.CreateForm(TMainForm, MainForm); Application.Run;end. 在dcef3中如何动态设置代理服务器setproxy？前面已经说过，如果不在命令行中设置代理服务器，那么dcef是默认使用的ie代理服务器，要想动态设置代理服务器，我们不在dcef的命令行参数设置代理，然后使用开头的动态设置ie代理服务器的代码，dcef3的代理服务器就是动态的了！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556System network settingsThe Chromium network stack uses the system network settings so that users and administrators can control the network settings of all applications easily. The network settings include:proxy settingsSSL/TLS settingscertificate revocation check settingscertificate and private key storesSo far this design decision has worked well. The only network settings that some users ask for an alternative to system settings are proxy settings. For this we recently added some command-line options that allow you to run Chromium with custom proxy settings.Preference service for network settingsAlthough the system network settings have been sufficient for our network stack, eventually there will be some configuration settings specific to our network stack, so we need to have our own preference service for those settings. See also issue 266, in which some Firefox users demand that we not use the WinInet proxy settings (the de facto system proxy settings on Windows).Command-line options for proxy settingsChrome supports the following proxy-related command line arguments:–no-proxy-serverThis tells Chrome not to use a Proxy. It overrides any other proxy settings provided.–proxy-auto-detectThis tells Chrome to try and automatically detect your proxy configuration. This flag is ignored if –proxy-server is also provided.–proxy-server==[:][;…] | [:] | “direct://”This tells Chrome to use a custom proxy configuration. You can specify a custom proxy configuration in three ways:1) By providing a semi-colon-separated mapping of list scheme to url/port pairs.For example, you can specify:–proxy-server=”http=foopy:80;ftp=foopy2″to use HTTP proxy “foopy:80” for http URLs and HTTP proxy “foopy2:80″ for ftp URLs.2) By providing a single uri with optional port to use for all URLs.For example:–proxy-server=”foopy:8080”will use the proxy at foopy:8080 for all traffic.3) By using the special “direct://” value.–proxy-server=”direct://” will cause all connections to not use a proxy.–proxy-bypass-list=(|)[:][;…]This tells chrome to bypass any specified proxy for the given semi-colon-separated list of hosts. This flag must be used (or rather, only has an effect) in tandem with –proxy-server.Note that trailing-domain matching doesn’t require “.” separators so “*google.com” will match “igoogle.com” for example.For example,–proxy-server=”foopy:8080″ –proxy-bypass-list=”*.google.com;*foo.com;127.0.0.1:8080″will use the proxy server “foopy” on port 8080 for all hosts except those pointing to *.google.com, those pointing to *foo.com and those pointing to localhost on port 8080.igoogle.com requests would still be proxied. ifoo.com requests would not be proxied since *foo, not *.foo was specified.–proxy-pac-url=This tells Chrome to use the PAC file at the specified URL.For example,–proxy-pac-url=”http://wpad/windows.pac”will tell Chrome to resolve proxy information for URL requests using the windows.pac file.","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"delphi技巧","slug":"delphi技巧","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%8A%80%E5%B7%A7/"},{"name":"dcef3使用方法","slug":"dcef3使用方法","permalink":"https://goodhelp.gitee.io/tags/dcef3%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"}]},{"title":"不要小看自己的力量励志视频","slug":"other/不要小看自己的力量励志视频","date":"2017-12-29T13:48:19.000Z","updated":"2021-09-16T23:49:24.408Z","comments":true,"path":"page/1444890423/","link":"","permalink":"https://goodhelp.gitee.io/page/1444890423/","excerpt":"不要小看自己的力量励志视频你可以改变世界。你每天都可以用善行和爱来充满你的生活。你也许不能消除世界饥饿，但你可以捐献50磅食品，从而让一个家庭免遭饥饿一个月。你也许不能给世界带来和平，但你可以把你的和平精神带给你周围的世界。你也许不能驱走所有人心中的仇恨和黑暗，但你可以把你内心中的爱和光拿出来与人共享。 您的浏览器不支持HTML5的 video 标签，无法为您播放！","text":"不要小看自己的力量励志视频你可以改变世界。你每天都可以用善行和爱来充满你的生活。你也许不能消除世界饥饿，但你可以捐献50磅食品，从而让一个家庭免遭饥饿一个月。你也许不能给世界带来和平，但你可以把你的和平精神带给你周围的世界。你也许不能驱走所有人心中的仇恨和黑暗，但你可以把你内心中的爱和光拿出来与人共享。 您的浏览器不支持HTML5的 video 标签，无法为您播放！","categories":[{"name":"其他","slug":"其他","permalink":"https://goodhelp.gitee.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"视频","slug":"视频","permalink":"https://goodhelp.gitee.io/tags/%E8%A7%86%E9%A2%91/"},{"name":"励志视频","slug":"励志视频","permalink":"https://goodhelp.gitee.io/tags/%E5%8A%B1%E5%BF%97%E8%A7%86%E9%A2%91/"}]},{"title":"绝地求生pubg黑屏补丁、内存优化、画质优化工具","slug":"soft/绝地求生pubg黑屏补丁、内存优化、画质优化工具","date":"2017-12-28T13:40:12.000Z","updated":"2021-09-11T16:45:22.708Z","comments":true,"path":"page/1983881970/","link":"","permalink":"https://goodhelp.gitee.io/page/1983881970/","excerpt":"本绝地求生工具包括内存优化，画质增强(reshade)，黑屏补丁，跳VC插件检测功能！ 本绝地求生pubg黑屏补丁和内存优化补丁特点:此黑屏补丁，不需要开机运行，绝地求生运行时运行本补丁即可，试想，开机运行的黑屏补丁，顾客不玩绝地求生你也运行？不是问题？黑屏补丁不管你在盖伦或是云更新下载的绝地求生，只要是绝地求生就行，本黑屏补丁直接检测游戏本身!内存优化，在游戏中不会出现卡顿现象，内存优化不会回收绝地大逃杀已经使用的内存，只回收非绝地求生程序所占的内存，本来内存优化就是把内存给绝地求生使用， 你再回收绝地求生的内存，会不会造成游戏中卡一下，你自己都想象得到!有些顾客先玩几把英雄联盟，再玩一会儿穿越火线，然后朋友一起约起玩绝地大逃杀，大家都知道腾讯的游戏退出并不是运行游戏时启动的程序在退出时都会退出，并且有些顾客根本就不退出英雄联盟等游戏，就直接运行绝地大逃杀，在你只有8G内存的情况下，顾客就会甩鼠标，拍键盘，说你机器卡得不得了!关键是他开机运行了什么？所以本内存优化补丁会直接优化这些根本不是当前需要运行的程序所占内存!使用所谓的内存优化专家，也是会收回绝地求生所占内存，游戏中也是会卡一下的，他是不会区分的！使用本补丁，无盘系统8G内存，回写缓存设置1G，一直玩绝地求生，不重启不卡! 绝地大逃杀pubg黑屏问题，在绝地大逃杀pc3.5.5更新后，到现在pc3.5.7都存在运行绝地大逃杀会一直黑屏，鼠标要点一下才会进入游戏，这影响了用户的体验，不明白的玩家会认为是机器配置问题，我们来看看这个现象，看有黑屏的动画 使用pubg黑屏补丁，解决后没有黑屏的动画 一直快速进入游戏界面！ 绝地求生画质增强(reshade)功能,本功能集成官方认可的reshade画质增强插件，运行时在Steam登录窗口显示按钮，由用户自由选择是否开启reshade画质增强!不需要去下载安装reshade，不需要你为了使用reshace去设置找pubg的路径，全自动启用reshade画质插件，退出本绝地求生工具，自动清理reshade文件，不留痕迹，不会影响原本的pubg环境! 同时本绝地求生工具具有windows优化大师的内存优化功能，可以设置小于多少内存的，多少分钟并且物理内存使用率超过91%进行一次内存回收，留出更多的物理内存给绝地大逃杀pubg使用。本绝地求生工具的内存优化，优化时游戏中不会出现卡顿情况! 绝地大逃杀pubg内存优化补丁的原理，使用了SetProcessWorkingSetSize函数，把物理内存占用存在虚拟内存上，windows的这个SetProcessWorkingSetSize函数来设置应用程序最小和最大的运行空间，只会保留需要的内存。当应用程序被闲置或系统内存太低时，操作系统会自动调用这个机制来设置应用程序的内存。如果你的物理内存小于8G，可以使用本补丁进行优化，如果你16G内存就不需要使用了！此种优化内存并非优秀的方法，市面上的优化内存软件基本使用此原理，最优秀的方法是添加物理内存！ 使用方法：运行绝地大逃杀时启动本绝地求生工具的setup.exe文件即可，你可以在游戏菜单中进行设置!steam退出，本补丁自动退出！ 其中的配置文件设置说明(如果删除config.ini配置文件，就是只使用pubg黑屏补丁！) [setup];启用clearmemory后内存小于memorysize设定的多少G，每cleartime设置的分钟优化一次内存占用,1为启用 0为禁用，默认为0;启用内存清理的前提条件是，pubg游戏在运行，并且物理内存使用率超过91%clearmemory=0memorysize=9cleartime=2;启用blackpatch＝1，启动pubg没有黑屏，直接进界面，0为不处理，默认为1;用于pubg pc 3.5.5版，如果后续版本无黑屏就可以不启动blackpatch=1;跳过安装vc2008 2010 2012 2013 2015 2017和dx2010 PhysX,1为跳过安装并且设置steam为中文，0为不处理，默认为0skipplug=1;reshade画质增强补丁 1为开启，0为不开启，默认为0，进入游戏后shift+F2呼出reshade界面reshade=0 下载地址: 1.不带reshade画质增强插件功能的下载地址 链接: https://pan.baidu.com/s/1oAiMaoE 密码: g8ie 解压密码 bnwin.com 启动方式：绝地求生启动前运行pubgtool.exe 2.具有绝地求生reshade画质增强插件功能的下载地址 链接：https://pan.baidu.com/s/1eTOJ7gu 密码：phm0 解压密码 bnwin.com 附加提供游戏加加的绝地求生助手的reshade画质配置文件,游戏加加的绝地求生助手对绝地求生的画质优化也是集成的reshade，如果你显卡比较好，可以用绝地求生助手的ini替换掉bnwin.ini，就可以使用绝地求生助手的画质设置效果!游戏加加的reshade配置文件下载: 链接：https://pan.baidu.com/s/1dG20VEL 密码：0x8a 解压密码 bnwin.com 使用游戏加加的reshade配置的方法：","text":"本绝地求生工具包括内存优化，画质增强(reshade)，黑屏补丁，跳VC插件检测功能！ 本绝地求生pubg黑屏补丁和内存优化补丁特点:此黑屏补丁，不需要开机运行，绝地求生运行时运行本补丁即可，试想，开机运行的黑屏补丁，顾客不玩绝地求生你也运行？不是问题？黑屏补丁不管你在盖伦或是云更新下载的绝地求生，只要是绝地求生就行，本黑屏补丁直接检测游戏本身!内存优化，在游戏中不会出现卡顿现象，内存优化不会回收绝地大逃杀已经使用的内存，只回收非绝地求生程序所占的内存，本来内存优化就是把内存给绝地求生使用， 你再回收绝地求生的内存，会不会造成游戏中卡一下，你自己都想象得到!有些顾客先玩几把英雄联盟，再玩一会儿穿越火线，然后朋友一起约起玩绝地大逃杀，大家都知道腾讯的游戏退出并不是运行游戏时启动的程序在退出时都会退出，并且有些顾客根本就不退出英雄联盟等游戏，就直接运行绝地大逃杀，在你只有8G内存的情况下，顾客就会甩鼠标，拍键盘，说你机器卡得不得了!关键是他开机运行了什么？所以本内存优化补丁会直接优化这些根本不是当前需要运行的程序所占内存!使用所谓的内存优化专家，也是会收回绝地求生所占内存，游戏中也是会卡一下的，他是不会区分的！使用本补丁，无盘系统8G内存，回写缓存设置1G，一直玩绝地求生，不重启不卡! 绝地大逃杀pubg黑屏问题，在绝地大逃杀pc3.5.5更新后，到现在pc3.5.7都存在运行绝地大逃杀会一直黑屏，鼠标要点一下才会进入游戏，这影响了用户的体验，不明白的玩家会认为是机器配置问题，我们来看看这个现象，看有黑屏的动画 使用pubg黑屏补丁，解决后没有黑屏的动画 一直快速进入游戏界面！ 绝地求生画质增强(reshade)功能,本功能集成官方认可的reshade画质增强插件，运行时在Steam登录窗口显示按钮，由用户自由选择是否开启reshade画质增强!不需要去下载安装reshade，不需要你为了使用reshace去设置找pubg的路径，全自动启用reshade画质插件，退出本绝地求生工具，自动清理reshade文件，不留痕迹，不会影响原本的pubg环境! 同时本绝地求生工具具有windows优化大师的内存优化功能，可以设置小于多少内存的，多少分钟并且物理内存使用率超过91%进行一次内存回收，留出更多的物理内存给绝地大逃杀pubg使用。本绝地求生工具的内存优化，优化时游戏中不会出现卡顿情况! 绝地大逃杀pubg内存优化补丁的原理，使用了SetProcessWorkingSetSize函数，把物理内存占用存在虚拟内存上，windows的这个SetProcessWorkingSetSize函数来设置应用程序最小和最大的运行空间，只会保留需要的内存。当应用程序被闲置或系统内存太低时，操作系统会自动调用这个机制来设置应用程序的内存。如果你的物理内存小于8G，可以使用本补丁进行优化，如果你16G内存就不需要使用了！此种优化内存并非优秀的方法，市面上的优化内存软件基本使用此原理，最优秀的方法是添加物理内存！ 使用方法：运行绝地大逃杀时启动本绝地求生工具的setup.exe文件即可，你可以在游戏菜单中进行设置!steam退出，本补丁自动退出！ 其中的配置文件设置说明(如果删除config.ini配置文件，就是只使用pubg黑屏补丁！) [setup];启用clearmemory后内存小于memorysize设定的多少G，每cleartime设置的分钟优化一次内存占用,1为启用 0为禁用，默认为0;启用内存清理的前提条件是，pubg游戏在运行，并且物理内存使用率超过91%clearmemory=0memorysize=9cleartime=2;启用blackpatch＝1，启动pubg没有黑屏，直接进界面，0为不处理，默认为1;用于pubg pc 3.5.5版，如果后续版本无黑屏就可以不启动blackpatch=1;跳过安装vc2008 2010 2012 2013 2015 2017和dx2010 PhysX,1为跳过安装并且设置steam为中文，0为不处理，默认为0skipplug=1;reshade画质增强补丁 1为开启，0为不开启，默认为0，进入游戏后shift+F2呼出reshade界面reshade=0 下载地址: 1.不带reshade画质增强插件功能的下载地址 链接: https://pan.baidu.com/s/1oAiMaoE 密码: g8ie 解压密码 bnwin.com 启动方式：绝地求生启动前运行pubgtool.exe 2.具有绝地求生reshade画质增强插件功能的下载地址 链接：https://pan.baidu.com/s/1eTOJ7gu 密码：phm0 解压密码 bnwin.com 附加提供游戏加加的绝地求生助手的reshade画质配置文件,游戏加加的绝地求生助手对绝地求生的画质优化也是集成的reshade，如果你显卡比较好，可以用绝地求生助手的ini替换掉bnwin.ini，就可以使用绝地求生助手的画质设置效果!游戏加加的reshade配置文件下载: 链接：https://pan.baidu.com/s/1dG20VEL 密码：0x8a 解压密码 bnwin.com 使用游戏加加的reshade配置的方法：","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"原创软件","slug":"原创软件","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%9F%E5%88%9B%E8%BD%AF%E4%BB%B6/"}]},{"title":"delphi中如何自定义dcef3的右键菜单？","slug":"article/delphi中如何自定义dcef3的右键菜单？","date":"2017-12-28T02:29:36.000Z","updated":"2021-09-16T23:40:10.439Z","comments":true,"path":"page/3769761372/","link":"","permalink":"https://goodhelp.gitee.io/page/3769761372/","excerpt":"delphi中TChromium控件dcef3的右键菜单默认是这样的如何修改成自己的菜单呢？或者自定义dcef3的右键菜单呢？ 在dcef3窗体中添加TApplicationEvents控件aplctnvnts1! 添加TPopupMenu控件pm1，并设置好自定义的dcef3的右键菜单及功能. 在TApplicationEvents控件的OnMessage事件中添加如下代码。1234567891011procedure TMainForm.aplctnvnts1Message(var Msg: tagMSG; var Handled: Boolean);var mPoint: TPoint;begin if IsChild(chrm1.Handle, Msg.Hwnd) and ((Msg.Message = WM_RBUTTONDOWN) or (Msg.Message = WM_RBUTTONUP)) then begin GetCursorPos(mPoint); //得到光标位置 pm1.Popup(mPoint.X, mPoint.Y); //弹出popupmenu的菜单 Handled := True; end;end; 这样你就不用让用户看TChromium的默认英文右键菜单了!对于TChromium默认右键菜单的功能，可以自己用代码很轻松的实现!","text":"delphi中TChromium控件dcef3的右键菜单默认是这样的如何修改成自己的菜单呢？或者自定义dcef3的右键菜单呢？ 在dcef3窗体中添加TApplicationEvents控件aplctnvnts1! 添加TPopupMenu控件pm1，并设置好自定义的dcef3的右键菜单及功能. 在TApplicationEvents控件的OnMessage事件中添加如下代码。1234567891011procedure TMainForm.aplctnvnts1Message(var Msg: tagMSG; var Handled: Boolean);var mPoint: TPoint;begin if IsChild(chrm1.Handle, Msg.Hwnd) and ((Msg.Message = WM_RBUTTONDOWN) or (Msg.Message = WM_RBUTTONUP)) then begin GetCursorPos(mPoint); //得到光标位置 pm1.Popup(mPoint.X, mPoint.Y); //弹出popupmenu的菜单 Handled := True; end;end; 这样你就不用让用户看TChromium的默认英文右键菜单了!对于TChromium默认右键菜单的功能，可以自己用代码很轻松的实现!","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"delphi技巧","slug":"delphi技巧","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%8A%80%E5%B7%A7/"},{"name":"dcef3使用方法","slug":"dcef3使用方法","permalink":"https://goodhelp.gitee.io/tags/dcef3%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"}]},{"title":"delphi中如何删除dcef3的cookie和缓存？","slug":"article/delphi中如何删除dcef3的cookie和缓存？","date":"2017-12-26T00:50:28.000Z","updated":"2021-09-16T23:40:29.733Z","comments":true,"path":"page/3468945668/","link":"","permalink":"https://goodhelp.gitee.io/page/3468945668/","excerpt":"我们用以下代码打开网站 12345678910var Chromium: TChromium;begin try Chromium := TChromium.Create(nil); Chromium.SetParentComponent(Form1); Chromium.Align := alClient; chromium.Browser.MainFrame.LoadUrl(&#x27;www.bnwin.com&#x27;); FreeAndNil(Chromium)end; 如何删除dcef3的cookie和缓存？请看以下代码 123456789101112131415161718192021222324252627282930313233343536373839type CefTask = class(TCefTaskOwn) procedure Execute; override; public var url,cookieName: ustring; constructor create; virtual; end; constructor CefTask.create;begin inherited create; url := &#x27;&#x27;; cookieName := &#x27;&#x27;;end; procedure CefTask.Execute;var CookieManager: ICefCookieManager;begin CookieManager := TCefCookieManagerRef.Global; CookieManager.DeleteCookies(url,cookieName);end; procedure c_WB_ClearCookies;var Task: CefTask;begin Task := CefTask.Create; CefPostTask(TID_IO, Task);end; // c_WB_Clear_url_Cookies(&#x27;http://google.com&#x27;,&#x27;cookie_name&#x27;);procedure c_WB_Clear_url_Cookies(c_url,c_cookieName: ustring);var Task: CefTask;begin Task := CefTask.Create; Task.url := c_url; Task.cookieName := c_cookieName; CefPostTask(TID_IO, Task);end; 整理自网站 https://stackoverflow.com/questions/12269587/how-do-i-clear-the-cache-and-cookies-for-an-embedded-chromium-browser 取得cookie并显示，如果需要删除cookie，把deleteCookie:= False改为deleteCookie:= True 123456789101112131415161718192021222324252627282930313233343536373839404142434445function VisitCookie (const name, value, domain, path: ustring; secure, httponly, hasExpires: Boolean;const creation, lastAccess, expires: TDateTime; count, total: Integer;out deleteCookie: Boolean): Boolean;begin deleteCookie:= False; MainForm.Memo1.Lines. Add (&#x27; cookie &#x27; +inttostr (count) + &#x27; / &#x27; + inttostr (total)); MainForm.Memo1.Lines. Add (&#x27; name &#x27; +name); MainForm.Memo1.Lines. Add (&#x27; value &#x27; +value); MainForm.Memo1.Lines. Add (&#x27; domain &#x27; +domain); MainForm.Memo1.Lines. Add (&#x27; path &#x27; +path); MainForm.Memo1.Lines. Add (&#x27; secure &#x27; +BoolToStr (secure)); MainForm.Memo1.Lines. Add (&#x27; httponly &#x27; +BoolToStr (httponly)); MainForm.Memo1.Lines. Add (&#x27; hasExpires &#x27; +BoolToStr (hasExpires)); MainForm.Memo1.Lines. Add (&#x27; creation &#x27; +DateToStr (creation)); MainForm.Memo1.Lines. Add (&#x27; lastAccess &#x27; +DateToStr (lastAccess)); MainForm.Memo1.Lines. Add (&#x27; expires &#x27; +DateToStr (expires)); MainForm.Memo1.Lines. Add (&#x27;--------------- &#x27;); Result:= True;end; procedure TMainForm.btn2Click(Sender: TObject);var CookieManager: ICefCookieManager;beginCookieManager:= TCefCookieManagerRef.Global(nil);CookieManager.VisitAllCookiesProc (VisitCookie);end; //这样写，我在delphi xe8中编译不过procedure TMainForm.Button1Click(Sender: TObject);var CookieManager: ICefCookieManager;begin CookieManager := TCefCookieManagerRef.Global(nil); CookieManager.VisitAllCookiesProc( function(const name, value, domain, path: ustring; secure, httponly, hasExpires: Boolean; const creation, lastAccess, expires: TDateTime; count, total: Integer; out deleteCookie: Boolean): Boolean begin deleteCookie := True; ShowMessage(&#x27;A cookie from domain &#x27; + domain + &#x27; will be unmercifully &#x27; + &#x27;deleted!&#x27;); end );end; 为网址设置单独的cookie文件 1234567891011121314CookieManager: ICefCookieManager; FormCreate:begin CookiesPath := ExtractFilePath(Application.ExeName) + &#x27;cookies/bnwin&#x27;; CookieManager := TCefCookieManagerRef.Global(nil); CookieManager.SetStoragePath(CookiesPath, True, nil); Chromium1.Load（&#x27;bnwin.com&#x27;）; end; FormClose: begin CookieManager.FlushStore(nil);end 为指定的网站设置cookie","text":"我们用以下代码打开网站 12345678910var Chromium: TChromium;begin try Chromium := TChromium.Create(nil); Chromium.SetParentComponent(Form1); Chromium.Align := alClient; chromium.Browser.MainFrame.LoadUrl(&#x27;www.bnwin.com&#x27;); FreeAndNil(Chromium)end; 如何删除dcef3的cookie和缓存？请看以下代码 123456789101112131415161718192021222324252627282930313233343536373839type CefTask = class(TCefTaskOwn) procedure Execute; override; public var url,cookieName: ustring; constructor create; virtual; end; constructor CefTask.create;begin inherited create; url := &#x27;&#x27;; cookieName := &#x27;&#x27;;end; procedure CefTask.Execute;var CookieManager: ICefCookieManager;begin CookieManager := TCefCookieManagerRef.Global; CookieManager.DeleteCookies(url,cookieName);end; procedure c_WB_ClearCookies;var Task: CefTask;begin Task := CefTask.Create; CefPostTask(TID_IO, Task);end; // c_WB_Clear_url_Cookies(&#x27;http://google.com&#x27;,&#x27;cookie_name&#x27;);procedure c_WB_Clear_url_Cookies(c_url,c_cookieName: ustring);var Task: CefTask;begin Task := CefTask.Create; Task.url := c_url; Task.cookieName := c_cookieName; CefPostTask(TID_IO, Task);end; 整理自网站 https://stackoverflow.com/questions/12269587/how-do-i-clear-the-cache-and-cookies-for-an-embedded-chromium-browser 取得cookie并显示，如果需要删除cookie，把deleteCookie:= False改为deleteCookie:= True 123456789101112131415161718192021222324252627282930313233343536373839404142434445function VisitCookie (const name, value, domain, path: ustring; secure, httponly, hasExpires: Boolean;const creation, lastAccess, expires: TDateTime; count, total: Integer;out deleteCookie: Boolean): Boolean;begin deleteCookie:= False; MainForm.Memo1.Lines. Add (&#x27; cookie &#x27; +inttostr (count) + &#x27; / &#x27; + inttostr (total)); MainForm.Memo1.Lines. Add (&#x27; name &#x27; +name); MainForm.Memo1.Lines. Add (&#x27; value &#x27; +value); MainForm.Memo1.Lines. Add (&#x27; domain &#x27; +domain); MainForm.Memo1.Lines. Add (&#x27; path &#x27; +path); MainForm.Memo1.Lines. Add (&#x27; secure &#x27; +BoolToStr (secure)); MainForm.Memo1.Lines. Add (&#x27; httponly &#x27; +BoolToStr (httponly)); MainForm.Memo1.Lines. Add (&#x27; hasExpires &#x27; +BoolToStr (hasExpires)); MainForm.Memo1.Lines. Add (&#x27; creation &#x27; +DateToStr (creation)); MainForm.Memo1.Lines. Add (&#x27; lastAccess &#x27; +DateToStr (lastAccess)); MainForm.Memo1.Lines. Add (&#x27; expires &#x27; +DateToStr (expires)); MainForm.Memo1.Lines. Add (&#x27;--------------- &#x27;); Result:= True;end; procedure TMainForm.btn2Click(Sender: TObject);var CookieManager: ICefCookieManager;beginCookieManager:= TCefCookieManagerRef.Global(nil);CookieManager.VisitAllCookiesProc (VisitCookie);end; //这样写，我在delphi xe8中编译不过procedure TMainForm.Button1Click(Sender: TObject);var CookieManager: ICefCookieManager;begin CookieManager := TCefCookieManagerRef.Global(nil); CookieManager.VisitAllCookiesProc( function(const name, value, domain, path: ustring; secure, httponly, hasExpires: Boolean; const creation, lastAccess, expires: TDateTime; count, total: Integer; out deleteCookie: Boolean): Boolean begin deleteCookie := True; ShowMessage(&#x27;A cookie from domain &#x27; + domain + &#x27; will be unmercifully &#x27; + &#x27;deleted!&#x27;); end );end; 为网址设置单独的cookie文件 1234567891011121314CookieManager: ICefCookieManager; FormCreate:begin CookiesPath := ExtractFilePath(Application.ExeName) + &#x27;cookies/bnwin&#x27;; CookieManager := TCefCookieManagerRef.Global(nil); CookieManager.SetStoragePath(CookiesPath, True, nil); Chromium1.Load（&#x27;bnwin.com&#x27;）; end; FormClose: begin CookieManager.FlushStore(nil);end 为指定的网站设置cookie 123456789101112var Fsuccess: Boolean;procedure SetCookieR(success: Boolean);begin Fsuccess := success;end; procedure TMainForm.btn1Click(Sender: TObject);var CookieManager: ICefCookieManager;begin CookieManager := TCefCookieManagerRef.Global(nil); CookieManager.SetCookieProc(&#x27;http://bnwin.com&#x27;, &#x27;TEST&#x27;, &#x27;supertest&#x27;, &#x27;.bnwin.com&#x27;, &#x27;/&#x27;, False,False, True, now, now, StrToDateTime(&#x27;2020-12-30&#x27;),SetCookieR);end; dcef中允许网站保存cookie会话 123456789101112CookieManager: ICefCookieManager; FormCreate:begin CookiesPath := ExtractFilePath(Application.ExeName) + &#x27;cookies&#x27;; CookieManager := TCefCookieManagerRef.Global(nil); CookieManager.SetStoragePath(CookiesPath, True, nil);end;FormClose: begin CookieManager.FlushStore(nil);end","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"delphi技巧","slug":"delphi技巧","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%8A%80%E5%B7%A7/"},{"name":"dcef3使用方法","slug":"dcef3使用方法","permalink":"https://goodhelp.gitee.io/tags/dcef3%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"}]},{"title":"delphi中dcef如何自定义referer信息？","slug":"article/delphi中dcef如何自定义referer信息？","date":"2017-12-25T16:19:24.000Z","updated":"2021-09-16T23:40:53.219Z","comments":true,"path":"page/4288787729/","link":"","permalink":"https://goodhelp.gitee.io/page/4288787729/","excerpt":"TChromium自定义referer，在早期的dcef版本中，这样Append(‘Referer’,’http://www.bnwin.com’)就可以了，详细看下面代码，如果append不行，启用这句request.SetReferrer(request.url, REFERRER_POLICY_ALWAYS); 123456789101112131415161718192021procedure TMainForm.chrm1BeforeResourceLoad(Sender: TObject; const browser: ICefBrowser; const frame: ICefFrame; const request: ICefRequest; const callback: ICefRequestCallback; out Result: TCefReturnValue);var map: ICefStringMultimap; sAccept,sUserAgent:string;begin sAccept:= &#x27;application/x-shockwave-flash, image/gif, image/jpeg, image/pjpeg, application/x-ms-application, application/x-ms-xbap,&#x27;+ &#x27; application/vnd.ms-xpsdocument, application/xaml+xml,text/html,application/octet-stream, */*&#x27;; sUserAgent:=&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36 QIHU 360EE&#x27;; map := TCefStringMultimapOwn.Create; request.GetHeaderMap(map); map.Append(&#x27;Referer&#x27;,request.url); map.Append(&#x27;Accept&#x27;,sAccept); map.Append(&#x27;User-Agent&#x27;,sUserAgent); // ShowMessage(map.getvalue(1)+&#x27; &#x27;+map.getkey(1)); request.SetHeaderMap(map); //map:=nil; //request.SetReferrer(request.url, REFERRER_POLICY_ALWAYS);end; 在高版本的dcef中自定义referer，可以直接定义request. 12345678910111213141516171819procedure TMainForm.ShowUrl(hurl,AllUrl:string);var Request: ICefRequest; Data: ICefPostData; Header: ICefStringMultimap; sUserAgent:string;begin if chrm1.Browser.IsLoading then chrm1.Browser.StopLoad; sUserAgent:=&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36 QIHU 360EE&#x27;; Request := TCefRequestRef.New; Request.SetReferrer(hurl,REFERRER_POLICY_ORIGIN);//定义referer Data := TCefPostDataRef.New; Header := TCefStringMultimapOwn.Create; Header.Append(&#x27;Accept-Language&#x27;, &#x27;zh-CN&#x27;); Header.Append(&#x27;User-Agent&#x27;,sUserAgent); Request.Assign(AllUrl,&#x27;POST&#x27;,Data,header); chrm1.Browser.MainFrame.LoadRequest(Request);end;","text":"TChromium自定义referer，在早期的dcef版本中，这样Append(‘Referer’,’http://www.bnwin.com’)就可以了，详细看下面代码，如果append不行，启用这句request.SetReferrer(request.url, REFERRER_POLICY_ALWAYS); 123456789101112131415161718192021procedure TMainForm.chrm1BeforeResourceLoad(Sender: TObject; const browser: ICefBrowser; const frame: ICefFrame; const request: ICefRequest; const callback: ICefRequestCallback; out Result: TCefReturnValue);var map: ICefStringMultimap; sAccept,sUserAgent:string;begin sAccept:= &#x27;application/x-shockwave-flash, image/gif, image/jpeg, image/pjpeg, application/x-ms-application, application/x-ms-xbap,&#x27;+ &#x27; application/vnd.ms-xpsdocument, application/xaml+xml,text/html,application/octet-stream, */*&#x27;; sUserAgent:=&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36 QIHU 360EE&#x27;; map := TCefStringMultimapOwn.Create; request.GetHeaderMap(map); map.Append(&#x27;Referer&#x27;,request.url); map.Append(&#x27;Accept&#x27;,sAccept); map.Append(&#x27;User-Agent&#x27;,sUserAgent); // ShowMessage(map.getvalue(1)+&#x27; &#x27;+map.getkey(1)); request.SetHeaderMap(map); //map:=nil; //request.SetReferrer(request.url, REFERRER_POLICY_ALWAYS);end; 在高版本的dcef中自定义referer，可以直接定义request. 12345678910111213141516171819procedure TMainForm.ShowUrl(hurl,AllUrl:string);var Request: ICefRequest; Data: ICefPostData; Header: ICefStringMultimap; sUserAgent:string;begin if chrm1.Browser.IsLoading then chrm1.Browser.StopLoad; sUserAgent:=&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36 QIHU 360EE&#x27;; Request := TCefRequestRef.New; Request.SetReferrer(hurl,REFERRER_POLICY_ORIGIN);//定义referer Data := TCefPostDataRef.New; Header := TCefStringMultimapOwn.Create; Header.Append(&#x27;Accept-Language&#x27;, &#x27;zh-CN&#x27;); Header.Append(&#x27;User-Agent&#x27;,sUserAgent); Request.Assign(AllUrl,&#x27;POST&#x27;,Data,header); chrm1.Browser.MainFrame.LoadRequest(Request);end;","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"delphi技巧","slug":"delphi技巧","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%8A%80%E5%B7%A7/"},{"name":"dcef3使用方法","slug":"dcef3使用方法","permalink":"https://goodhelp.gitee.io/tags/dcef3%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"}]},{"title":"Procmon监视系统一举一动的利器!","slug":"soft/Procmon监视系统一举一动的利器","date":"2017-12-25T03:58:22.000Z","updated":"2021-09-16T23:53:10.272Z","comments":true,"path":"page/446633678/","link":"","permalink":"https://goodhelp.gitee.io/page/446633678/","excerpt":"Procmon也被称为Process Monitor，是一款系统进程监视软件，总体来说，Process Monitor相当于Filemon+Regmon，其中的Filemon专门用来监视系统 中的任何文件操作过程，而Regmon用来监视注册表的读写操作过程。 有了Process Monitor，使用者就可以对系统中的任何文件和 注册表操作同时进行监视和记录，通过注册表和文件读写的变化， 对于帮助诊断系统故障或是发现恶意软件、病毒或木马来说，非常 有用。 这是一个高级的 Windows 系统和应用程序监视工具，由优秀的 Sysinternals 开发，并且目前已并入微软旗下，可靠性自不用说。 Process Monitor 不仅结合了 Filemon（文件监视器） 和 Regmon（注册表监视器） 两个工具的功能，还具有以下一些增强： 监视进程和线程的启动和退出，包括退出状态代码监视映像 (DLL 和内核模式驱动程序) 加载捕获更多输入输出参数操作非破坏性的过滤器允许你自行定义而不会丢失任何捕获的数据捕获每一个线程操作的堆栈，使得可以在许多情况下识别一个操作的根源可靠捕获进程详细信息，包括映像路径、命令行、完整性、用户和会话ID等等完全可以自定义任何事件的属性列过滤器可以设置为任何数据条件，包括未在当前视图中显示的高级的日志机制，可记录上千万的事件，数GB的日志数据进程树工具显示所有进程的关系原生的日志格式，可将所有数据信息保存，让另一个 Process Monitor 实例加载进程悬停提示，可方便的查看进程信息详细的悬停提示信息让你方便的查看列中不能完整显示的信息搜索可取消系统引导时记录所有操作 官方下载地址： https://docs.microsoft.com/zh-cn/sysinternals/downloads/procmon 百度网盘下载地址：链接: https://pan.baidu.com/s/1eSF9fAM 密码: erib","text":"Procmon也被称为Process Monitor，是一款系统进程监视软件，总体来说，Process Monitor相当于Filemon+Regmon，其中的Filemon专门用来监视系统 中的任何文件操作过程，而Regmon用来监视注册表的读写操作过程。 有了Process Monitor，使用者就可以对系统中的任何文件和 注册表操作同时进行监视和记录，通过注册表和文件读写的变化， 对于帮助诊断系统故障或是发现恶意软件、病毒或木马来说，非常 有用。 这是一个高级的 Windows 系统和应用程序监视工具，由优秀的 Sysinternals 开发，并且目前已并入微软旗下，可靠性自不用说。 Process Monitor 不仅结合了 Filemon（文件监视器） 和 Regmon（注册表监视器） 两个工具的功能，还具有以下一些增强： 监视进程和线程的启动和退出，包括退出状态代码监视映像 (DLL 和内核模式驱动程序) 加载捕获更多输入输出参数操作非破坏性的过滤器允许你自行定义而不会丢失任何捕获的数据捕获每一个线程操作的堆栈，使得可以在许多情况下识别一个操作的根源可靠捕获进程详细信息，包括映像路径、命令行、完整性、用户和会话ID等等完全可以自定义任何事件的属性列过滤器可以设置为任何数据条件，包括未在当前视图中显示的高级的日志机制，可记录上千万的事件，数GB的日志数据进程树工具显示所有进程的关系原生的日志格式，可将所有数据信息保存，让另一个 Process Monitor 实例加载进程悬停提示，可方便的查看进程信息详细的悬停提示信息让你方便的查看列中不能完整显示的信息搜索可取消系统引导时记录所有操作 官方下载地址： https://docs.microsoft.com/zh-cn/sysinternals/downloads/procmon 百度网盘下载地址：链接: https://pan.baidu.com/s/1eSF9fAM 密码: erib","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"去广告方法","slug":"去广告方法","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%BB%E5%B9%BF%E5%91%8A%E6%96%B9%E6%B3%95/"},{"name":"精品软件","slug":"精品软件","permalink":"https://goodhelp.gitee.io/tags/%E7%B2%BE%E5%93%81%E8%BD%AF%E4%BB%B6/"}]},{"title":"delphi中如何让dcef支持flash插件播放视频？","slug":"article/delphi中如何让dcef支持flash插件播放视频？","date":"2017-12-24T16:16:03.000Z","updated":"2021-09-16T23:40:39.316Z","comments":true,"path":"page/2193927687/","link":"","permalink":"https://goodhelp.gitee.io/page/2193927687/","excerpt":"Chromium Embedded Framework (CEF)是个基于Google Chromium项目的开源Web browser控件，支持Windows, Linux, Mac平台。除了提供C/C++接口外，也有其他语言的移植版。因为基于Chromium，所以CEF支持Webkit &amp; Chrome中实现的HTML5的特性，并且在性能上面，也比较接近Chrome。CEF还提供的如下特性：自定义插件、自定义协议、自定义JavaScript对象和扩展；可控制的resource loading, navigation, context menus等等。dcef是指的cef在delphi中的版本 cef在前期版本中是自带支持flash插件的,后来Chromium不再默认支持flash控件!下面看看我的程序的dcef命令行参数 如何让dcef支持flash呢？ 安装好dcef，不管哪个版本都行! 安装360极速浏览器或QQ浏览器，打开其安装目录，找到ppflash目录和npflash目录(360极速浏览器是这两个目录，而QQ浏览器略有不同)！ 在你的工程目录中建NativeFlash目录和PepperFlash目录,然后360的npflash目录下的NPSWF开头的dll文件和同目录下的vch文件复制到自己工程的NativeFlash中，把360的ppflash目录中的pepflash开头的dll文件和同目录下的json文件复制到工程的PepperFlash目录中!这一步就是用360浏览器的flash文件，不需要你手工去下载安装插件!至少你应该发现即使你的系统没有安装flash插件，但360浏览器安装后一样可以正常播放flash，这就是因为他的目录中自带了这几个flash文件，为了让你的程序的dcef支持flash，所以我们直接复制360极速浏览器的flash文件过来，简单方便! 编辑你的delphi工程文件（即dpr文件），在{$R *.res}后面添加如下代码123456789101112131415161718192021procedure AppendCefCmdline(const processType: ustring; const cmd: ICefCommandLine);begin //cmd.AppendSwitch(&#x27;--enable-gpu-plugin&#x27;);//允许gpu //cmd.AppendSwitch(&#x27;disable-gpu&#x27;);//禁止gpu cmd.AppendSwitch(&#x27;enable-npapi&#x27;); //允许NativeFlash //cmd.AppendSwitch(&#x27;enable-tab-audio-muting&#x27;);//允许tab页禁音 //cmd.AppendSwitch(&#x27;--enable-media-stream&#x27;); //允许视频流 cmd.AppendSwitchwithvalue(&#x27;load-plugin&#x27;, &#x27;NativeFlash\\NPSWF32.dll&#x27;);//指定NativeFlash插件文件位置，注意文件名要和你的一致 //cmd.AppendSwitchWithValue(&#x27;ppapi-flash-version&#x27;,&#x27;20.0.0.267&#x27;);//指定PepperFlash版本号 cmd.AppendSwitchWithValue(&#x27;ppapi-flash-path&#x27;,&#x27;PepperFlash\\pepflashplayer.dll&#x27;);//指定PepperFlash插件文件位置,注意文件名要和你的一致 cmd.AppendSwitch(&#x27;--enable-system-flash&#x27;);//允许PepperFlash //cmd.AppendSwitch(&#x27;--enable-usermedia-screen-capturing&#x27;);end; begin CefOnBeforeCommandLineProcessing :=AppendCefCmdline; //这一句就是指定了dcef启动的命令行 Application.Initialize; Application.MainFormOnTaskbar := True; Application.CreateForm(TMainForm, MainForm); Application.Run;end. 很多人用delphi的dcef写的程序，不支持flash，是只在命令行中添加了允许flash，而没有指定flash插件文件的位置，这时dcef会去调用系统安装的flash插件，一旦系统插件有问题，你的程序就无法播放flash了，本文写的方法就是360极速浏览器的方法，不管你的系统安装不安装flash，一样播放flash!而要让dcefbrowser支持flash也一样，dcefbrowser中只是把CefOnBeforeCommandLineProcessing改为DcefBApp.OnBeforeCommandLineProcessing即可，至于播放flash会有dos窗口弹一下的问题，请看本站的这篇文章http://www.bnwin.com/2017/12/01/328.html","text":"Chromium Embedded Framework (CEF)是个基于Google Chromium项目的开源Web browser控件，支持Windows, Linux, Mac平台。除了提供C/C++接口外，也有其他语言的移植版。因为基于Chromium，所以CEF支持Webkit &amp; Chrome中实现的HTML5的特性，并且在性能上面，也比较接近Chrome。CEF还提供的如下特性：自定义插件、自定义协议、自定义JavaScript对象和扩展；可控制的resource loading, navigation, context menus等等。dcef是指的cef在delphi中的版本 cef在前期版本中是自带支持flash插件的,后来Chromium不再默认支持flash控件!下面看看我的程序的dcef命令行参数 如何让dcef支持flash呢？ 安装好dcef，不管哪个版本都行! 安装360极速浏览器或QQ浏览器，打开其安装目录，找到ppflash目录和npflash目录(360极速浏览器是这两个目录，而QQ浏览器略有不同)！ 在你的工程目录中建NativeFlash目录和PepperFlash目录,然后360的npflash目录下的NPSWF开头的dll文件和同目录下的vch文件复制到自己工程的NativeFlash中，把360的ppflash目录中的pepflash开头的dll文件和同目录下的json文件复制到工程的PepperFlash目录中!这一步就是用360浏览器的flash文件，不需要你手工去下载安装插件!至少你应该发现即使你的系统没有安装flash插件，但360浏览器安装后一样可以正常播放flash，这就是因为他的目录中自带了这几个flash文件，为了让你的程序的dcef支持flash，所以我们直接复制360极速浏览器的flash文件过来，简单方便! 编辑你的delphi工程文件（即dpr文件），在{$R *.res}后面添加如下代码123456789101112131415161718192021procedure AppendCefCmdline(const processType: ustring; const cmd: ICefCommandLine);begin //cmd.AppendSwitch(&#x27;--enable-gpu-plugin&#x27;);//允许gpu //cmd.AppendSwitch(&#x27;disable-gpu&#x27;);//禁止gpu cmd.AppendSwitch(&#x27;enable-npapi&#x27;); //允许NativeFlash //cmd.AppendSwitch(&#x27;enable-tab-audio-muting&#x27;);//允许tab页禁音 //cmd.AppendSwitch(&#x27;--enable-media-stream&#x27;); //允许视频流 cmd.AppendSwitchwithvalue(&#x27;load-plugin&#x27;, &#x27;NativeFlash\\NPSWF32.dll&#x27;);//指定NativeFlash插件文件位置，注意文件名要和你的一致 //cmd.AppendSwitchWithValue(&#x27;ppapi-flash-version&#x27;,&#x27;20.0.0.267&#x27;);//指定PepperFlash版本号 cmd.AppendSwitchWithValue(&#x27;ppapi-flash-path&#x27;,&#x27;PepperFlash\\pepflashplayer.dll&#x27;);//指定PepperFlash插件文件位置,注意文件名要和你的一致 cmd.AppendSwitch(&#x27;--enable-system-flash&#x27;);//允许PepperFlash //cmd.AppendSwitch(&#x27;--enable-usermedia-screen-capturing&#x27;);end; begin CefOnBeforeCommandLineProcessing :=AppendCefCmdline; //这一句就是指定了dcef启动的命令行 Application.Initialize; Application.MainFormOnTaskbar := True; Application.CreateForm(TMainForm, MainForm); Application.Run;end. 很多人用delphi的dcef写的程序，不支持flash，是只在命令行中添加了允许flash，而没有指定flash插件文件的位置，这时dcef会去调用系统安装的flash插件，一旦系统插件有问题，你的程序就无法播放flash了，本文写的方法就是360极速浏览器的方法，不管你的系统安装不安装flash，一样播放flash!而要让dcefbrowser支持flash也一样，dcefbrowser中只是把CefOnBeforeCommandLineProcessing改为DcefBApp.OnBeforeCommandLineProcessing即可，至于播放flash会有dos窗口弹一下的问题，请看本站的这篇文章http://www.bnwin.com/2017/12/01/328.html","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"delphi技巧","slug":"delphi技巧","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%8A%80%E5%B7%A7/"},{"name":"dcef3使用方法","slug":"dcef3使用方法","permalink":"https://goodhelp.gitee.io/tags/dcef3%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"}]},{"title":"delphi如何实现任意窗口透明化?","slug":"article/delphi如何实现任意窗口透明化","date":"2017-12-16T16:13:47.000Z","updated":"2021-09-16T23:44:35.280Z","comments":true,"path":"page/807774960/","link":"","permalink":"https://goodhelp.gitee.io/page/807774960/","excerpt":"1234567//声明:SetLayeredWindowAttributes( Hwnd: THandle; &#123;窗口句柄&#125; crKey: COLORREF; &#123;透明色&#125; bAlpha: Byte; &#123;Alpha 值&#125; dwFlags: DWORD &#123;LWA_COLORKEY(=1)表示使用透明色; LWA_ALPHA(=2)表示使用 Alpha 值&#125;): Boolean; &#123;是否成功设置&#125; 举例(控制外部程序的透明度, 用计算器举了个例子): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748unit Unit1; interface uses Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms, Dialogs, StdCtrls; type TForm1 = class(TForm) Button1: TButton; Button2: TButton; procedure Button1Click(Sender: TObject); procedure Button2Click(Sender: TObject); end; var Form1: TForm1; implementation &#123;$R *.dfm&#125; &#123;设定计算器的 Alpha 透明&#125;procedure TForm1.Button1Click(Sender: TObject);var h: HWND; FormStyle: Integer;begin h := FindWindow(&#x27;CalcFrame&#x27;,&#x27;计算器&#x27;); FormStyle := GetWindowLong(h, GWL_EXSTYLE); SetWindowLong(h, GWL_EXSTYLE, FormStyle or WS_EX_LAYERED); SetLayeredWindowAttributes(h, 0, 128, LWA_ALPHA);end; &#123;设定计算器中的白色透明&#125;procedure TForm1.Button2Click(Sender: TObject);var h: HWND; FormStyle: Integer;begin h := FindWindow(&#x27;SciCalc&#x27;, nil); FormStyle := GetWindowLong(h, GWL_EXSTYLE); SetWindowLong(h, GWL_EXSTYLE, FormStyle or WS_EX_LAYERED); SetLayeredWindowAttributes(h, clWhite, 255, LWA_COLORKEY);end; end.","text":"1234567//声明:SetLayeredWindowAttributes( Hwnd: THandle; &#123;窗口句柄&#125; crKey: COLORREF; &#123;透明色&#125; bAlpha: Byte; &#123;Alpha 值&#125; dwFlags: DWORD &#123;LWA_COLORKEY(=1)表示使用透明色; LWA_ALPHA(=2)表示使用 Alpha 值&#125;): Boolean; &#123;是否成功设置&#125; 举例(控制外部程序的透明度, 用计算器举了个例子): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748unit Unit1; interface uses Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms, Dialogs, StdCtrls; type TForm1 = class(TForm) Button1: TButton; Button2: TButton; procedure Button1Click(Sender: TObject); procedure Button2Click(Sender: TObject); end; var Form1: TForm1; implementation &#123;$R *.dfm&#125; &#123;设定计算器的 Alpha 透明&#125;procedure TForm1.Button1Click(Sender: TObject);var h: HWND; FormStyle: Integer;begin h := FindWindow(&#x27;CalcFrame&#x27;,&#x27;计算器&#x27;); FormStyle := GetWindowLong(h, GWL_EXSTYLE); SetWindowLong(h, GWL_EXSTYLE, FormStyle or WS_EX_LAYERED); SetLayeredWindowAttributes(h, 0, 128, LWA_ALPHA);end; &#123;设定计算器中的白色透明&#125;procedure TForm1.Button2Click(Sender: TObject);var h: HWND; FormStyle: Integer;begin h := FindWindow(&#x27;SciCalc&#x27;, nil); FormStyle := GetWindowLong(h, GWL_EXSTYLE); SetWindowLong(h, GWL_EXSTYLE, FormStyle or WS_EX_LAYERED); SetLayeredWindowAttributes(h, clWhite, 255, LWA_COLORKEY);end; end.","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"delphi技巧","slug":"delphi技巧","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%8A%80%E5%B7%A7/"},{"name":"去广告方法","slug":"去广告方法","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%BB%E5%B9%BF%E5%91%8A%E6%96%B9%E6%B3%95/"}]},{"title":"单独调用运行8圈挂机锁工具","slug":"soft/单独调用运行8圈挂机锁工具","date":"2017-12-15T13:37:21.000Z","updated":"2021-09-12T00:08:13.552Z","comments":true,"path":"page/576111441/","link":"","permalink":"https://goodhelp.gitee.io/page/576111441/","excerpt":"适用于八圈9.5以下版本，9.5版本请查看本站其他页面8圈网管计费系统，自带有挂机锁，一般的网吧均在桌面添加一个挂机锁，但单独的挂机锁或无盘提供的挂机锁，只要重启机器就解锁了，但计费系统的挂机锁则不同，重启机器后，8圈网管计费系统的挂机锁仍然是挂机状态！（如果顾客忘记了8圈挂机锁的密码，可以直接在8圈计费服务端对着挂机机器右键解锁，无需挂机密码，而普通的挂机锁密码忘了就没法，只有重启，重启后就解锁了!这也是8圈计费挂机锁的优势所在!）看看8圈网管计费系统界面，而8圈的挂机锁一般要点开界面才能运行，无法把8圈挂机锁创建快捷方式到桌面，本程序独立于8圈网管计费系统，运行本程序自动运行8圈的挂机锁，这样就可以把无盘系统的挂机锁或单独的挂机全部换成8圈的挂机锁了! 本程序直接运行实现功能就是 8圈的挂机锁，同时可以添加参数运行加参数 1 运行就是 8圈的结账下机加参数 2 运行就是 8圈的电脑换机加参数 3 运行就是 8圈的呼叫网管加参数 4 运行就是 8圈的在线充值 如何添加参数，请看下面的gif动画 下载地址: ———————-支持8圈9.4.4链接: https://pan.baidu.com/s/159bjiteKJnRwNhlGGK05Lg 密码: shrs增加参数 5 运行就是 8圈的修改密码功能———————-8圈9.4.4以前版本链接: https://pan.baidu.com/s/1nvoVTLB 密码: jxg4 解压密码 bnwin.com 查看8圈相关软件 https://goodhelp.gitee.io/tags/八圈/","text":"适用于八圈9.5以下版本，9.5版本请查看本站其他页面8圈网管计费系统，自带有挂机锁，一般的网吧均在桌面添加一个挂机锁，但单独的挂机锁或无盘提供的挂机锁，只要重启机器就解锁了，但计费系统的挂机锁则不同，重启机器后，8圈网管计费系统的挂机锁仍然是挂机状态！（如果顾客忘记了8圈挂机锁的密码，可以直接在8圈计费服务端对着挂机机器右键解锁，无需挂机密码，而普通的挂机锁密码忘了就没法，只有重启，重启后就解锁了!这也是8圈计费挂机锁的优势所在!）看看8圈网管计费系统界面，而8圈的挂机锁一般要点开界面才能运行，无法把8圈挂机锁创建快捷方式到桌面，本程序独立于8圈网管计费系统，运行本程序自动运行8圈的挂机锁，这样就可以把无盘系统的挂机锁或单独的挂机全部换成8圈的挂机锁了! 本程序直接运行实现功能就是 8圈的挂机锁，同时可以添加参数运行加参数 1 运行就是 8圈的结账下机加参数 2 运行就是 8圈的电脑换机加参数 3 运行就是 8圈的呼叫网管加参数 4 运行就是 8圈的在线充值 如何添加参数，请看下面的gif动画 下载地址: ———————-支持8圈9.4.4链接: https://pan.baidu.com/s/159bjiteKJnRwNhlGGK05Lg 密码: shrs增加参数 5 运行就是 8圈的修改密码功能———————-8圈9.4.4以前版本链接: https://pan.baidu.com/s/1nvoVTLB 密码: jxg4 解压密码 bnwin.com 查看8圈相关软件 https://goodhelp.gitee.io/tags/八圈/","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"八圈","slug":"八圈","permalink":"https://goodhelp.gitee.io/tags/%E5%85%AB%E5%9C%88/"},{"name":"原创软件","slug":"原创软件","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%9F%E5%88%9B%E8%BD%AF%E4%BB%B6/"}]},{"title":"dcef3加载flash闪烁问题简单解决方法","slug":"article/dcef3加载flash闪烁问题简单解决方法","date":"2017-11-30T16:08:51.000Z","updated":"2021-09-16T23:42:28.023Z","comments":true,"path":"page/1936827288/","link":"","permalink":"https://goodhelp.gitee.io/page/1936827288/","excerpt":"dcef3添加flash插件后，在播放flash时会有一个dos的黑框一闪而过,显示not sandboxed,影响使用体验! 一种方法是hook 具体可以看这篇文章 http://blog.csdn.net/zx2356/article/details/51514403这篇文章是使用的C语言，这儿采用同样的方法，在delphi中实现!代码如下HookExt.pas源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100unit HookExt; interfaceuses uhook,Windows,SysUtils; type TFuncCreateProcessA = function(lpApplicationName: LPCSTR; lpCommandLine: LPSTR; lpProcessAttributes, lpThreadAttributes: PSecurityAttributes; bInheritHandles: BOOL; dwCreationFlags: DWORD; lpEnvironment: Pointer; lpCurrentDirectory: LPCSTR; const lpStartupInfo: TStartupInfoA; var lpProcessInformation: TProcessInformation): BOOL; stdcall; TFuncCreateProcessW = function(lpApplicationName: LPCWSTR; lpCommandLine: LPWSTR; lpProcessAttributes, lpThreadAttributes: PSecurityAttributes; bInheritHandles: BOOL; dwCreationFlags: DWORD; lpEnvironment: Pointer; lpCurrentDirectory: LPCWSTR; const lpStartupInfo: TStartupInfoW; var lpProcessInformation: TProcessInformation): BOOL; stdcall; implementation var hhk: HHook; MapFile: THandle; startPID: PDWORD; Hook: array [0 .. 1] of TNtHookClass; function NewCreateProcessA(lpApplicationName: LPCSTR; lpCommandLine: LPSTR; lpProcessAttributes, lpThreadAttributes: PSecurityAttributes; bInheritHandles: BOOL; dwCreationFlags: DWORD; lpEnvironment: Pointer; lpCurrentDirectory: LPCSTR; const lpStartupInfo: TStartupInfoA; var lpProcessInformation: TProcessInformation): BOOL; stdcall;var strCommandLine: AnsiString;begin strCommandLine := StrPas(lpCommandLine); if (Pos(&#x27;echo NOT SANDBOXED&#x27;,strCommandLine)&gt;0) or (Pos(&#x27;no-sandbox&#x27;,strCommandLine)&gt;0) then Result := True else begin Hook[0].UnHook; Result := TFuncCreateProcessA(Hook[0].BaseAddr)(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation); Hook[0].Hook; end;end; function NewCreateProcessW(lpApplicationName: LPCWSTR; lpCommandLine: LPWSTR; lpProcessAttributes, lpThreadAttributes: PSecurityAttributes; bInheritHandles: BOOL; dwCreationFlags: DWORD; lpEnvironment: Pointer; lpCurrentDirectory: LPCWSTR; const lpStartupInfo: TStartupInfoW; var lpProcessInformation: TProcessInformation): BOOL; stdcall;var strCommandLine: string;begin strCommandLine := StrPas(lpCommandLine); if (Pos(&#x27;echo NOT SANDBOXED&#x27;,strCommandLine)&gt;0) or (Pos(&#x27;no-sandbox&#x27;,strCommandLine)&gt;0) then Result := True else begin Hook[1].UnHook; Result := TFuncCreateProcessW(Hook[1].BaseAddr)(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation); Hook[1].Hook; end;end; // 安装API Hookprocedure InitHook;begin Hook[0] := TNtHookClass.Create(&#x27;kernel32.dll&#x27;, &#x27;CreateProcessA&#x27;, @NewCreateProcessA); Hook[1] := TNtHookClass.Create(&#x27;kernel32.dll&#x27;, &#x27;CreateProcessW&#x27;, @NewCreateProcessW); // Hook[2] := TNtHookClass.Create( &#x27;user32.dll&#x27;, &#x27;MessageBoxA&#x27;, @NewMessageBoxA );end; // 删除API Hookprocedure UnInitHook;var i: Integer;begin for i := 0 to High(Hook) do FreeAndNil(Hook[i]);end; // 环境处理procedure DllEntry(dwReason: DWORD);begin case dwReason of DLL_PROCESS_ATTACH: InitHook; DLL_PROCESS_DETACH: UnInitHook; end;end; initialization InitHook; finalization UnInitHook;end. 其中的uHook.pas源码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788unit uHook; interface usesWindows, Messages, SysUtils;type TNtJmpCode = packed record MovEax: Byte; Addr: DWORD; JmpCode: Word; dwReserved: Byte; end; TNtHookClass = class(TObject) private hProcess: THandle; NewAddr: TNtJmpCode; OldAddr: array [0 .. 7] of Byte; ReadOk: Boolean; public BaseAddr: Pointer; constructor Create(const ADllName, AFuncName: string; ANewFunc: Pointer); destructor Destroy; override; procedure Hook; procedure UnHook; end; implementation &#123; TNtHookClass &#125; constructor TNtHookClass.Create(const ADllName, AFuncName: string; ANewFunc: Pointer);var dllModule: HMODULE; lpNumberOfBytesReacd: DWORD; //NativeUInt; i:Integer;begin // 获取模块句柄 dllModule := GetModuleHandle(PWideChar(ADllName)); if dllModule = 0 then dllModule := LoadLibrary(PWideChar(ADllName)); // 得到模块入口地址 BaseAddr := Pointer(GetProcAddress(dllModule, PWideChar(AFuncName))); // 获取当前进程句柄 hProcess := GetCurrentProcess; // 指向新地址的指针 NewAddr.MovEax := $B8; NewAddr.Addr := DWORD(ANewFunc); NewAddr.JmpCode := $E0FF; // 保存原始地址 ReadOk:=ReadProcessMemory(hProcess, BaseAddr, Pointer(@OldAddr), 8, lpNumberOfBytesReacd); // 开始拦截 Hook; end; destructor TNtHookClass.Destroy;begin UnHook; CloseHandle(hProcess); inherited;end; procedure TNtHookClass.Hook;var lpNumberOfBytesRead: DWORD;begin if not ReadOk then exit; // 写入新的地址 WriteProcessMemory(hProcess, BaseAddr, @NewAddr, 8, lpNumberOfBytesRead);end; procedure TNtHookClass.UnHook;var lpNumberOfBytesRead: DWORD;begin if not ReadOk then exit; // 恢复地址 WriteProcessMemory(hProcess, BaseAddr, @OldAddr, 8, lpNumberOfBytesRead); end; end. 这种hook处理不好就容易蓝屏，更简单的方法如下：用二进制编辑软件，比如winhex,我这儿采用UltraEdit,用UltraEdit打开flash插件dll文件 pepflashplayer.dll 搜索comspec修改为somspec,(修改的名字只要和comspec不相同即可)修改cmd.exe为cm1.exe (修改的名字只要和cmd.exe不相同即可) 修改后为 然后保存即可，这时打开flash就不会有dos黑框闪一下了！ 第三种方法，更简单，什么都不用修改，只要在你的程序目录下新建一个文本文件，然后改名为cmd.exe，因为弹出黑框需要使用cmd程序，而系统搜索程序是从进程当前的工作目录开始查找，所以直接这样建一个不能执行的cmd.exe文件可以拦截cmd的调用。这个方法最简单！ 第一种hook方法是修改flash文件，但其实是采用动态方法改了汇编代码，处理不好容易蓝屏。第二种方法修改flash插件文件,原理是：flash执行cmd的逻辑是，先读取环境变量comspec(cmd.exe的全路径)，读取到就执行它，读取不到就不执行cmd.exe.只要把变量和cmd.exe名字修改，就执行不成功，就没有DOS黑框出来!第一种方法是在flash插件要运行cmd.exe的时候再进行拦截，是动态修改的，而第二种是直接让flash找不到变量和cmd.exe程序，flash自己判断不用执行，是静态修改!第三种是懒人方法!但几种方法实现的效果都是阻止cmd.exe的正常执行!同时你就可以这样思考了，为了让flash不出现闪黑框的问题，就变成了如何阻止cmd.exe的执行，比如你在你自己的程序中先修改一下comspec环境变量，也是可以阻止cmd.exe执行的，大家自由发挥!","text":"dcef3添加flash插件后，在播放flash时会有一个dos的黑框一闪而过,显示not sandboxed,影响使用体验! 一种方法是hook 具体可以看这篇文章 http://blog.csdn.net/zx2356/article/details/51514403这篇文章是使用的C语言，这儿采用同样的方法，在delphi中实现!代码如下HookExt.pas源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100unit HookExt; interfaceuses uhook,Windows,SysUtils; type TFuncCreateProcessA = function(lpApplicationName: LPCSTR; lpCommandLine: LPSTR; lpProcessAttributes, lpThreadAttributes: PSecurityAttributes; bInheritHandles: BOOL; dwCreationFlags: DWORD; lpEnvironment: Pointer; lpCurrentDirectory: LPCSTR; const lpStartupInfo: TStartupInfoA; var lpProcessInformation: TProcessInformation): BOOL; stdcall; TFuncCreateProcessW = function(lpApplicationName: LPCWSTR; lpCommandLine: LPWSTR; lpProcessAttributes, lpThreadAttributes: PSecurityAttributes; bInheritHandles: BOOL; dwCreationFlags: DWORD; lpEnvironment: Pointer; lpCurrentDirectory: LPCWSTR; const lpStartupInfo: TStartupInfoW; var lpProcessInformation: TProcessInformation): BOOL; stdcall; implementation var hhk: HHook; MapFile: THandle; startPID: PDWORD; Hook: array [0 .. 1] of TNtHookClass; function NewCreateProcessA(lpApplicationName: LPCSTR; lpCommandLine: LPSTR; lpProcessAttributes, lpThreadAttributes: PSecurityAttributes; bInheritHandles: BOOL; dwCreationFlags: DWORD; lpEnvironment: Pointer; lpCurrentDirectory: LPCSTR; const lpStartupInfo: TStartupInfoA; var lpProcessInformation: TProcessInformation): BOOL; stdcall;var strCommandLine: AnsiString;begin strCommandLine := StrPas(lpCommandLine); if (Pos(&#x27;echo NOT SANDBOXED&#x27;,strCommandLine)&gt;0) or (Pos(&#x27;no-sandbox&#x27;,strCommandLine)&gt;0) then Result := True else begin Hook[0].UnHook; Result := TFuncCreateProcessA(Hook[0].BaseAddr)(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation); Hook[0].Hook; end;end; function NewCreateProcessW(lpApplicationName: LPCWSTR; lpCommandLine: LPWSTR; lpProcessAttributes, lpThreadAttributes: PSecurityAttributes; bInheritHandles: BOOL; dwCreationFlags: DWORD; lpEnvironment: Pointer; lpCurrentDirectory: LPCWSTR; const lpStartupInfo: TStartupInfoW; var lpProcessInformation: TProcessInformation): BOOL; stdcall;var strCommandLine: string;begin strCommandLine := StrPas(lpCommandLine); if (Pos(&#x27;echo NOT SANDBOXED&#x27;,strCommandLine)&gt;0) or (Pos(&#x27;no-sandbox&#x27;,strCommandLine)&gt;0) then Result := True else begin Hook[1].UnHook; Result := TFuncCreateProcessW(Hook[1].BaseAddr)(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation); Hook[1].Hook; end;end; // 安装API Hookprocedure InitHook;begin Hook[0] := TNtHookClass.Create(&#x27;kernel32.dll&#x27;, &#x27;CreateProcessA&#x27;, @NewCreateProcessA); Hook[1] := TNtHookClass.Create(&#x27;kernel32.dll&#x27;, &#x27;CreateProcessW&#x27;, @NewCreateProcessW); // Hook[2] := TNtHookClass.Create( &#x27;user32.dll&#x27;, &#x27;MessageBoxA&#x27;, @NewMessageBoxA );end; // 删除API Hookprocedure UnInitHook;var i: Integer;begin for i := 0 to High(Hook) do FreeAndNil(Hook[i]);end; // 环境处理procedure DllEntry(dwReason: DWORD);begin case dwReason of DLL_PROCESS_ATTACH: InitHook; DLL_PROCESS_DETACH: UnInitHook; end;end; initialization InitHook; finalization UnInitHook;end. 其中的uHook.pas源码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788unit uHook; interface usesWindows, Messages, SysUtils;type TNtJmpCode = packed record MovEax: Byte; Addr: DWORD; JmpCode: Word; dwReserved: Byte; end; TNtHookClass = class(TObject) private hProcess: THandle; NewAddr: TNtJmpCode; OldAddr: array [0 .. 7] of Byte; ReadOk: Boolean; public BaseAddr: Pointer; constructor Create(const ADllName, AFuncName: string; ANewFunc: Pointer); destructor Destroy; override; procedure Hook; procedure UnHook; end; implementation &#123; TNtHookClass &#125; constructor TNtHookClass.Create(const ADllName, AFuncName: string; ANewFunc: Pointer);var dllModule: HMODULE; lpNumberOfBytesReacd: DWORD; //NativeUInt; i:Integer;begin // 获取模块句柄 dllModule := GetModuleHandle(PWideChar(ADllName)); if dllModule = 0 then dllModule := LoadLibrary(PWideChar(ADllName)); // 得到模块入口地址 BaseAddr := Pointer(GetProcAddress(dllModule, PWideChar(AFuncName))); // 获取当前进程句柄 hProcess := GetCurrentProcess; // 指向新地址的指针 NewAddr.MovEax := $B8; NewAddr.Addr := DWORD(ANewFunc); NewAddr.JmpCode := $E0FF; // 保存原始地址 ReadOk:=ReadProcessMemory(hProcess, BaseAddr, Pointer(@OldAddr), 8, lpNumberOfBytesReacd); // 开始拦截 Hook; end; destructor TNtHookClass.Destroy;begin UnHook; CloseHandle(hProcess); inherited;end; procedure TNtHookClass.Hook;var lpNumberOfBytesRead: DWORD;begin if not ReadOk then exit; // 写入新的地址 WriteProcessMemory(hProcess, BaseAddr, @NewAddr, 8, lpNumberOfBytesRead);end; procedure TNtHookClass.UnHook;var lpNumberOfBytesRead: DWORD;begin if not ReadOk then exit; // 恢复地址 WriteProcessMemory(hProcess, BaseAddr, @OldAddr, 8, lpNumberOfBytesRead); end; end. 这种hook处理不好就容易蓝屏，更简单的方法如下：用二进制编辑软件，比如winhex,我这儿采用UltraEdit,用UltraEdit打开flash插件dll文件 pepflashplayer.dll 搜索comspec修改为somspec,(修改的名字只要和comspec不相同即可)修改cmd.exe为cm1.exe (修改的名字只要和cmd.exe不相同即可) 修改后为 然后保存即可，这时打开flash就不会有dos黑框闪一下了！ 第三种方法，更简单，什么都不用修改，只要在你的程序目录下新建一个文本文件，然后改名为cmd.exe，因为弹出黑框需要使用cmd程序，而系统搜索程序是从进程当前的工作目录开始查找，所以直接这样建一个不能执行的cmd.exe文件可以拦截cmd的调用。这个方法最简单！ 第一种hook方法是修改flash文件，但其实是采用动态方法改了汇编代码，处理不好容易蓝屏。第二种方法修改flash插件文件,原理是：flash执行cmd的逻辑是，先读取环境变量comspec(cmd.exe的全路径)，读取到就执行它，读取不到就不执行cmd.exe.只要把变量和cmd.exe名字修改，就执行不成功，就没有DOS黑框出来!第一种方法是在flash插件要运行cmd.exe的时候再进行拦截，是动态修改的，而第二种是直接让flash找不到变量和cmd.exe程序，flash自己判断不用执行，是静态修改!第三种是懒人方法!但几种方法实现的效果都是阻止cmd.exe的正常执行!同时你就可以这样思考了，为了让flash不出现闪黑框的问题，就变成了如何阻止cmd.exe的执行，比如你在你自己的程序中先修改一下comspec环境变量，也是可以阻止cmd.exe执行的，大家自由发挥!","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"delphi技巧","slug":"delphi技巧","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%8A%80%E5%B7%A7/"},{"name":"dcef3使用方法","slug":"dcef3使用方法","permalink":"https://goodhelp.gitee.io/tags/dcef3%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"}]},{"title":"如何自定义修改TChromium的header头信息!","slug":"article/如何自定义修改TChromium的header头信息","date":"2017-11-29T16:05:35.000Z","updated":"2021-09-16T23:43:47.508Z","comments":true,"path":"page/3675410287/","link":"","permalink":"https://goodhelp.gitee.io/page/3675410287/","excerpt":"TChromium自定义post的header信息提交数据1234567891011121314151617181920212223242526272829uses ceflib; function CreateField(const AValue: AnsiString): ICefPostDataElement;begin Result := TCefPostDataElementRef.New; Result.SetToBytes(Length(AValue), PAnsiChar(AValue));end; procedure TForm1.Button1Click(Sender: TObject);var Header: ICefStringMultimap; Data: ICefPostData; Request: ICefRequest;begin Header := TCefStringMultimapOwn.Create; Header.Append(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;); Data := TCefPostDataRef.New; Data.AddElement(CreateField(&#x27;Data.id=27&#x27;)); Data.AddElement(CreateField(&#x27;&amp;Data.title=title&#x27;)); Data.AddElement(CreateField(&#x27;&amp;Data.body=body&#x27;)); Request := TCefRequestRef.New; Request.Flags := WUR_FLAG_NONE; Request.Assign(&#x27;http://example.com/&#x27;, &#x27;POST&#x27;, Data, Header); Chromium1.Browser.MainFrame.LoadRequest(Request);end; 在另一版本中的代码1234567891011121314151617181920212223procedure TForm1.Button1Click(Sender: TObject);var Header: ICefStringMultimap; Data: ICefPostData; Request: ICefRequest;begin Request := TCefRequestRef.New; Request.Url := &#x27;http://example.com/&#x27;; Request.Method := &#x27;POST&#x27;; Request.Flags := WUR_FLAG_NONE; Header := TCefStringMultimapOwn.Create; Header.Append(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;); Request.SetHeaderMap(Header); Data := TCefPostDataRef.New; Data.AddElement(CreateField(&#x27;Data.id=27&#x27;)); Data.AddElement(CreateField(&#x27;&amp;Data.title=title&#x27;)); Data.AddElement(CreateField(&#x27;&amp;Data.body=body&#x27;)); Request.PostData := Data; Chromium1.Browser.MainFrame.LoadRequest(Request);end; TChromium自定义post数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function CreateField(const AValue: AnsiString): ICefPostDataElement;begin Result := TCefPostDataElementRef.New; Result.SetToBytes(Length(AValue), PAnsiChar(AValue));end; //***************************************** procedure POST(total, fee: integer);var Header: ICefStringMultimap; Data: ICefPostData; Request: ICefRequest; Cook: ICefCookieManager;begin Request := TCefRequestRef.New; Request.Url := &#x27;&#x27;; Request.Method := &#x27;POST&#x27;; Request.Flags:=[UR_FLAG_ALLOW_CACHED_CREDENTIALS,UR_FLAG_ALLOW_COOKIES]; Header := TCefStringMultimapOwn.Create; Header.Append(&#x27;Host&#x27;, &#x27;&#x27;); Header.Append(&#x27;User-Agent&#x27;, &#x27;&#x27;); Header.Append(&#x27;Accept&#x27;, &#x27;&#x27;); Header.Append(&#x27;Accept-Language&#x27;, &#x27;&#x27;); Header.Append(&#x27;Accept-Encoding&#x27;, &#x27;&#x27;); Header.Append(&#x27;Content-Type&#x27;, &#x27;&#x27;); Header.Append(&#x27;Referer&#x27;, &#x27;&#x27;); Header.Append(&#x27;Content-Length&#x27;, &#x27;&#x27;); Header.Append(&#x27;Origin&#x27;, &#x27;&#x27;); Header.Append(&#x27;Connection&#x27;, &#x27;&#x27;); Header.Append(&#x27;Pragma&#x27;, &#x27;&#x27;); Header.Append(&#x27;Cache-Control&#x27;, &#x27;&#x27;); Header.Append(&#x27;Cookie&#x27;,&#x27;...&#x27;); ... Header.Append(&#x27;Cookie&#x27;,&#x27;...&#x27;); Request.SetHeaderMap(Header); Data := TCefPostDataRef.New; Data.AddElement(CreateField(&#x27;sessionid=&#x27;+SessionID)); Data.AddElement(CreateField(&#x27;¤cy=5&#x27;)); Data.AddElement(CreateField(&#x27;&amp;subtotal=&#x27;+inttostr(total-fee))); Data.AddElement(CreateField(&#x27;&amp;fee=&#x27;+IntToStr(fee))); Data.AddElement(CreateField(&#x27;&amp;total=&#x27;+IntToStr(total))); Request.PostData := Data; form1.Chromium1.Browser.MainFrame.LoadRequest(Request);end;","text":"TChromium自定义post的header信息提交数据1234567891011121314151617181920212223242526272829uses ceflib; function CreateField(const AValue: AnsiString): ICefPostDataElement;begin Result := TCefPostDataElementRef.New; Result.SetToBytes(Length(AValue), PAnsiChar(AValue));end; procedure TForm1.Button1Click(Sender: TObject);var Header: ICefStringMultimap; Data: ICefPostData; Request: ICefRequest;begin Header := TCefStringMultimapOwn.Create; Header.Append(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;); Data := TCefPostDataRef.New; Data.AddElement(CreateField(&#x27;Data.id=27&#x27;)); Data.AddElement(CreateField(&#x27;&amp;Data.title=title&#x27;)); Data.AddElement(CreateField(&#x27;&amp;Data.body=body&#x27;)); Request := TCefRequestRef.New; Request.Flags := WUR_FLAG_NONE; Request.Assign(&#x27;http://example.com/&#x27;, &#x27;POST&#x27;, Data, Header); Chromium1.Browser.MainFrame.LoadRequest(Request);end; 在另一版本中的代码1234567891011121314151617181920212223procedure TForm1.Button1Click(Sender: TObject);var Header: ICefStringMultimap; Data: ICefPostData; Request: ICefRequest;begin Request := TCefRequestRef.New; Request.Url := &#x27;http://example.com/&#x27;; Request.Method := &#x27;POST&#x27;; Request.Flags := WUR_FLAG_NONE; Header := TCefStringMultimapOwn.Create; Header.Append(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;); Request.SetHeaderMap(Header); Data := TCefPostDataRef.New; Data.AddElement(CreateField(&#x27;Data.id=27&#x27;)); Data.AddElement(CreateField(&#x27;&amp;Data.title=title&#x27;)); Data.AddElement(CreateField(&#x27;&amp;Data.body=body&#x27;)); Request.PostData := Data; Chromium1.Browser.MainFrame.LoadRequest(Request);end; TChromium自定义post数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function CreateField(const AValue: AnsiString): ICefPostDataElement;begin Result := TCefPostDataElementRef.New; Result.SetToBytes(Length(AValue), PAnsiChar(AValue));end; //***************************************** procedure POST(total, fee: integer);var Header: ICefStringMultimap; Data: ICefPostData; Request: ICefRequest; Cook: ICefCookieManager;begin Request := TCefRequestRef.New; Request.Url := &#x27;&#x27;; Request.Method := &#x27;POST&#x27;; Request.Flags:=[UR_FLAG_ALLOW_CACHED_CREDENTIALS,UR_FLAG_ALLOW_COOKIES]; Header := TCefStringMultimapOwn.Create; Header.Append(&#x27;Host&#x27;, &#x27;&#x27;); Header.Append(&#x27;User-Agent&#x27;, &#x27;&#x27;); Header.Append(&#x27;Accept&#x27;, &#x27;&#x27;); Header.Append(&#x27;Accept-Language&#x27;, &#x27;&#x27;); Header.Append(&#x27;Accept-Encoding&#x27;, &#x27;&#x27;); Header.Append(&#x27;Content-Type&#x27;, &#x27;&#x27;); Header.Append(&#x27;Referer&#x27;, &#x27;&#x27;); Header.Append(&#x27;Content-Length&#x27;, &#x27;&#x27;); Header.Append(&#x27;Origin&#x27;, &#x27;&#x27;); Header.Append(&#x27;Connection&#x27;, &#x27;&#x27;); Header.Append(&#x27;Pragma&#x27;, &#x27;&#x27;); Header.Append(&#x27;Cache-Control&#x27;, &#x27;&#x27;); Header.Append(&#x27;Cookie&#x27;,&#x27;...&#x27;); ... Header.Append(&#x27;Cookie&#x27;,&#x27;...&#x27;); Request.SetHeaderMap(Header); Data := TCefPostDataRef.New; Data.AddElement(CreateField(&#x27;sessionid=&#x27;+SessionID)); Data.AddElement(CreateField(&#x27;¤cy=5&#x27;)); Data.AddElement(CreateField(&#x27;&amp;subtotal=&#x27;+inttostr(total-fee))); Data.AddElement(CreateField(&#x27;&amp;fee=&#x27;+IntToStr(fee))); Data.AddElement(CreateField(&#x27;&amp;total=&#x27;+IntToStr(total))); Request.PostData := Data; form1.Chromium1.Browser.MainFrame.LoadRequest(Request);end;","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"delphi技巧","slug":"delphi技巧","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%8A%80%E5%B7%A7/"},{"name":"dcef3使用方法","slug":"dcef3使用方法","permalink":"https://goodhelp.gitee.io/tags/dcef3%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"}]},{"title":"如何让dcef3支持mp3和h.264_mp4解码播放(有源码及dll)!","slug":"article/如何让dcef3支持mp3和h-264-mp4解码播放-有源码及dll","date":"2017-11-28T16:00:23.000Z","updated":"2021-09-16T23:35:47.100Z","comments":true,"path":"page/43472519/","link":"","permalink":"https://goodhelp.gitee.io/page/43472519/","excerpt":"嵌入式Chromium框架(简称CEF) 是一个由Marshall Greenblatt在2008建立的开源项目，它主要目的是开发一个基于Google Chromium的Webbrowser控件。CEF支持一系列的编程语言和操作系统，并且能很容易地整合到新的或已有的工程中去。它的设计思想政治就是易用且兼顾性能。CEF基本的框架包含C/C++程序接口，通过本地库的接口来实现，而这个库则会隔离宿主程序和Chromium&amp;Webkit的操作细节。它在浏览器控件和宿主程序之间提供紧密的整合，它支持用户插件，协议，javascript对象以及javascript扩展，宿主程序可以随意地控件资源下载，导航，下下文内容和打印等，并且可以跟Google Chrome浏览器一起，支持高性能和Html5 技术 为什么chromium不支持mp3和h.264的mp4音视频解码，因为h.264编码并非开源，是需要付费的!所以就存在谷歌自己的浏览器chrome能支持mp4和tchromium不支持mp4!如何查看你的tchromium是否支持mp4呢？你用tchromium写一个简单浏览器，然后打开http://html5test.com 支持是这样显示的 而不支持是这样显示的 也就是支持h.264 support mp3 support和aac support应该是钩! 要让cef支持mp3和mp4，需要自己编译，如果你对自己如何编辑有兴趣可以看这篇文件 在Windows下编译Cef3.2623并加入mp3、mp4支持 对于delphi用户，如何让在delphi中dcef3支持mp3和mp4呢？先到这儿下载dcef3 3.2623.1401 http://download.csdn.net/download/cyu/9917747 (如果没有积分就到这儿下载 链接：https://pan.baidu.com/s/1dFETI0L 密码：gult ) 你也可以安装dcefbrowser，封装后的dcef3 这儿下载dcefbrowser3.2623.1401 https://github.com/bccsafe/DcefBrowser (你也可以到这儿下载dcefbrowser 链接：https://pan.baidu.com/s/1dFB5Zv7 密码：fljs )不管你是下载的dcef3 3.2623.1401 还是下载的dcefbrowser 3.2623.1401都可以，安装控件后，运行示例程序，这时你的dcef是不支持mp3和mp4的，为什么呢？因为h.264等编码问题，作者打包的dll库文件是默认不支持mp3和mp4的! 如何让delphi中dcef3支持mp3和mp4呢？你只需要到这儿下载 链接：https://pan.baidu.com/s/1c1DZ1DY 密码：sqir 已经编译好支持mp3和mp4的dll库，覆盖到前面安装的控件中，就OK了，因为这个dll库是对应于dcef3.2623.1401，所以dcef必须也要安装3.26.23.1401。如何让delphi中dcef3支持mp3和mp4呢?因为非开源问题，所以自己编译dcef3的dll库的不多，提供下载的也不多，为了让你的dcef3支持mp3和mp4，我们只要找对应的版本就可以使用了!为什么非要指定dcef3为3.2623.1401，这是因为编译cef的dll需要开启mp3和mp4支持，网上提供其他版本的cef的dll库，并且加入了支持mp3和mp4的没有，如果你会C++，会自己编译cef的库，那什么版本都一样，都可以支持mp3和mp4 附dcef3另一版本及库文件：dcef3.2454 下载http://download.csdn.net/download/bigcoolfish/9616325 相对应已添加支持mp3和mp4的 dcef3.2454 dll库文件下载 https://pan.baidu.com/s/1pKHbeY3 密码: mxr2","text":"嵌入式Chromium框架(简称CEF) 是一个由Marshall Greenblatt在2008建立的开源项目，它主要目的是开发一个基于Google Chromium的Webbrowser控件。CEF支持一系列的编程语言和操作系统，并且能很容易地整合到新的或已有的工程中去。它的设计思想政治就是易用且兼顾性能。CEF基本的框架包含C/C++程序接口，通过本地库的接口来实现，而这个库则会隔离宿主程序和Chromium&amp;Webkit的操作细节。它在浏览器控件和宿主程序之间提供紧密的整合，它支持用户插件，协议，javascript对象以及javascript扩展，宿主程序可以随意地控件资源下载，导航，下下文内容和打印等，并且可以跟Google Chrome浏览器一起，支持高性能和Html5 技术 为什么chromium不支持mp3和h.264的mp4音视频解码，因为h.264编码并非开源，是需要付费的!所以就存在谷歌自己的浏览器chrome能支持mp4和tchromium不支持mp4!如何查看你的tchromium是否支持mp4呢？你用tchromium写一个简单浏览器，然后打开http://html5test.com 支持是这样显示的 而不支持是这样显示的 也就是支持h.264 support mp3 support和aac support应该是钩! 要让cef支持mp3和mp4，需要自己编译，如果你对自己如何编辑有兴趣可以看这篇文件 在Windows下编译Cef3.2623并加入mp3、mp4支持 对于delphi用户，如何让在delphi中dcef3支持mp3和mp4呢？先到这儿下载dcef3 3.2623.1401 http://download.csdn.net/download/cyu/9917747 (如果没有积分就到这儿下载 链接：https://pan.baidu.com/s/1dFETI0L 密码：gult ) 你也可以安装dcefbrowser，封装后的dcef3 这儿下载dcefbrowser3.2623.1401 https://github.com/bccsafe/DcefBrowser (你也可以到这儿下载dcefbrowser 链接：https://pan.baidu.com/s/1dFB5Zv7 密码：fljs )不管你是下载的dcef3 3.2623.1401 还是下载的dcefbrowser 3.2623.1401都可以，安装控件后，运行示例程序，这时你的dcef是不支持mp3和mp4的，为什么呢？因为h.264等编码问题，作者打包的dll库文件是默认不支持mp3和mp4的! 如何让delphi中dcef3支持mp3和mp4呢？你只需要到这儿下载 链接：https://pan.baidu.com/s/1c1DZ1DY 密码：sqir 已经编译好支持mp3和mp4的dll库，覆盖到前面安装的控件中，就OK了，因为这个dll库是对应于dcef3.2623.1401，所以dcef必须也要安装3.26.23.1401。如何让delphi中dcef3支持mp3和mp4呢?因为非开源问题，所以自己编译dcef3的dll库的不多，提供下载的也不多，为了让你的dcef3支持mp3和mp4，我们只要找对应的版本就可以使用了!为什么非要指定dcef3为3.2623.1401，这是因为编译cef的dll需要开启mp3和mp4支持，网上提供其他版本的cef的dll库，并且加入了支持mp3和mp4的没有，如果你会C++，会自己编译cef的库，那什么版本都一样，都可以支持mp3和mp4 附dcef3另一版本及库文件：dcef3.2454 下载http://download.csdn.net/download/bigcoolfish/9616325 相对应已添加支持mp3和mp4的 dcef3.2454 dll库文件下载 https://pan.baidu.com/s/1pKHbeY3 密码: mxr2","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"delphi技巧","slug":"delphi技巧","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%8A%80%E5%B7%A7/"},{"name":"dcef3","slug":"dcef3","permalink":"https://goodhelp.gitee.io/tags/dcef3/"}]},{"title":"如何查出桌面的弹出窗口是谁创建的?","slug":"article/如何查出桌面的弹出窗口是谁创建的","date":"2017-11-26T15:49:29.000Z","updated":"2021-09-16T23:44:47.610Z","comments":true,"path":"page/2806439394/","link":"","permalink":"https://goodhelp.gitee.io/page/2806439394/","excerpt":"做为PC系统，很大一部份是使用的windows，windows的广告软件很多，不小心就会在桌面上弹出一个窗口，凭肉眼，用任务管理器，很难看出是哪个程序创建的弹出窗口，本文件介绍用句柄精灵ViewWizard找出桌面弹出窗口是什么程序创建的!来看看桌面出现的这个弹出窗口在开机运行QQ后不久就在桌面右下角弹出这个窗口，任务栏没有任何程序出现！ 打开 句柄精灵ViewWizard (下载句柄精灵请到 http://www.bnwin.com/2017/11/03/202.html) 界面如下 鼠标按住 句柄精灵的 十字图标拖到这个弹出的窗口上！ 这时句柄精灵就显示出来这个程序的所有信息 这个窗口的模块是 C:\\Users\\Administrator\\AppData\\Local\\Temp\\QXREPAIR1.DLL 往下面拉，看看进程是谁 exe执行文件在 C:\\Users\\Administrator\\AppData\\Local\\Temp\\PZYTOOLS\\XFIXER.exe 是由谁创建的呢？父进程是 916 [svchost.exe] 找到了是谁创建的，是什么进程，就可以相应的进行控制了!你可以禁止XFIXER.exe的运行，或者禁止svchost.exe在temp目录创建xfixer.exe文件等！ 你也可以根据句柄精灵提供的窗口信息进行自动关闭!对于这种有独立进程的弹出窗口你可能通过任务管理器也能查找到，虽然没有使用句柄精灵方便，但通过其他程序加载dll库文件弹出的窗口，通过任务管理器就无能为力了! 我们来看看英雄联盟选择英雄时左边的窗口是谁创建的 打开句柄精灵，拖动十字图标到这个窗口上，看看句柄精灵中的信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121属性 数据基本&gt;句柄 67140 [0x00010644]文本长度 0类名 TWINCONTROL基类 Generic描述 通用窗口ID *数据 0x130B9478字节 *实例 *模块 I:\\游戏辅助\\TGP腾讯游戏平台网吧版\\apps\\Pallas\\pallas.exe父窗&gt;句柄 [65552]文本 [Desktop]类名 [#32769]基类 [Generic]显示&gt;状态 常规&gt;可视 yes有效 yes置顶 yes分层 no透明 no重叠 no不活动 noUnicode yes密码框 no掩码不透明度 *Z序 3大小&gt;窗口矩形 (1508,415)-(1810,798) 302×383还原矩形 (1508,415)-(1810,798) 302×383客户矩形(屏幕) (1508,415)-(1810,798) 302×383客户矩形(窗口) (0,0)-(302,383) 302×383最大化坐标 (0,0) 1920×1050最小最大尺寸 0x0 1930×1057当前窗口坐标当前客户坐标关系&gt;父窗口 65552 [0x00010010] #32769 “Desktop”根窗口 *所有者窗口 *首个子窗口 *首兄弟窗口 394540 [0x0006052C] MSCTFIME UI “MSCTFIME UI”上一个窗口 918714 [0x000E04BA] IME “Default IME”下一个窗口 198612 [0x000307D4] Auto-Suggest Dropdown “”尾兄弟窗口 65812 [0x00010114] Progman “Program Manager”样式&gt;标准样式 0x96020000 (2516713472)描述 WS_POPUP|WS_VISIBLE|WS_CLIPSIBLINGS|WS_CLIPCHILDREN|WS_GROUP控件扩展样式 0x00000088 (136)描述 WS_EX_TOPMOST|WS_EX_TOOLWINDOW控件类&gt;类名 TWINCONTROL类原子 0xC2CC (49868)类字节 *窗口字节 *类样式 0x00000008 (8)描述 CS_DBLCLKS图标 *小图标 *光标 0x00010003 IDC_ARROW画刷 *菜单 *过程 0x55C1AD90 (1438756240) [Unicode]模块 0x00400000 (4194304)模块路径 I:\\游戏辅助\\TGP腾讯游戏平台网吧版\\apps\\Pallas\\pallas.exe菜单&gt;句柄 *子菜单所有子菜单菜单项菜单矩形字体&gt;句柄 *名称大小粗体斜体删除线下划线字符集进程&gt;进程ID 7060 [0x00001B94]线程ID 2560 [0x00000A00]进程启动 2017-11-26 16:32:06线程启动 2017-11-26 16:32:06内存使用 32,248 KB内存峰值 91,252 KB虚拟内存 82,008 KB线程计数 17句柄计数 324GUI对象 GDI:52, User:40映像名称 pallas.exeEXE路径 I:\\游戏辅助\\TGP腾讯游戏平台网吧版\\apps\\Pallas\\pallas.exe物理路径 I:\\游戏辅助\\TGP腾讯游戏平台网吧版\\apps\\Pallas\\pallas.exe命令行父进程 6444 [tgp_daemon.exe]文件&gt;名称 pallas.exe大小 7390408版本 4.1.1.123版权 Copyright (C) 2015 Tencent.All Rights Reserved产品 WeGame公司 腾讯计算机系统有限公司描述 Tencent.WeGame.Pallas创建时间 2015-12-31 21:14:44统计&gt;子窗口所有子窗口无效子窗口隐藏子窗口线程窗口 12进程窗口 12附加&gt;基本类型 Generic (通用) 正确使用句柄精灵，可以找出广告程序等弹出窗口的幕后黑手！","text":"做为PC系统，很大一部份是使用的windows，windows的广告软件很多，不小心就会在桌面上弹出一个窗口，凭肉眼，用任务管理器，很难看出是哪个程序创建的弹出窗口，本文件介绍用句柄精灵ViewWizard找出桌面弹出窗口是什么程序创建的!来看看桌面出现的这个弹出窗口在开机运行QQ后不久就在桌面右下角弹出这个窗口，任务栏没有任何程序出现！ 打开 句柄精灵ViewWizard (下载句柄精灵请到 http://www.bnwin.com/2017/11/03/202.html) 界面如下 鼠标按住 句柄精灵的 十字图标拖到这个弹出的窗口上！ 这时句柄精灵就显示出来这个程序的所有信息 这个窗口的模块是 C:\\Users\\Administrator\\AppData\\Local\\Temp\\QXREPAIR1.DLL 往下面拉，看看进程是谁 exe执行文件在 C:\\Users\\Administrator\\AppData\\Local\\Temp\\PZYTOOLS\\XFIXER.exe 是由谁创建的呢？父进程是 916 [svchost.exe] 找到了是谁创建的，是什么进程，就可以相应的进行控制了!你可以禁止XFIXER.exe的运行，或者禁止svchost.exe在temp目录创建xfixer.exe文件等！ 你也可以根据句柄精灵提供的窗口信息进行自动关闭!对于这种有独立进程的弹出窗口你可能通过任务管理器也能查找到，虽然没有使用句柄精灵方便，但通过其他程序加载dll库文件弹出的窗口，通过任务管理器就无能为力了! 我们来看看英雄联盟选择英雄时左边的窗口是谁创建的 打开句柄精灵，拖动十字图标到这个窗口上，看看句柄精灵中的信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121属性 数据基本&gt;句柄 67140 [0x00010644]文本长度 0类名 TWINCONTROL基类 Generic描述 通用窗口ID *数据 0x130B9478字节 *实例 *模块 I:\\游戏辅助\\TGP腾讯游戏平台网吧版\\apps\\Pallas\\pallas.exe父窗&gt;句柄 [65552]文本 [Desktop]类名 [#32769]基类 [Generic]显示&gt;状态 常规&gt;可视 yes有效 yes置顶 yes分层 no透明 no重叠 no不活动 noUnicode yes密码框 no掩码不透明度 *Z序 3大小&gt;窗口矩形 (1508,415)-(1810,798) 302×383还原矩形 (1508,415)-(1810,798) 302×383客户矩形(屏幕) (1508,415)-(1810,798) 302×383客户矩形(窗口) (0,0)-(302,383) 302×383最大化坐标 (0,0) 1920×1050最小最大尺寸 0x0 1930×1057当前窗口坐标当前客户坐标关系&gt;父窗口 65552 [0x00010010] #32769 “Desktop”根窗口 *所有者窗口 *首个子窗口 *首兄弟窗口 394540 [0x0006052C] MSCTFIME UI “MSCTFIME UI”上一个窗口 918714 [0x000E04BA] IME “Default IME”下一个窗口 198612 [0x000307D4] Auto-Suggest Dropdown “”尾兄弟窗口 65812 [0x00010114] Progman “Program Manager”样式&gt;标准样式 0x96020000 (2516713472)描述 WS_POPUP|WS_VISIBLE|WS_CLIPSIBLINGS|WS_CLIPCHILDREN|WS_GROUP控件扩展样式 0x00000088 (136)描述 WS_EX_TOPMOST|WS_EX_TOOLWINDOW控件类&gt;类名 TWINCONTROL类原子 0xC2CC (49868)类字节 *窗口字节 *类样式 0x00000008 (8)描述 CS_DBLCLKS图标 *小图标 *光标 0x00010003 IDC_ARROW画刷 *菜单 *过程 0x55C1AD90 (1438756240) [Unicode]模块 0x00400000 (4194304)模块路径 I:\\游戏辅助\\TGP腾讯游戏平台网吧版\\apps\\Pallas\\pallas.exe菜单&gt;句柄 *子菜单所有子菜单菜单项菜单矩形字体&gt;句柄 *名称大小粗体斜体删除线下划线字符集进程&gt;进程ID 7060 [0x00001B94]线程ID 2560 [0x00000A00]进程启动 2017-11-26 16:32:06线程启动 2017-11-26 16:32:06内存使用 32,248 KB内存峰值 91,252 KB虚拟内存 82,008 KB线程计数 17句柄计数 324GUI对象 GDI:52, User:40映像名称 pallas.exeEXE路径 I:\\游戏辅助\\TGP腾讯游戏平台网吧版\\apps\\Pallas\\pallas.exe物理路径 I:\\游戏辅助\\TGP腾讯游戏平台网吧版\\apps\\Pallas\\pallas.exe命令行父进程 6444 [tgp_daemon.exe]文件&gt;名称 pallas.exe大小 7390408版本 4.1.1.123版权 Copyright (C) 2015 Tencent.All Rights Reserved产品 WeGame公司 腾讯计算机系统有限公司描述 Tencent.WeGame.Pallas创建时间 2015-12-31 21:14:44统计&gt;子窗口所有子窗口无效子窗口隐藏子窗口线程窗口 12进程窗口 12附加&gt;基本类型 Generic (通用) 正确使用句柄精灵，可以找出广告程序等弹出窗口的幕后黑手！","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"去广告方法","slug":"去广告方法","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%BB%E5%B9%BF%E5%91%8A%E6%96%B9%E6%B3%95/"}]},{"title":"如何让手机控制电脑之TeamViewer","slug":"soft/如何让手机控制电脑之TeamViewer","date":"2017-11-22T03:53:21.000Z","updated":"2021-09-11T16:44:56.916Z","comments":true,"path":"page/3502241198/","link":"","permalink":"https://goodhelp.gitee.io/page/3502241198/","excerpt":"TeamViewer是一个能在任何防火墙和NAT代理的后台用于远程控制，桌面共享和文件传输的简单且快速的解决方案。为了连接到另一台计算机，只需要在两台计算机上同时运行 TeamViewer 即可，而不需要进行安装（也可以选择安装，安装后可以设置开机运行）。该软件第一次启动在两台计算机上自动生成伙伴 ID。只需要输入你的伙伴的ID到TeamViewer，然后就会立即建立起连接。TeamViewer官方网站:https://www.teamviewer.com/zhCN/ 如何使用手机控制电脑呢？ 在TeamViewer官方网站下载相应的App,比如Android版TeamViewer下载地址为https://play.google.com/store/apps/details?id=com.teamviewer.teamviewer.market.mobile,不过你可以直接在你的手机应用市场中搜索TeamViewer，也可以下载安装TeamViewer的app安装!Android手机安装成功运行的界面如下 在电脑中运行TeamViewer，界面如下: 只要在手机的伙伴ＩＤ处输入电脑端显示的ＩＤ，点击远程控制，输入电脑端的密码，就可以在手机中控制电脑了，连接成功后的界面如下 点继续后就可以操控电脑了 电脑端运行TeamViewer，每次运行，密码都不一样，为了便于控制，我们要设置一个固定的密码，实现无人值守！点击电脑端显示的密码，会弹出一个菜单，选择 设置预定义密码，界面如下 这样做了以后，只要在电脑中TeamViewer的其他菜单的选项点开，钩上随windows一同启动TeamViewer，就可以在手机上输入电脑端teamviewer的id和预设的固定密码，从手机控制电脑了!但这时你是不是觉得还不够方便？为了更自动化一些，我们需要注册一个TeamViewer的控制帐号!在手机端是不是有一个计算机选项卡，点击后有一个注册按钮，你只要注册了帐号，你第一次登录，teamviewer会发一封添加允许设备登录的邮件，也就是只有允许的设备才能使用，这样安全性就高了!允许的设备登录帐号后，就可以添加电脑端的ID和密码，以后在手机中，只要登录帐号，直接点击你预添加的计算机就可以控制了，不需要你记和输ＩＤ和密码! TeamViewer最新版需要授权许可才能使用 Teamviewer连接的原理主要分为三部分，分别是①如何根据ID找到要连接的电脑，②找到电脑之后如何内网间互联，③如何能操作对方的电脑。一、先说TeamViewer如何根据ID连接到对方： 1、运行TeamViewer 之后，电脑会先连接到TV的服务器，然后服务器对这台电脑分配一个唯一的ID。这个ID主要是以网卡的MAC地址为依据生成的，所以如果想给电脑换一个Teamviewer ID，只要修改一下MAC地址就行了。 2、当一个TeamViewer 连接另一个的时候，会先连接到服务器，通过ID与电脑的对应关系找到这台要连接的电脑。 二、如何建立内网对内网的连接： 如果连接的其中任一方是有公网IP的网络环境，双方的连接就启用P2P连接。双方是内网的情况， TeamViewer数据就会通过TeamViewer 自己的服务器进行中转。这也是TeamViewer 内网互通会在网络高峰期比较慢的原因。 三、如何操作被控机的鼠标与键盘。 原理与远程控制木马是一样的。这里远端指被控制的电脑。连接建立之后，远端的电脑图像压缩后发回本地，这样本地就能看到画面，本地进行键盘鼠标的等操作的动作封装成数据包发送给远端解开后还原成动作进行远程的模拟操作。远端反馈的画面通过压缩后继续发回给控制端。就远控的图像传输来说，早年远控都是直接进行JPEG截图后传输，所以速度不太理想。之后各种大牛延伸出很多很腻害的基于截图的方式的屏幕传输的算法，传输效率进一步提高，通常是先加载一个虚拟屏幕驱动，然后对屏幕做逐行扫描，然后计算变化的部分，之后只传输变化的部分。TeamViewer(版本9.0)也是支持虚拟屏幕驱动的，但是需要到设置中手动进行安装。","text":"TeamViewer是一个能在任何防火墙和NAT代理的后台用于远程控制，桌面共享和文件传输的简单且快速的解决方案。为了连接到另一台计算机，只需要在两台计算机上同时运行 TeamViewer 即可，而不需要进行安装（也可以选择安装，安装后可以设置开机运行）。该软件第一次启动在两台计算机上自动生成伙伴 ID。只需要输入你的伙伴的ID到TeamViewer，然后就会立即建立起连接。TeamViewer官方网站:https://www.teamviewer.com/zhCN/ 如何使用手机控制电脑呢？ 在TeamViewer官方网站下载相应的App,比如Android版TeamViewer下载地址为https://play.google.com/store/apps/details?id=com.teamviewer.teamviewer.market.mobile,不过你可以直接在你的手机应用市场中搜索TeamViewer，也可以下载安装TeamViewer的app安装!Android手机安装成功运行的界面如下 在电脑中运行TeamViewer，界面如下: 只要在手机的伙伴ＩＤ处输入电脑端显示的ＩＤ，点击远程控制，输入电脑端的密码，就可以在手机中控制电脑了，连接成功后的界面如下 点继续后就可以操控电脑了 电脑端运行TeamViewer，每次运行，密码都不一样，为了便于控制，我们要设置一个固定的密码，实现无人值守！点击电脑端显示的密码，会弹出一个菜单，选择 设置预定义密码，界面如下 这样做了以后，只要在电脑中TeamViewer的其他菜单的选项点开，钩上随windows一同启动TeamViewer，就可以在手机上输入电脑端teamviewer的id和预设的固定密码，从手机控制电脑了!但这时你是不是觉得还不够方便？为了更自动化一些，我们需要注册一个TeamViewer的控制帐号!在手机端是不是有一个计算机选项卡，点击后有一个注册按钮，你只要注册了帐号，你第一次登录，teamviewer会发一封添加允许设备登录的邮件，也就是只有允许的设备才能使用，这样安全性就高了!允许的设备登录帐号后，就可以添加电脑端的ID和密码，以后在手机中，只要登录帐号，直接点击你预添加的计算机就可以控制了，不需要你记和输ＩＤ和密码! TeamViewer最新版需要授权许可才能使用 Teamviewer连接的原理主要分为三部分，分别是①如何根据ID找到要连接的电脑，②找到电脑之后如何内网间互联，③如何能操作对方的电脑。一、先说TeamViewer如何根据ID连接到对方： 1、运行TeamViewer 之后，电脑会先连接到TV的服务器，然后服务器对这台电脑分配一个唯一的ID。这个ID主要是以网卡的MAC地址为依据生成的，所以如果想给电脑换一个Teamviewer ID，只要修改一下MAC地址就行了。 2、当一个TeamViewer 连接另一个的时候，会先连接到服务器，通过ID与电脑的对应关系找到这台要连接的电脑。 二、如何建立内网对内网的连接： 如果连接的其中任一方是有公网IP的网络环境，双方的连接就启用P2P连接。双方是内网的情况， TeamViewer数据就会通过TeamViewer 自己的服务器进行中转。这也是TeamViewer 内网互通会在网络高峰期比较慢的原因。 三、如何操作被控机的鼠标与键盘。 原理与远程控制木马是一样的。这里远端指被控制的电脑。连接建立之后，远端的电脑图像压缩后发回本地，这样本地就能看到画面，本地进行键盘鼠标的等操作的动作封装成数据包发送给远端解开后还原成动作进行远程的模拟操作。远端反馈的画面通过压缩后继续发回给控制端。就远控的图像传输来说，早年远控都是直接进行JPEG截图后传输，所以速度不太理想。之后各种大牛延伸出很多很腻害的基于截图的方式的屏幕传输的算法，传输效率进一步提高，通常是先加载一个虚拟屏幕驱动，然后对屏幕做逐行扫描，然后计算变化的部分，之后只传输变化的部分。TeamViewer(版本9.0)也是支持虚拟屏幕驱动的，但是需要到设置中手动进行安装。","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"精品软件","slug":"精品软件","permalink":"https://goodhelp.gitee.io/tags/%E7%B2%BE%E5%93%81%E8%BD%AF%E4%BB%B6/"}]},{"title":"如何使unigui支持多文件上传-MultiFileUpload","slug":"code/如何使unigui支持多文件上传-MultiFileUpload","date":"2017-11-20T04:47:47.000Z","updated":"2021-09-16T23:56:04.022Z","comments":true,"path":"page/2263726181/","link":"","permalink":"https://goodhelp.gitee.io/page/2263726181/","excerpt":"unigui能上传文件，单只支持单文件上传，在unigui中如何实现多文件上传呢？MultiFileUpload提供了解决方案!此例子使用MultiFileUpload解决了unigui多文件上传的问题看看运行效果其中部份代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344procedure TDialogFileUpload.UniFormClose(Sender: TObject; var Action: TCloseAction);var I: Integer;begin if FIsUploading then begin //正在上传，不允许退出 Action := caNone; ModalResult := mrNone; Exit; end; if ModalResult=mrOK then begin if FListFiles.Count=0 then begin MessageDlg(&#x27;请选择文件并上传！&#x27;,mtInformation,[mbOK],nil); Action := caNone; ModalResult := mrNone; Exit; end; for I := 0 to FListFiles.Count - 1 do begin if Integer(FListFiles.Objects[I])=0 then begin MessageDlg(&#x27;请上传选择的文件！&#x27;,mtInformation,[mbOK],nil); Action := caNone; ModalResult := mrNone; Exit; end; end; if Assigned(FOnGetUploadFiles) then begin FOnGetUploadFiles(Self,FListFiles,FListFileSizes); end; end; //关闭时清除所有文件 FListFiles.Clear; FListFileSizes.Clear; UniSession.AddJS(&#x27;panelUpload.onRemove();&#x27;);end; 源码下载地址：链接: https://pan.baidu.com/s/1JYlHKLu2WZHXIc3MdNez7Q 提取码: srz4 复制这段内容后打开百度网盘手机App，操作更方便哦","text":"unigui能上传文件，单只支持单文件上传，在unigui中如何实现多文件上传呢？MultiFileUpload提供了解决方案!此例子使用MultiFileUpload解决了unigui多文件上传的问题看看运行效果其中部份代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344procedure TDialogFileUpload.UniFormClose(Sender: TObject; var Action: TCloseAction);var I: Integer;begin if FIsUploading then begin //正在上传，不允许退出 Action := caNone; ModalResult := mrNone; Exit; end; if ModalResult=mrOK then begin if FListFiles.Count=0 then begin MessageDlg(&#x27;请选择文件并上传！&#x27;,mtInformation,[mbOK],nil); Action := caNone; ModalResult := mrNone; Exit; end; for I := 0 to FListFiles.Count - 1 do begin if Integer(FListFiles.Objects[I])=0 then begin MessageDlg(&#x27;请上传选择的文件！&#x27;,mtInformation,[mbOK],nil); Action := caNone; ModalResult := mrNone; Exit; end; end; if Assigned(FOnGetUploadFiles) then begin FOnGetUploadFiles(Self,FListFiles,FListFileSizes); end; end; //关闭时清除所有文件 FListFiles.Clear; FListFileSizes.Clear; UniSession.AddJS(&#x27;panelUpload.onRemove();&#x27;);end; 源码下载地址：链接: https://pan.baidu.com/s/1JYlHKLu2WZHXIc3MdNez7Q 提取码: srz4 复制这段内容后打开百度网盘手机App，操作更方便哦","categories":[{"name":"源码","slug":"code","permalink":"https://goodhelp.gitee.io/categories/code/"}],"tags":[{"name":"delphi源码","slug":"delphi源码","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%BA%90%E7%A0%81/"},{"name":"unigui使用方法","slug":"unigui使用方法","permalink":"https://goodhelp.gitee.io/tags/unigui%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"}]},{"title":"使用plupload和fineuploader组件强化unigui文件上传功能!","slug":"code/使用plupload和fineuploader组件强化unigui文件上传功能","date":"2017-11-20T04:44:43.000Z","updated":"2021-09-16T23:55:38.709Z","comments":true,"path":"page/3576835458/","link":"","permalink":"https://goodhelp.gitee.io/page/3576835458/","excerpt":"unigui有上传组件，但功能不强，要想实现强大的功能，那么就得使用其他组件，以下介绍unigui中使用plupload和fineuploader上传文件 unigui使用前端上传组件plupload上传文件,改进文件上传，显示文件上传进度先看看效果图片 Plupload有以下功能和特点： 1、拥有多种上传方式：HTML5、flash、silverlight以及传统的。Plupload会自动侦测当前的环境，选择最合适的上传方式，并且会优先使用HTML5的方式。所以你完全不用去操心当前的浏览器支持哪些上传方式，Plupload会自动为你选择最合适的方式。 2、支持以拖拽的方式来选取要上传的文件 3、支持在前端压缩图片，即在图片文件还未上传之前就对它进行压缩 4、可以直接读取原生的文件数据，这样的好处就是例如可以在图片文件还未上传之前就能把它显示在页面上预览 5、支持把大文件切割成小片进行上传，因为有些浏览器对很大的文件比如几G的一些文件无法上传。 unigui使用前端上传组件fineuploader上传文件，增强文件上传先看看效果图片 Fine Uploader 采用ajax方式实现对文件上传.同时在浏览器中直接支持文件拖拽[对浏览器版本有要求类似IE版本必须是9或是更高的IE10].在不同浏览器中提供统一用户体验.该组件基本覆盖目前所有主流浏览器.同时没有任何第三方组件依赖.相当Clear.在服务器端已经覆盖支持了ASP.NET/ColdFusion/Java/Node.js/Perl/PHP/Python. 对上传细节类似限制文件大小，文件类型，文件上传的数量等通过统一接口以暴露选项方式操作.可以到这儿Github 上Fine Uploader 查看具体内容 delphi使用unigui源码下载地址链接: https://pan.baidu.com/s/10zOTt4eKqsDHnwHCDPp5ng 提取码: nenp 复制这段内容后打开百度网盘手机App，操作更方便哦","text":"unigui有上传组件，但功能不强，要想实现强大的功能，那么就得使用其他组件，以下介绍unigui中使用plupload和fineuploader上传文件 unigui使用前端上传组件plupload上传文件,改进文件上传，显示文件上传进度先看看效果图片 Plupload有以下功能和特点： 1、拥有多种上传方式：HTML5、flash、silverlight以及传统的。Plupload会自动侦测当前的环境，选择最合适的上传方式，并且会优先使用HTML5的方式。所以你完全不用去操心当前的浏览器支持哪些上传方式，Plupload会自动为你选择最合适的方式。 2、支持以拖拽的方式来选取要上传的文件 3、支持在前端压缩图片，即在图片文件还未上传之前就对它进行压缩 4、可以直接读取原生的文件数据，这样的好处就是例如可以在图片文件还未上传之前就能把它显示在页面上预览 5、支持把大文件切割成小片进行上传，因为有些浏览器对很大的文件比如几G的一些文件无法上传。 unigui使用前端上传组件fineuploader上传文件，增强文件上传先看看效果图片 Fine Uploader 采用ajax方式实现对文件上传.同时在浏览器中直接支持文件拖拽[对浏览器版本有要求类似IE版本必须是9或是更高的IE10].在不同浏览器中提供统一用户体验.该组件基本覆盖目前所有主流浏览器.同时没有任何第三方组件依赖.相当Clear.在服务器端已经覆盖支持了ASP.NET/ColdFusion/Java/Node.js/Perl/PHP/Python. 对上传细节类似限制文件大小，文件类型，文件上传的数量等通过统一接口以暴露选项方式操作.可以到这儿Github 上Fine Uploader 查看具体内容 delphi使用unigui源码下载地址链接: https://pan.baidu.com/s/10zOTt4eKqsDHnwHCDPp5ng 提取码: nenp 复制这段内容后打开百度网盘手机App，操作更方便哦","categories":[{"name":"源码","slug":"code","permalink":"https://goodhelp.gitee.io/categories/code/"}],"tags":[{"name":"delphi源码","slug":"delphi源码","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%BA%90%E7%A0%81/"},{"name":"unigui使用方法","slug":"unigui使用方法","permalink":"https://goodhelp.gitee.io/tags/unigui%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"}]},{"title":"手工杀毒恶意代码检测工具PCHunter","slug":"soft/手工杀毒恶意代码检测工具PCHunter","date":"2017-11-20T03:50:52.000Z","updated":"2021-09-16T23:50:24.777Z","comments":true,"path":"page/1410737214/","link":"","permalink":"https://goodhelp.gitee.io/page/1410737214/","excerpt":"PC Hunter是一个Windows系统信息查看软件，同时也是一个手工杀毒辅助软件。支持xp~win10的所有32位操作系统，还支持64位的Win7、Win8、Win8.1和Win10系统。看看界面主要功能:1.进程、线程、进程模块、进程窗口、进程内存信息查看，杀进程、杀线程、卸载模块等功能 2.内核驱动模块查看，支持内核驱动模块的内存拷贝 3.SSDT、Shadow SSDT、FSD、KBD、TCPIP、Nsiproxy、Tdx、Classpnp、Atapi、Acpi、SCSI、IDT、GDT信息查看，并能检测和恢复ssdt hook和inline hook 4.CreateProcess、CreateThread、LoadImage、CmpCallback、BugCheckCallback、Shutdown、Lego等近20多种Notify Routine信息查看，并支持对这些Notify Routine的删除 5.端口信息查看，目前不支持2000系统 6.查看消息钩子 7.内核模块的iat、eat、inline hook、patches检测和恢复 8.磁盘、卷、键盘、网络层等过滤驱动检测，并支持删除 9.注册表编辑 10.进程iat、eat、inline hook、patches检测和恢复","text":"PC Hunter是一个Windows系统信息查看软件，同时也是一个手工杀毒辅助软件。支持xp~win10的所有32位操作系统，还支持64位的Win7、Win8、Win8.1和Win10系统。看看界面主要功能:1.进程、线程、进程模块、进程窗口、进程内存信息查看，杀进程、杀线程、卸载模块等功能 2.内核驱动模块查看，支持内核驱动模块的内存拷贝 3.SSDT、Shadow SSDT、FSD、KBD、TCPIP、Nsiproxy、Tdx、Classpnp、Atapi、Acpi、SCSI、IDT、GDT信息查看，并能检测和恢复ssdt hook和inline hook 4.CreateProcess、CreateThread、LoadImage、CmpCallback、BugCheckCallback、Shutdown、Lego等近20多种Notify Routine信息查看，并支持对这些Notify Routine的删除 5.端口信息查看，目前不支持2000系统 6.查看消息钩子 7.内核模块的iat、eat、inline hook、patches检测和恢复 8.磁盘、卷、键盘、网络层等过滤驱动检测，并支持删除 9.注册表编辑 10.进程iat、eat、inline hook、patches检测和恢复 11.文件系统查看，支持基本的文件操作 12.查看(编辑)IE插件、SPI、启动项、服务、Hosts文件、映像劫持、文件关联、系统防火墙规则、IME 13.ObjectType Hook检测和恢复 14.DPC定时器检测和删除 15.MBR Rootkit检测和修复 16.内核对象劫持检测 17.WorkerThread枚举 18.Ndis中一些回调信息枚举 19.硬件调试寄存器、调试相关API检测 20.枚举SFilter/Flgmgr的回调 21.系统用户名检测 官方网站：http://www.xuetr.com 免费版下载地址：http://www.xuetr.com/download/PCHunter_free.zip Linxer大牛在XueTr源码基础上重新开发了PC Hunter，支持Win8.1和X64，本次更新新增了十几处检测。分为免费版和收费版。","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"去广告方法","slug":"去广告方法","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%BB%E5%B9%BF%E5%91%8A%E6%96%B9%E6%B3%95/"},{"name":"精品软件","slug":"精品软件","permalink":"https://goodhelp.gitee.io/tags/%E7%B2%BE%E5%93%81%E8%BD%AF%E4%BB%B6/"}]},{"title":"TChromium获取网页源代码delphi代码","slug":"article/TChromium获取网页源代码delphi代码","date":"2017-11-19T15:45:32.000Z","updated":"2021-09-16T23:38:39.667Z","comments":true,"path":"page/2301859295/","link":"","permalink":"https://goodhelp.gitee.io/page/2301859295/","excerpt":"使用Webbrowser取得网页源代码网上已经有很多例子了，而TChromium如何获得网页源代码呢？ 第一种方法1234567891011procedure TCustomLoad.OnLoadEnd(const browser: ICefBrowser;const frame: ICefFrame; httpStatusCode: Integer);vardata:tstringlist;begindata:=tstringlist.create;if frame.IsMain thendata.text:=frame.Source; // HTML Sourceend;data.free;end; 在dcef3中123456789101112procedure StringVisitor(const str: ustring);begin//str is the SourceHtmlshowmessage(str);end;function GetSourceHTML: string;varCefStringVisitor:ICefStringVisitor;beginCefStringVisitor := TCefFastStringVisitor.Create(StringVisitor);Chromium1.Browser.MainFrame.GetSource(CefStringVisitor);end; 第三种1Chromium1.Browser.MainFrame.ViewSource;","text":"使用Webbrowser取得网页源代码网上已经有很多例子了，而TChromium如何获得网页源代码呢？ 第一种方法1234567891011procedure TCustomLoad.OnLoadEnd(const browser: ICefBrowser;const frame: ICefFrame; httpStatusCode: Integer);vardata:tstringlist;begindata:=tstringlist.create;if frame.IsMain thendata.text:=frame.Source; // HTML Sourceend;data.free;end; 在dcef3中123456789101112procedure StringVisitor(const str: ustring);begin//str is the SourceHtmlshowmessage(str);end;function GetSourceHTML: string;varCefStringVisitor:ICefStringVisitor;beginCefStringVisitor := TCefFastStringVisitor.Create(StringVisitor);Chromium1.Browser.MainFrame.GetSource(CefStringVisitor);end; 第三种1Chromium1.Browser.MainFrame.ViewSource;","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"delphi技巧","slug":"delphi技巧","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%8A%80%E5%B7%A7/"},{"name":"TChromium技巧","slug":"TChromium技巧","permalink":"https://goodhelp.gitee.io/tags/TChromium%E6%8A%80%E5%B7%A7/"}]},{"title":"unigui管理系统源码","slug":"code/unigui管理系统源码","date":"2017-11-11T04:40:41.000Z","updated":"2021-09-16T23:56:25.298Z","comments":true,"path":"page/2767400155/","link":"","permalink":"https://goodhelp.gitee.io/page/2767400155/","excerpt":"uniGui是一款delphi开发网页应用的框架，完全基于ExtJs,全面支持ajax技术，是delphi开发bs程序的有力控件!官方网站为 http://www.unigui.com unigui的demo运行方法网址介绍地址http://www.unigui.com/resources/running-demos uniGUI为Delphi开发者在IDE上的Web应用程序设计创建、调试提供一套独特的视觉元素。每个组件的设计是为了提供在Delphi VCL可视化组件的对应相同的功能。这提供了一个非常舒适的开发环境，非常接近原生VCL应用开发的一个简单的学习过程。uniGUI Web应用程序可以部署到服务器上使用一个可用的部署选项，如Windows服务，独立服务器或ISAPI模块。 本源码是在uniguiv0.95的基础上开发的，如果你用最新的unigui版本，可能需要一些修改才能运行! 以下是引导说明界面其中的部份代码 123456789101112131415161718192021222324252627282930313233343536373839404142procedure TMainForm.InsertFrame(acaption:string);var tabs:TUniTabSheet;begin if (MM1.LoginUserid&lt;&gt;&#x27;&#x27;) then //判断登录 begin if acaption=&#x27;添加帐号&#x27; then begin try UniFrame3:=TUniFrame3.Create(Self); UniFrame3.Align:=alClient; except ShowActiveTab(&#x27;添加帐号&#x27;); exit; end; tabs:=TUniTabSheet.Create(Self); tabs.PageControl:=pg1; tabs.Caption:=&#x27;添加帐号&#x27;; tabs.Closable:=True; pg1.ActivePage:=tabs; UniFrame3.Parent:=tabs; UniFrame3.ParentWindow:=MainForm.Handle; end; if acaption=&#x27;系统设置&#x27; then begin try UniFrame4:=TUniFrame4.Create(Self); UniFrame4.Align:=alClient; except ShowActiveTab(&#x27;系统设置&#x27;); exit; end; tabs:=TUniTabSheet.Create(Self); tabs.PageControl:=pg1; tabs.Caption:=&#x27;系统设置&#x27;; tabs.Closable:=True; pg1.ActivePage:=tabs; UniFrame4.Parent:=tabs; UniFrame4.ParentWindow:=MainForm.Handle; end; end;end; 提供的源代码可以用于学习unigui！此unigui源码动态生成tab,鼠标长时间不动自动锁界面等值得借鉴，你只需要修改一下代码就可以做为自己web系统的框架，添加功能继续开发!下载后运行bin目录中的安装，就可以点 打开 看到界面了，可以自己注册帐号，默认有一个帐号admin admin 下载地址：链接: https://pan.baidu.com/s/1PMRYEB96MYH6VYrYnHrEaQ 提取码: cyfe 复制这段内容后打开百度网盘手机App，操作更方便哦","text":"uniGui是一款delphi开发网页应用的框架，完全基于ExtJs,全面支持ajax技术，是delphi开发bs程序的有力控件!官方网站为 http://www.unigui.com unigui的demo运行方法网址介绍地址http://www.unigui.com/resources/running-demos uniGUI为Delphi开发者在IDE上的Web应用程序设计创建、调试提供一套独特的视觉元素。每个组件的设计是为了提供在Delphi VCL可视化组件的对应相同的功能。这提供了一个非常舒适的开发环境，非常接近原生VCL应用开发的一个简单的学习过程。uniGUI Web应用程序可以部署到服务器上使用一个可用的部署选项，如Windows服务，独立服务器或ISAPI模块。 本源码是在uniguiv0.95的基础上开发的，如果你用最新的unigui版本，可能需要一些修改才能运行! 以下是引导说明界面其中的部份代码 123456789101112131415161718192021222324252627282930313233343536373839404142procedure TMainForm.InsertFrame(acaption:string);var tabs:TUniTabSheet;begin if (MM1.LoginUserid&lt;&gt;&#x27;&#x27;) then //判断登录 begin if acaption=&#x27;添加帐号&#x27; then begin try UniFrame3:=TUniFrame3.Create(Self); UniFrame3.Align:=alClient; except ShowActiveTab(&#x27;添加帐号&#x27;); exit; end; tabs:=TUniTabSheet.Create(Self); tabs.PageControl:=pg1; tabs.Caption:=&#x27;添加帐号&#x27;; tabs.Closable:=True; pg1.ActivePage:=tabs; UniFrame3.Parent:=tabs; UniFrame3.ParentWindow:=MainForm.Handle; end; if acaption=&#x27;系统设置&#x27; then begin try UniFrame4:=TUniFrame4.Create(Self); UniFrame4.Align:=alClient; except ShowActiveTab(&#x27;系统设置&#x27;); exit; end; tabs:=TUniTabSheet.Create(Self); tabs.PageControl:=pg1; tabs.Caption:=&#x27;系统设置&#x27;; tabs.Closable:=True; pg1.ActivePage:=tabs; UniFrame4.Parent:=tabs; UniFrame4.ParentWindow:=MainForm.Handle; end; end;end; 提供的源代码可以用于学习unigui！此unigui源码动态生成tab,鼠标长时间不动自动锁界面等值得借鉴，你只需要修改一下代码就可以做为自己web系统的框架，添加功能继续开发!下载后运行bin目录中的安装，就可以点 打开 看到界面了，可以自己注册帐号，默认有一个帐号admin admin 下载地址：链接: https://pan.baidu.com/s/1PMRYEB96MYH6VYrYnHrEaQ 提取码: cyfe 复制这段内容后打开百度网盘手机App，操作更方便哦","categories":[{"name":"源码","slug":"code","permalink":"https://goodhelp.gitee.io/categories/code/"}],"tags":[{"name":"delphi源码","slug":"delphi源码","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%BA%90%E7%A0%81/"},{"name":"unigui使用方法","slug":"unigui使用方法","permalink":"https://goodhelp.gitee.io/tags/unigui%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"}]},{"title":"富有哲理的座右铭100条","slug":"other/富有哲理的座右铭100条","date":"2017-11-08T15:42:48.000Z","updated":"2021-09-16T23:49:11.039Z","comments":true,"path":"page/3685387284/","link":"","permalink":"https://goodhelp.gitee.io/page/3685387284/","excerpt":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644651、人之所以有一张嘴，而有两只耳朵，原因是听的要比说的多一倍。2、哲人无忧，智者常乐。并不是因为所爱的一切他都拥有了，而是所拥有的一切他都爱。3、泪水和汗水的化学成分相似，但前者只能为你换来同情，后者却可以为你赢的成功。4、越是成熟的稻穗，越懂得弯腰。5、江海之所以能成为百谷之王，是因为懂得身处低下。6、每个人都有潜在的能量，只是很容易被习惯所掩盖，被时间所迷离，被惰性所消磨。 7、生气是拿别人做错的事来惩罚自己。 8、后悔是一种耗费精神的情绪。后悔是比损失更大的损失，比错误更大的错误，所以请不要后悔。 9、人生有几件绝对不能失去的东西：自制的力量，冷静的头脑，希望和信心。 10、不是境况造就人，而是人造就境况。 11、自己要先看得起自己，别人才会看得起你。 12、要铭记在心：每天都是一年中最美好的日子。 13、爱的力量大到可以使人忘记一切，却又小到连一粒嫉妒的沙石也不能容纳。 14、人是可以快乐地生活的，只是我们自己选择了复杂，选择了叹息！ 15、过去的一页，能不翻就不翻，翻落了灰尘会迷了双眼。 16、人若软弱就是自己最大的敌人；人若勇敢就是自己最好的朋友。 17、要纠正别人之前，先反省自己有没有犯错。 18、许多人缺少的不是美，而是自信的气质，记住：自信本身就是一种美。有了积极的心态就容易成功。 19、人总是珍惜未得到的，而遗忘了所拥有的。 20、用最少的悔恨面对过去。用最少的浪费面对现在。用最多的梦面对未来。 21、大多数人想要改造这个世界，但却罕有人想改造自己。 22、得意时应善待他人，因为你失意时会需要他们。 23、一千个人就有一千种生存方式和生活道路，要想改变一些事情，首先得把自己给找回来。 24、任何的限制，都是从自己的内心开始的。忘掉失败，不过要牢记失败中的教训。 25、假如我不能，我一定要；假如我一定要，我就一定能。 26、一个能从别人的观念来看事情，能了解别人心灵活动的人，永远不必为自己的前途担心。 27、人生不过三万天，成功失败均坦然，是非恩怨莫在意，健康快乐最值钱。 28、世界上有两种人：索取者和给予者。前者也许能吃得更好，但后者绝对能睡得更香。 29、环境不会改变，解决之道在于改变自己。 30、要让事情改变，先改变我自己；要让事情变得更好，先让自己变得更好。 31、不要对挫折叹气，姑且把这一切看成是在你成大事之前，必须经受的准备工作。 32、你出生的时候，你哭着，周围的人笑着；在生命的尽头，你笑着，而周围的人在哭着。 33、伟人之所以伟大，是因为他与别人共处逆境时，别人失去了信心，他却下决心实现自己的目标。 34、如果早上醒来，你发现自己还能自由呼吸，你就比在这一周离开人世的100万人更有福气。 35、什么时候也不要放弃希望，越是险恶的环境越要燃起希望的意志。 36、积极的人在每一次忧患中都看到一个机会，而消极的人则在每个机会都看到某种忧患。 37、许多人企求着生活的完美结局，殊不知美根本不在结局，而在于追求的过程。 38、也许有些人很可恶，有些人很卑鄙。而当我设身为他想象的时候，我才知道：他比我还可怜。所以请原谅所有你见过的人，好人或者坏人。 39、一句无心的话也许会点燃纠纷，一句残酷的话也许会毁掉生命，一句及时的话也许会消释紧张，一句知心的话也许会愈合伤口、挽救他人。 40、生命就是一个逐渐支出和利用时间的过程。一旦丧失了时间，生命也就走到了尽头。 41、世上并没有用来鼓励工作努力的赏赐，所有的赏赐都只是被用来奖励工作成果的。 42、生命的完整，在于宽恕、容忍、等待与爱，如果没有这一切，你拥有了所有，也是虚无。 43、当我们眺望远方的时候，近处的风景便看不清了。 44、如果你希望成功，以恒心为良友，以经验为参谋，以小心为兄弟，以希望为哨兵。 45、思考是一件最辛苦的工作，这可能是为什么很少人愿意思考的原因。 46、成功呈概率分布，关键是你能不能坚持到成功开始呈现的那一刻。 47、自己打败自己是最可悲的失败，自己战胜自己是最可贵的胜利。 48、为别人鼓掌的人也是在给自己的生命加油。 49、拥有梦想只是一种智力，实现梦想才是一种能力。 50、如果一个人不知道他要驶向哪个码头，那么任何风都不会是顺风。 51、人的才华就如海绵的水，没有外力的挤压，它是绝对流不出来的。流出来后，海绵才能吸收新的源泉。 52、感恩生命，感谢她给予我们一个聪明的大脑。思考疑难的问题，生命的意义；赞颂真善美，批判假恶丑。记住精彩的瞬间，激动的时刻，温馨的情景，甜蜜的镜头。感恩生命赋予我们特有的灵性。 53、善待自己，幸福无比，善待别人，快乐无比，善待生命，健康无比。 54、一切伟大的行动和思想，都有一个微不足道的开始。 55、在你发怒的时候，要紧闭你的嘴，免得增加你的怒气。 56、获致幸福的不二法门是珍视你所拥有的、遗忘你所没有的。 57、骄傲是胜利下的蛋，孵出来的却是失败。 58、没有一个朋友比得上健康，没有一个敌人比得上病魔，与其为病痛暗自流泪，不如运动健身为生命添彩。 59、有什么别有病，没什么别没钱，缺什么也别缺健康，健康不是一切，但是没有健康就没有一切。 60、什么都可以不好，心情不能不好；什么都可以缺乏，自信不能缺乏；什么都可以不要，快乐不能不要；什么都可以忘掉，健身不能忘掉。 61、选对事业可以成就一生，选对朋友可以智能一生，选对环境可以快乐一生，选对伴侣可以幸福一生，选对生活方式可以健康一生。 62、含泪播种的人一定能含笑收获。 63、一个有信念者所开发出的力量，大于个只有兴趣者。 64、忍耐力较诸脑力，尤胜一筹。 65、影响我们人生的绝不仅仅是环境，其实是心态在控制个人的行动和思想。同时，心态也决定了一个人的视野、事业和成就，甚至一生。 66、每一发奋努力的背后，必有加倍的赏赐。 67、懒惰像生锈一样，比操劳更消耗身体。 68、所有的胜利，与征服自己的胜利比起来，都是微不足道。所有的失败，与失去自己的失败比起来，更是微不足道。 69、挫折其实就是迈向成功所应缴的学费。 70、在这个尘世上，虽然有不少寒冷，不少黑暗，但只要人与人之间多些信任，多些关爱，那么，就会增加许多阳光。 71、一个能从别人的观念来看事情，能了解别人心灵活动的人，永远不必为自己的前途担心。 72、当一个人先从自己的内心开始奋斗，他就是个有价值的人。 73、没有人富有得可以不要别人的帮助，也没有人穷得不能在某方面给他人帮助。 74、凡真心尝试助人者，没有不帮到自己的。 75、积极者相信只有推动自己才能推动世界，只要推动自己就能推动世界。 76、一个人最大的破产是绝望，最大的资产是希望。 77、行动是成功的阶梯，行动越多，登得越高。 78、环境永远不会十全十美，消极的人受环境控制，积极的人却控制环境。 79、当所有人都低调的时候，你可以高调，但不能跑调。 80、成功的法则极为简单，但简单并不代表容易。 81、肯低头的人，永远不会撞到矮门。 82、昨晚多几分钟的准备，今天少几小时的麻烦。 83、拿望远镜看别人，拿放大镜看自己。 84、一念放下，万般自在。 85、六个不能：不能饿了才吃，不能渴了才喝，不能困了才睡，不能累了才歇，不能病了才检查，不能老了再后悔。 86、屋子修得再大也是临时住所，只有那个小木匣才是永久的家，所以，屋宽不如心宽，身安不如心安！ 87、人生最大的错误，是用健康换取身外之物，人生最大的悲哀，是用生命换取个人的烦恼，人生最大的浪费，是用生命解决自己制造的麻烦！ 88、人生最大的哀痛，是子欲孝而亲不在！人生最大的悲剧，是家未富而人先亡，人生最大的可怜，是弥留之际才明白自己是应该做什么的！ 89、当心灵趋于平静时，精神便是永恒！把欲望降到最低点，把理性升华到最高点，你会感受到：平安是福，清心是禄，寡欲是寿！ 90、最好的医生是自己，最好的药物是时间，最好的心情是宁静，最好的保健是笑脸，最好的运动是步行！ 91、欢乐是长寿的妙药，勤奋是健康的灵丹，运动是健康的投资，长寿是健身的回报，相逢莫问留春术，淡薄宁静比药好！ 92、金钱难买健康，健康大于金钱，金钱难买幸福，幸福必有健康，生命的幸福不在名利在健康，身体的强壮不在金钱在运动！ 93、饮食贵在节，读书贵在精，锻炼贵在恒，节饮食养胃，多读书养胆，喜运动延生！ 94、你不能左右天气，但可以改变心情。你不能改变容貌，但可以掌握自己。你不能预见明天，但可以珍惜今天！ 95、热爱生活的人，生活也爱他。 96、微笑不用本钱，但能创造财富。赞美不用花钱，但能产生气力。分享不用过度，但能倍增快乐。 97、快乐总和宽厚的人相伴，财富总与诚信的人相伴，聪明总与高尚的人相伴，魅力总与幽默的人相伴，健康总与豁达的人相伴。 98、愚者用肉体监视心灵，智者用心灵监视肉体。 99、生活若剥去了理想、梦想、幻想，那生命便只是一堆空架子。 100、尝试去把别人拍过来的砖砌成结实的地基，生活就不会那么辛苦了。","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644651、人之所以有一张嘴，而有两只耳朵，原因是听的要比说的多一倍。2、哲人无忧，智者常乐。并不是因为所爱的一切他都拥有了，而是所拥有的一切他都爱。3、泪水和汗水的化学成分相似，但前者只能为你换来同情，后者却可以为你赢的成功。4、越是成熟的稻穗，越懂得弯腰。5、江海之所以能成为百谷之王，是因为懂得身处低下。6、每个人都有潜在的能量，只是很容易被习惯所掩盖，被时间所迷离，被惰性所消磨。 7、生气是拿别人做错的事来惩罚自己。 8、后悔是一种耗费精神的情绪。后悔是比损失更大的损失，比错误更大的错误，所以请不要后悔。 9、人生有几件绝对不能失去的东西：自制的力量，冷静的头脑，希望和信心。 10、不是境况造就人，而是人造就境况。 11、自己要先看得起自己，别人才会看得起你。 12、要铭记在心：每天都是一年中最美好的日子。 13、爱的力量大到可以使人忘记一切，却又小到连一粒嫉妒的沙石也不能容纳。 14、人是可以快乐地生活的，只是我们自己选择了复杂，选择了叹息！ 15、过去的一页，能不翻就不翻，翻落了灰尘会迷了双眼。 16、人若软弱就是自己最大的敌人；人若勇敢就是自己最好的朋友。 17、要纠正别人之前，先反省自己有没有犯错。 18、许多人缺少的不是美，而是自信的气质，记住：自信本身就是一种美。有了积极的心态就容易成功。 19、人总是珍惜未得到的，而遗忘了所拥有的。 20、用最少的悔恨面对过去。用最少的浪费面对现在。用最多的梦面对未来。 21、大多数人想要改造这个世界，但却罕有人想改造自己。 22、得意时应善待他人，因为你失意时会需要他们。 23、一千个人就有一千种生存方式和生活道路，要想改变一些事情，首先得把自己给找回来。 24、任何的限制，都是从自己的内心开始的。忘掉失败，不过要牢记失败中的教训。 25、假如我不能，我一定要；假如我一定要，我就一定能。 26、一个能从别人的观念来看事情，能了解别人心灵活动的人，永远不必为自己的前途担心。 27、人生不过三万天，成功失败均坦然，是非恩怨莫在意，健康快乐最值钱。 28、世界上有两种人：索取者和给予者。前者也许能吃得更好，但后者绝对能睡得更香。 29、环境不会改变，解决之道在于改变自己。 30、要让事情改变，先改变我自己；要让事情变得更好，先让自己变得更好。 31、不要对挫折叹气，姑且把这一切看成是在你成大事之前，必须经受的准备工作。 32、你出生的时候，你哭着，周围的人笑着；在生命的尽头，你笑着，而周围的人在哭着。 33、伟人之所以伟大，是因为他与别人共处逆境时，别人失去了信心，他却下决心实现自己的目标。 34、如果早上醒来，你发现自己还能自由呼吸，你就比在这一周离开人世的100万人更有福气。 35、什么时候也不要放弃希望，越是险恶的环境越要燃起希望的意志。 36、积极的人在每一次忧患中都看到一个机会，而消极的人则在每个机会都看到某种忧患。 37、许多人企求着生活的完美结局，殊不知美根本不在结局，而在于追求的过程。 38、也许有些人很可恶，有些人很卑鄙。而当我设身为他想象的时候，我才知道：他比我还可怜。所以请原谅所有你见过的人，好人或者坏人。 39、一句无心的话也许会点燃纠纷，一句残酷的话也许会毁掉生命，一句及时的话也许会消释紧张，一句知心的话也许会愈合伤口、挽救他人。 40、生命就是一个逐渐支出和利用时间的过程。一旦丧失了时间，生命也就走到了尽头。 41、世上并没有用来鼓励工作努力的赏赐，所有的赏赐都只是被用来奖励工作成果的。 42、生命的完整，在于宽恕、容忍、等待与爱，如果没有这一切，你拥有了所有，也是虚无。 43、当我们眺望远方的时候，近处的风景便看不清了。 44、如果你希望成功，以恒心为良友，以经验为参谋，以小心为兄弟，以希望为哨兵。 45、思考是一件最辛苦的工作，这可能是为什么很少人愿意思考的原因。 46、成功呈概率分布，关键是你能不能坚持到成功开始呈现的那一刻。 47、自己打败自己是最可悲的失败，自己战胜自己是最可贵的胜利。 48、为别人鼓掌的人也是在给自己的生命加油。 49、拥有梦想只是一种智力，实现梦想才是一种能力。 50、如果一个人不知道他要驶向哪个码头，那么任何风都不会是顺风。 51、人的才华就如海绵的水，没有外力的挤压，它是绝对流不出来的。流出来后，海绵才能吸收新的源泉。 52、感恩生命，感谢她给予我们一个聪明的大脑。思考疑难的问题，生命的意义；赞颂真善美，批判假恶丑。记住精彩的瞬间，激动的时刻，温馨的情景，甜蜜的镜头。感恩生命赋予我们特有的灵性。 53、善待自己，幸福无比，善待别人，快乐无比，善待生命，健康无比。 54、一切伟大的行动和思想，都有一个微不足道的开始。 55、在你发怒的时候，要紧闭你的嘴，免得增加你的怒气。 56、获致幸福的不二法门是珍视你所拥有的、遗忘你所没有的。 57、骄傲是胜利下的蛋，孵出来的却是失败。 58、没有一个朋友比得上健康，没有一个敌人比得上病魔，与其为病痛暗自流泪，不如运动健身为生命添彩。 59、有什么别有病，没什么别没钱，缺什么也别缺健康，健康不是一切，但是没有健康就没有一切。 60、什么都可以不好，心情不能不好；什么都可以缺乏，自信不能缺乏；什么都可以不要，快乐不能不要；什么都可以忘掉，健身不能忘掉。 61、选对事业可以成就一生，选对朋友可以智能一生，选对环境可以快乐一生，选对伴侣可以幸福一生，选对生活方式可以健康一生。 62、含泪播种的人一定能含笑收获。 63、一个有信念者所开发出的力量，大于个只有兴趣者。 64、忍耐力较诸脑力，尤胜一筹。 65、影响我们人生的绝不仅仅是环境，其实是心态在控制个人的行动和思想。同时，心态也决定了一个人的视野、事业和成就，甚至一生。 66、每一发奋努力的背后，必有加倍的赏赐。 67、懒惰像生锈一样，比操劳更消耗身体。 68、所有的胜利，与征服自己的胜利比起来，都是微不足道。所有的失败，与失去自己的失败比起来，更是微不足道。 69、挫折其实就是迈向成功所应缴的学费。 70、在这个尘世上，虽然有不少寒冷，不少黑暗，但只要人与人之间多些信任，多些关爱，那么，就会增加许多阳光。 71、一个能从别人的观念来看事情，能了解别人心灵活动的人，永远不必为自己的前途担心。 72、当一个人先从自己的内心开始奋斗，他就是个有价值的人。 73、没有人富有得可以不要别人的帮助，也没有人穷得不能在某方面给他人帮助。 74、凡真心尝试助人者，没有不帮到自己的。 75、积极者相信只有推动自己才能推动世界，只要推动自己就能推动世界。 76、一个人最大的破产是绝望，最大的资产是希望。 77、行动是成功的阶梯，行动越多，登得越高。 78、环境永远不会十全十美，消极的人受环境控制，积极的人却控制环境。 79、当所有人都低调的时候，你可以高调，但不能跑调。 80、成功的法则极为简单，但简单并不代表容易。 81、肯低头的人，永远不会撞到矮门。 82、昨晚多几分钟的准备，今天少几小时的麻烦。 83、拿望远镜看别人，拿放大镜看自己。 84、一念放下，万般自在。 85、六个不能：不能饿了才吃，不能渴了才喝，不能困了才睡，不能累了才歇，不能病了才检查，不能老了再后悔。 86、屋子修得再大也是临时住所，只有那个小木匣才是永久的家，所以，屋宽不如心宽，身安不如心安！ 87、人生最大的错误，是用健康换取身外之物，人生最大的悲哀，是用生命换取个人的烦恼，人生最大的浪费，是用生命解决自己制造的麻烦！ 88、人生最大的哀痛，是子欲孝而亲不在！人生最大的悲剧，是家未富而人先亡，人生最大的可怜，是弥留之际才明白自己是应该做什么的！ 89、当心灵趋于平静时，精神便是永恒！把欲望降到最低点，把理性升华到最高点，你会感受到：平安是福，清心是禄，寡欲是寿！ 90、最好的医生是自己，最好的药物是时间，最好的心情是宁静，最好的保健是笑脸，最好的运动是步行！ 91、欢乐是长寿的妙药，勤奋是健康的灵丹，运动是健康的投资，长寿是健身的回报，相逢莫问留春术，淡薄宁静比药好！ 92、金钱难买健康，健康大于金钱，金钱难买幸福，幸福必有健康，生命的幸福不在名利在健康，身体的强壮不在金钱在运动！ 93、饮食贵在节，读书贵在精，锻炼贵在恒，节饮食养胃，多读书养胆，喜运动延生！ 94、你不能左右天气，但可以改变心情。你不能改变容貌，但可以掌握自己。你不能预见明天，但可以珍惜今天！ 95、热爱生活的人，生活也爱他。 96、微笑不用本钱，但能创造财富。赞美不用花钱，但能产生气力。分享不用过度，但能倍增快乐。 97、快乐总和宽厚的人相伴，财富总与诚信的人相伴，聪明总与高尚的人相伴，魅力总与幽默的人相伴，健康总与豁达的人相伴。 98、愚者用肉体监视心灵，智者用心灵监视肉体。 99、生活若剥去了理想、梦想、幻想，那生命便只是一堆空架子。 100、尝试去把别人拍过来的砖砌成结实的地基，生活就不会那么辛苦了。","categories":[{"name":"其他","slug":"其他","permalink":"https://goodhelp.gitee.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"文章","slug":"文章","permalink":"https://goodhelp.gitee.io/tags/%E6%96%87%E7%AB%A0/"},{"name":"座右铭","slug":"座右铭","permalink":"https://goodhelp.gitee.io/tags/%E5%BA%A7%E5%8F%B3%E9%93%AD/"}]},{"title":"仓央嘉措最美情诗十首","slug":"other/仓央嘉措最美情诗十首","date":"2017-11-08T15:38:33.000Z","updated":"2021-09-16T23:49:17.939Z","comments":true,"path":"page/1843896738/","link":"","permalink":"https://goodhelp.gitee.io/page/1843896738/","excerpt":"仓央嘉措（1683—1706年），为第六世达赖喇嘛，门巴族人，西藏历史上著名的人物。1683年（藏历水猪年，康熙二十二年）生于西藏南部，门隅纳拉山下宇松地区乌坚林村的一户农奴家庭，父亲扎西丹增，母亲次旺拉姆。家中世代信奉宁玛派佛教。1697年被当时的西藏摄政王第巴·桑结嘉措认定为五世达赖的转世灵童，同年在桑结嘉措的主持下在布达拉宫举行了坐床典礼。1705年被废，1706年在押解途中圆寂。仓央嘉措是一位才华出众、富有文采的民歌诗人，写了很多细腻真挚的情歌。最为经典的拉萨藏文木刻版《仓央嘉措情歌》，词句优美，朴实生动，汇集了仓央嘉措60多首情诗，如今已被译成20多种文字，几乎传遍了全世界，他的诗歌已经超越民族、时空、国界，成为宝贵的文化遗产。其中最著名的是“曾虑多情损梵行，入山又恐别倾城。世间安得双全法，不负如来不负卿。” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308一、 谁，执我之手，敛我半世癫狂;谁，吻我之眸，遮我半世流离;谁，抚我之面，慰我半世哀伤;谁，携我之心，融我半世冰霜;谁，扶我之肩，驱我一世沉寂。谁，唤我之心，掩我一生凌轹。谁，弃我而去，留我一世独殇;谁，可明我意，使我此生无憾;谁，可助我臂，纵横万载无双;谁，可倾我心，寸土恰似虚弥;谁，可葬吾怆，笑天地虚妄，吾心狂。伊，覆我之唇，祛我前世流离;伊，揽我之怀，除我前世轻浮。执子之手，陪你痴狂千生;深吻子眸，伴你万世轮回。执子之手，共你一世风霜;吻子之眸，赠你一世深情。我， 牵尔玉手， 收你此生所有;我， 抚尔秀颈， 挡你此生风雨。予，挽子青丝，挽子一世情思;予，执子之手，共赴一世情长;曾，以父之名，免你一生哀愁;曾，怜子之情，祝你一生平安!二、《那一世》那一刻，我升起风马，不为乞福，只为守候你的到来;那一日，我闭目在经殿香雾中，蓦然听见你颂经中的真言;那一夜，我听了一宿梵唱，不为参悟，只为寻你的一丝气息;那一月，我摇动所有的经筒，不为超度，只为触摸你的指尖;那一年，我磕长头在山路，不为觐见，只为贴着你的温暖;那一世，转山转水转佛塔啊，不为修来生，只为途中与你相见。那一瞬，我飞升成仙，不为长生，只为佑你平安喜乐。三、《十诫诗 》第一最好不相见，如此便可不相恋。第二最好不相知，如此便可不相思。第三最好不相伴，如此便可不相欠。第四最好不相惜，如此便可不相忆。第五最好不相爱，如此便可不相弃。第六最好不相对，如此便可不相会。第七最好不相误，如此便可不相负。第八最好不相许，如此便可不相续。第九最好不相依，如此便可不相偎。第十最好不相遇，如此便可不相聚。但曾相见便相知，相见何如不见时。安得与君相诀绝，免教生死作相思。四、《见与不见》你见，或者不见我我就在那里不悲不喜你念，或者不念我情就在那里不来不去你爱，或者不爱我爱就在那里不增不减你跟，或者不跟我我的手就在你手里不舍不弃来我的怀里或者让我住进你的心里默然 相爱寂静 欢喜五、住进布达拉宫，我是雪域最大的王。流浪在拉萨街头，我是世间最美的情郎。与玛吉阿米的更传神，自恐多情损梵行，入山又怕误倾城。世间安得双全法，不负如来不负卿。六、我终于明白，世间有一种思绪，无法用言语形容，粗犷而忧伤。回声的千结百绕，而守候的是，执着。一如月光下的高原，一抹淡淡痴痴的笑。笑那浮华落尽，月色如洗;笑那悄然而逝，飞花万盏。谁是那轻轻颤动的百合，在你的清辉下亘古不变。谁有那灼灼热烈的双眸，在你的颔首中攀援而上。遥远的忧伤，穿过千山万水。纵使高原上的风，吹不散，执着的背影。纵使清晨前的霜，融不化，心头的温热。你静守在月下，悄悄地来。七、《问佛》我问佛：为何不给所有女子羞花闭月容颜?佛曰：那只是昙花一现，用来蒙蔽世俗的眼，没有什麽美可以抵过一颗纯净仁爱的心，我把它赐给每一个女子，可有人让她蒙上了灰。我问佛：世间为何有那麽多遗憾?佛曰：这是一个婆娑世界，婆娑既遗憾，没有遗憾，给你再多幸福也不会体会快乐。我问佛：如何让人们的心不再感到孤单?佛曰：每一颗心生来就是孤单而残缺的，多数带著这种残缺度过一生，只因与能使它圆满的另一半相遇时，不是疏忽错过就是已失去拥有它的资格。我问佛：如果遇到了可以爱的人，却又怕不能把握怎麽办?佛曰：留人间多少爱，迎浮世千重变;和有情人，做快乐事，别问是劫是缘。我问佛：如何才能如你般睿智?佛曰：佛是过来人，人是未来佛，我也曾如你般天真。我问佛：为什么总是在我悲伤的时候下雪?佛说：冬天就要过去，留点记忆。我问佛：为什么每次下雪都是我不在意的夜晚?佛说：不经意的时候人们总会错过很多真正的美丽。我问佛：那过几天还下不下雪?佛说：不要只盯着这个季节，错过了今冬。八、我用世间所有的路，倒退，从哪儿来回哪儿去。正如月亮回到湖心，野鹤奔向闲云，我步入你，然后一场大雪便封住所有人的嘴。那个女子，满身都是洗不尽的春色，眸子闪处，花花草草;笑口开时，山山水水;但那块发光的松石，却折射着她一生的因缘，她坐在自己深处避邪，起来后再把那些误解她的人白白错过。一挥手，六尘境界到处都是她撒出的花种。夕阳印证着雪山无我的智慧，爱情与梵心同样白得耀眼，离别后，晚风依然珍藏着她的誓言。誓言中的青草早已枯黄，没有什么远近之分，世上最远的也远不过隔世之爱，再近也近不过自己与自己相邻，此时，远处隐隐传来琵琶声，那是她弹的，却不是为我弹的。","text":"仓央嘉措（1683—1706年），为第六世达赖喇嘛，门巴族人，西藏历史上著名的人物。1683年（藏历水猪年，康熙二十二年）生于西藏南部，门隅纳拉山下宇松地区乌坚林村的一户农奴家庭，父亲扎西丹增，母亲次旺拉姆。家中世代信奉宁玛派佛教。1697年被当时的西藏摄政王第巴·桑结嘉措认定为五世达赖的转世灵童，同年在桑结嘉措的主持下在布达拉宫举行了坐床典礼。1705年被废，1706年在押解途中圆寂。仓央嘉措是一位才华出众、富有文采的民歌诗人，写了很多细腻真挚的情歌。最为经典的拉萨藏文木刻版《仓央嘉措情歌》，词句优美，朴实生动，汇集了仓央嘉措60多首情诗，如今已被译成20多种文字，几乎传遍了全世界，他的诗歌已经超越民族、时空、国界，成为宝贵的文化遗产。其中最著名的是“曾虑多情损梵行，入山又恐别倾城。世间安得双全法，不负如来不负卿。” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308一、 谁，执我之手，敛我半世癫狂;谁，吻我之眸，遮我半世流离;谁，抚我之面，慰我半世哀伤;谁，携我之心，融我半世冰霜;谁，扶我之肩，驱我一世沉寂。谁，唤我之心，掩我一生凌轹。谁，弃我而去，留我一世独殇;谁，可明我意，使我此生无憾;谁，可助我臂，纵横万载无双;谁，可倾我心，寸土恰似虚弥;谁，可葬吾怆，笑天地虚妄，吾心狂。伊，覆我之唇，祛我前世流离;伊，揽我之怀，除我前世轻浮。执子之手，陪你痴狂千生;深吻子眸，伴你万世轮回。执子之手，共你一世风霜;吻子之眸，赠你一世深情。我， 牵尔玉手， 收你此生所有;我， 抚尔秀颈， 挡你此生风雨。予，挽子青丝，挽子一世情思;予，执子之手，共赴一世情长;曾，以父之名，免你一生哀愁;曾，怜子之情，祝你一生平安!二、《那一世》那一刻，我升起风马，不为乞福，只为守候你的到来;那一日，我闭目在经殿香雾中，蓦然听见你颂经中的真言;那一夜，我听了一宿梵唱，不为参悟，只为寻你的一丝气息;那一月，我摇动所有的经筒，不为超度，只为触摸你的指尖;那一年，我磕长头在山路，不为觐见，只为贴着你的温暖;那一世，转山转水转佛塔啊，不为修来生，只为途中与你相见。那一瞬，我飞升成仙，不为长生，只为佑你平安喜乐。三、《十诫诗 》第一最好不相见，如此便可不相恋。第二最好不相知，如此便可不相思。第三最好不相伴，如此便可不相欠。第四最好不相惜，如此便可不相忆。第五最好不相爱，如此便可不相弃。第六最好不相对，如此便可不相会。第七最好不相误，如此便可不相负。第八最好不相许，如此便可不相续。第九最好不相依，如此便可不相偎。第十最好不相遇，如此便可不相聚。但曾相见便相知，相见何如不见时。安得与君相诀绝，免教生死作相思。四、《见与不见》你见，或者不见我我就在那里不悲不喜你念，或者不念我情就在那里不来不去你爱，或者不爱我爱就在那里不增不减你跟，或者不跟我我的手就在你手里不舍不弃来我的怀里或者让我住进你的心里默然 相爱寂静 欢喜五、住进布达拉宫，我是雪域最大的王。流浪在拉萨街头，我是世间最美的情郎。与玛吉阿米的更传神，自恐多情损梵行，入山又怕误倾城。世间安得双全法，不负如来不负卿。六、我终于明白，世间有一种思绪，无法用言语形容，粗犷而忧伤。回声的千结百绕，而守候的是，执着。一如月光下的高原，一抹淡淡痴痴的笑。笑那浮华落尽，月色如洗;笑那悄然而逝，飞花万盏。谁是那轻轻颤动的百合，在你的清辉下亘古不变。谁有那灼灼热烈的双眸，在你的颔首中攀援而上。遥远的忧伤，穿过千山万水。纵使高原上的风，吹不散，执着的背影。纵使清晨前的霜，融不化，心头的温热。你静守在月下，悄悄地来。七、《问佛》我问佛：为何不给所有女子羞花闭月容颜?佛曰：那只是昙花一现，用来蒙蔽世俗的眼，没有什麽美可以抵过一颗纯净仁爱的心，我把它赐给每一个女子，可有人让她蒙上了灰。我问佛：世间为何有那麽多遗憾?佛曰：这是一个婆娑世界，婆娑既遗憾，没有遗憾，给你再多幸福也不会体会快乐。我问佛：如何让人们的心不再感到孤单?佛曰：每一颗心生来就是孤单而残缺的，多数带著这种残缺度过一生，只因与能使它圆满的另一半相遇时，不是疏忽错过就是已失去拥有它的资格。我问佛：如果遇到了可以爱的人，却又怕不能把握怎麽办?佛曰：留人间多少爱，迎浮世千重变;和有情人，做快乐事，别问是劫是缘。我问佛：如何才能如你般睿智?佛曰：佛是过来人，人是未来佛，我也曾如你般天真。我问佛：为什么总是在我悲伤的时候下雪?佛说：冬天就要过去，留点记忆。我问佛：为什么每次下雪都是我不在意的夜晚?佛说：不经意的时候人们总会错过很多真正的美丽。我问佛：那过几天还下不下雪?佛说：不要只盯着这个季节，错过了今冬。八、我用世间所有的路，倒退，从哪儿来回哪儿去。正如月亮回到湖心，野鹤奔向闲云，我步入你，然后一场大雪便封住所有人的嘴。那个女子，满身都是洗不尽的春色，眸子闪处，花花草草;笑口开时，山山水水;但那块发光的松石，却折射着她一生的因缘，她坐在自己深处避邪，起来后再把那些误解她的人白白错过。一挥手，六尘境界到处都是她撒出的花种。夕阳印证着雪山无我的智慧，爱情与梵心同样白得耀眼，离别后，晚风依然珍藏着她的誓言。誓言中的青草早已枯黄，没有什么远近之分，世上最远的也远不过隔世之爱，再近也近不过自己与自己相邻，此时，远处隐隐传来琵琶声，那是她弹的，却不是为我弹的。","categories":[{"name":"其他","slug":"其他","permalink":"https://goodhelp.gitee.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"文章","slug":"文章","permalink":"https://goodhelp.gitee.io/tags/%E6%96%87%E7%AB%A0/"},{"name":"情诗","slug":"情诗","permalink":"https://goodhelp.gitee.io/tags/%E6%83%85%E8%AF%97/"}]},{"title":"英语名言警句","slug":"other/英语名言警句","date":"2017-11-07T15:35:30.000Z","updated":"2021-09-16T23:48:57.695Z","comments":true,"path":"page/2135853815/","link":"","permalink":"https://goodhelp.gitee.io/page/2135853815/","excerpt":"中文中的一些名言，英语中你知道怎么说吗？记住下面这些英语名言，用在你的考试作文中，会被加分哟！ 第一部份: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281、Do one thing at a time, and do well.一次只做一件事，做到最好！ 2、Never forget to say “thanks”.永远不要忘了说“谢谢”! 3、Keep on going never give up.勇往直前， 决不放弃！ 4、Whatever is worth doing is worth doing well.任何值得做的事就值得把它做好！ 5、Believe in yourself.相信你自己！ 6、I can because i think i can.我行，因为我相信我行！ 7、Action speak louder than words.行动胜于言语！ 8、Never say die.永不气馁！ 9、Never put off what you can do today until tomorrow.今日事今日毕！ 10、The best preparation for tomorrow is doing your best today.对明天做好的准备就是今天做到最好！ 11、You cannot improve your past, but you can improve your future. Once time is wasted, life is wasted.你不能改变你的过去，但你可以让你的未来变得更美好。一旦时间浪费了，生命就浪费了。 12、Knowlegde can change your fate and English can accomplish your future.知识改变命运，英语成就未来。 13、Don&#x27;t aim for success if you want it; just do what you love and believe in, and it will come naturally.如果你想要成功，不要去追求成功；尽管做你自己热爱的事情并且相信它，成功自然到来。 14、Jack of all trades and master of none.门门精通，样样稀松。 15、Judge not from appearances.人不可貌相，海不可斗量。 16、Justice has long arms.天网恢恢，疏而不漏。 17、Keep good men company and you shall be of the number.近朱者赤，近墨者黑。 18、Kill two birds with one stone.一箭双雕。 19、Kings go mad, and the people suffer for it.君王发狂，百姓遭殃。 20、Kings have long arms.普天之下，莫非王土。 21、Knowledge is power.知识就是力量。 21、Knowledge makes humble, ignorance makes proud.博学使人谦逊，无知使人骄傲。 22、Learn and live.活着，为了学习。 23、Learning makes a good man better and ill man worse.好人越学越好，坏人越学越坏。 24、Learn not and know not.不学无术。 25、Learn to walk before you run.先学走，再学跑。 26、Let bygones be bygones.过去的就让它过去吧。 27、Let sleeping dogs lie.别惹麻烦。 28、Let the cat out of the bag.泄漏天机。 29、Lies can never changes fact.谎言终究是谎言。 30、Lies have short legs.谎言站不长。 31、Life is but a span.人生苦短。 32、Life is half spent before we know what it is.人过半生，方知天命。 33、Life is not all roses.人生并不是康庄大道。 34、Life without a friend is death.没有朋友，虽生犹死。 35、Like a rat in a hole.瓮中之鳖。 36、Like author, like book.文如其人。 37、Like father, like son.有其父必有其子。 38、Like for like.一报还一报。 39、Like knows like.惺惺相惜。 40、Like mother, like daughter.有其母必有其女。 41、Like teacher, like pupil.什么样的老师教什么样的学生。 42、Like tree, like fruit.羊毛出在羊身上。 第二部份 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879801、You can never turn back the clock时光不能倒流2、All things come to those who wait懂得忍耐的人是最大的赢家3、Desire has no rest人的欲望无止尽4、Some people never adjust to the loss of a loved one有些人永远无法从失去挚爱的人的悲痛中走出来5、Time is of the essence时间就是一切6、Danger past，God forgotten飞鸟尽，良弓藏7、A young idler，an old beggar少壮不努力，老大徒伤悲8、Man proposes，God disposes谋事在人，成事在天9、Merry meet，merry part好聚好散10、Courtesy costs nothing礼多人不怪11、Every little bit helps滴水穿石12、Nothing is difficult if you put your heart into it世上无难事，只怕有心人13、You may delay，but time until not时不待我14、Better a little loss than a long sorrow长痛不如短痛15、Man struggles upwards，water flows downwards人往高处走，水往低处流16、Past pain is pleasure过去的痛苦即是快乐17、The wall has ears隔墙有耳18、Love me，love my dog爱屋及乌19、Don’t trouble trouble until trouble troubles you别自找麻烦20、The road is tortuous，but the future is bright道路是曲折的，前途是光明的21、One is always on a strange road，watching strange scenery and listening to strange music一个人总要走陌生的路，看陌生的风景，听陌生的音乐22、Reality is temporary while ideals are permanent现实是暂时的，理想是永恒的23、It is better to forgive and forget rather than to hold a grudge与其怀有宿怨，不如去宽恕和释怀来得好24、Do wrong once and you’ll never hear the end of it一失足成千古恨25、Speak of the devil and he appears说曹操，曹操到26、When the cat’s away, the mice will play山中无老虎，猴子称大王27、Alter what is changeable and accept what is immutable改变可以改变的，接受不能改变的28、A hedge between keeps friendship green君子之交淡如水29、Take the essence and discard the dregs取其精华，去其糟泊30、If you shed tears when you miss the sun，you also miss the stars如果你因为失去太阳而落泪，那么你也将失去群星31、There is a skeleton in the cupboard家丑不可外扬32、One eyewitness is better than ten hearsays百闻不如一见33、Don’t teach fish to swim不要班门弄斧34、It only takes a minute to get a crush on someone but an eternity to forget someone迷上某人只需一分钟，忘记某人却是一辈子的事35、At the touch of love everyone becomes a poet每一个沐浴爱河的人都是诗人36、Let nature take its right course船到桥头自然直37、Opportunity knocks but once机不可失，时不再来38、It’s never too late to mend亡羊补牢，犹未晚也39、A journey of a thousand miles begins with a single step千里之行，始于足下40、If winter comes，can spring be far behind？冬天来了，春天还会远吗？","text":"中文中的一些名言，英语中你知道怎么说吗？记住下面这些英语名言，用在你的考试作文中，会被加分哟！ 第一部份: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281、Do one thing at a time, and do well.一次只做一件事，做到最好！ 2、Never forget to say “thanks”.永远不要忘了说“谢谢”! 3、Keep on going never give up.勇往直前， 决不放弃！ 4、Whatever is worth doing is worth doing well.任何值得做的事就值得把它做好！ 5、Believe in yourself.相信你自己！ 6、I can because i think i can.我行，因为我相信我行！ 7、Action speak louder than words.行动胜于言语！ 8、Never say die.永不气馁！ 9、Never put off what you can do today until tomorrow.今日事今日毕！ 10、The best preparation for tomorrow is doing your best today.对明天做好的准备就是今天做到最好！ 11、You cannot improve your past, but you can improve your future. Once time is wasted, life is wasted.你不能改变你的过去，但你可以让你的未来变得更美好。一旦时间浪费了，生命就浪费了。 12、Knowlegde can change your fate and English can accomplish your future.知识改变命运，英语成就未来。 13、Don&#x27;t aim for success if you want it; just do what you love and believe in, and it will come naturally.如果你想要成功，不要去追求成功；尽管做你自己热爱的事情并且相信它，成功自然到来。 14、Jack of all trades and master of none.门门精通，样样稀松。 15、Judge not from appearances.人不可貌相，海不可斗量。 16、Justice has long arms.天网恢恢，疏而不漏。 17、Keep good men company and you shall be of the number.近朱者赤，近墨者黑。 18、Kill two birds with one stone.一箭双雕。 19、Kings go mad, and the people suffer for it.君王发狂，百姓遭殃。 20、Kings have long arms.普天之下，莫非王土。 21、Knowledge is power.知识就是力量。 21、Knowledge makes humble, ignorance makes proud.博学使人谦逊，无知使人骄傲。 22、Learn and live.活着，为了学习。 23、Learning makes a good man better and ill man worse.好人越学越好，坏人越学越坏。 24、Learn not and know not.不学无术。 25、Learn to walk before you run.先学走，再学跑。 26、Let bygones be bygones.过去的就让它过去吧。 27、Let sleeping dogs lie.别惹麻烦。 28、Let the cat out of the bag.泄漏天机。 29、Lies can never changes fact.谎言终究是谎言。 30、Lies have short legs.谎言站不长。 31、Life is but a span.人生苦短。 32、Life is half spent before we know what it is.人过半生，方知天命。 33、Life is not all roses.人生并不是康庄大道。 34、Life without a friend is death.没有朋友，虽生犹死。 35、Like a rat in a hole.瓮中之鳖。 36、Like author, like book.文如其人。 37、Like father, like son.有其父必有其子。 38、Like for like.一报还一报。 39、Like knows like.惺惺相惜。 40、Like mother, like daughter.有其母必有其女。 41、Like teacher, like pupil.什么样的老师教什么样的学生。 42、Like tree, like fruit.羊毛出在羊身上。 第二部份 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879801、You can never turn back the clock时光不能倒流2、All things come to those who wait懂得忍耐的人是最大的赢家3、Desire has no rest人的欲望无止尽4、Some people never adjust to the loss of a loved one有些人永远无法从失去挚爱的人的悲痛中走出来5、Time is of the essence时间就是一切6、Danger past，God forgotten飞鸟尽，良弓藏7、A young idler，an old beggar少壮不努力，老大徒伤悲8、Man proposes，God disposes谋事在人，成事在天9、Merry meet，merry part好聚好散10、Courtesy costs nothing礼多人不怪11、Every little bit helps滴水穿石12、Nothing is difficult if you put your heart into it世上无难事，只怕有心人13、You may delay，but time until not时不待我14、Better a little loss than a long sorrow长痛不如短痛15、Man struggles upwards，water flows downwards人往高处走，水往低处流16、Past pain is pleasure过去的痛苦即是快乐17、The wall has ears隔墙有耳18、Love me，love my dog爱屋及乌19、Don’t trouble trouble until trouble troubles you别自找麻烦20、The road is tortuous，but the future is bright道路是曲折的，前途是光明的21、One is always on a strange road，watching strange scenery and listening to strange music一个人总要走陌生的路，看陌生的风景，听陌生的音乐22、Reality is temporary while ideals are permanent现实是暂时的，理想是永恒的23、It is better to forgive and forget rather than to hold a grudge与其怀有宿怨，不如去宽恕和释怀来得好24、Do wrong once and you’ll never hear the end of it一失足成千古恨25、Speak of the devil and he appears说曹操，曹操到26、When the cat’s away, the mice will play山中无老虎，猴子称大王27、Alter what is changeable and accept what is immutable改变可以改变的，接受不能改变的28、A hedge between keeps friendship green君子之交淡如水29、Take the essence and discard the dregs取其精华，去其糟泊30、If you shed tears when you miss the sun，you also miss the stars如果你因为失去太阳而落泪，那么你也将失去群星31、There is a skeleton in the cupboard家丑不可外扬32、One eyewitness is better than ten hearsays百闻不如一见33、Don’t teach fish to swim不要班门弄斧34、It only takes a minute to get a crush on someone but an eternity to forget someone迷上某人只需一分钟，忘记某人却是一辈子的事35、At the touch of love everyone becomes a poet每一个沐浴爱河的人都是诗人36、Let nature take its right course船到桥头自然直37、Opportunity knocks but once机不可失，时不再来38、It’s never too late to mend亡羊补牢，犹未晚也39、A journey of a thousand miles begins with a single step千里之行，始于足下40、If winter comes，can spring be far behind？冬天来了，春天还会远吗？","categories":[{"name":"其他","slug":"其他","permalink":"https://goodhelp.gitee.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"文章","slug":"文章","permalink":"https://goodhelp.gitee.io/tags/%E6%96%87%E7%AB%A0/"},{"name":"英语名言","slug":"英语名言","permalink":"https://goodhelp.gitee.io/tags/%E8%8B%B1%E8%AF%AD%E5%90%8D%E8%A8%80/"}]},{"title":"8088汇编速查手册","slug":"article/8088汇编速查手册","date":"2017-11-07T15:33:22.000Z","updated":"2021-09-16T23:42:37.941Z","comments":true,"path":"page/753365309/","link":"","permalink":"https://goodhelp.gitee.io/page/753365309/","excerpt":"汇编语言(assembly language)是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符(Mnemonics)代替机器指令的操作码，用地址符号(Symbol)或标号(Label)代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。普遍地说，特定的汇编语言和特定的机器语言指令集是一一对应的不同平台之间不可直接移植。下面是汇编指令一、数据传输指令─────────────────────────────────────── 它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据. 1. 通用数据传送指令. MOV 传送字或字节. MOVSX 先符号扩展,再传送. MOVZX 先零扩展,再传送. PUSH 把字压入堆栈. POP 把字弹出堆栈. PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈. POPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈. PUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈. POPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈. BSWAP 交换32位寄存器里字节的顺序 XCHG 交换字或字节.( 至少有一个操作数为寄存器,段寄存器不可作为操作数) CMPXCHG 比较并交换操作数.( 第二个操作数必须为累加器AL/AX/EAX ) XADD 先交换再累加.( 结果在第一个操作数里 ) XLAT 字节查表转换. ── BX 指向一张 256 字节的表的起点, AL 为表的索引值 (0-255,即 0-FFH); 返回 AL 为查表结果. ( [BX+AL]-&gt;AL ) 2. 输入输出端口传送指令. IN I/O端口输入. ( 语法: IN 累加器, {端口号│DX} ) OUT I/O端口输出. ( 语法: OUT {端口号│DX},累加器 ) 输入输出端口由立即方式指定时, 其范围是 0-255; 由寄存器 DX 指定时, 其范围是 0-65535. 3. 目的地址传送指令. LEA 装入有效地址. 例: LEA DX,string ;把偏移地址存到DX. LDS 传送目标指针,把指针内容装入DS. 例: LDS SI,string ;把段地址:偏移地址存到DS:SI. LES 传送目标指针,把指针内容装入ES. 例: LES DI,string ;把段地址:偏移地址存到ES:DI. LFS 传送目标指针,把指针内容装入FS. 例: LFS DI,string ;把段地址:偏移地址存到FS:DI. LGS 传送目标指针,把指针内容装入GS. 例: LGS DI,string ;把段地址:偏移地址存到GS:DI. LSS 传送目标指针,把指针内容装入SS. 例: LSS DI,string ;把段地址:偏移地址存到SS:DI. 4. 标志传送指令. LAHF 标志寄存器传送,把标志装入AH. SAHF 标志寄存器传送,把AH内容装入标志寄存器. PUSHF 标志入栈. POPF 标志出栈. PUSHD 32位标志入栈. POPD 32位标志出栈.二、算术运算指令─────────────────────────────────────── ADD 加法. ADC 带进位加法. INC 加 1. AAA 加法的ASCII码调整. DAA 加法的十进制调整. SUB 减法. SBB 带借位减法. DEC 减 1. NEC 求反(以 0 减之). CMP 比较.(两操作数作减法,仅修改标志位,不回送结果). AAS 减法的ASCII码调整. DAS 减法的十进制调整. MUL 无符号乘法. IMUL 整数乘法. 以上两条,结果回送AH和AL(字节运算),或DX和AX(字运算), AAM 乘法的ASCII码调整. DIV 无符号除法. IDIV 整数除法. 以上两条,结果回送: 商回送AL,余数回送AH, (字节运算); 或 商回送AX,余数回送DX, (字运算). AAD 除法的ASCII码调整. CBW 字节转换为字. (把AL中字节的符号扩展到AH中去) CWD 字转换为双字. (把AX中的字的符号扩展到DX中去) CWDE 字转换为双字. (把AX中的字符号扩展到EAX中去) CDQ 双字扩展. (把EAX中的字的符号扩展到EDX中去)三、逻辑运算指令─────────────────────────────────────── AND 与运算. OR 或运算. XOR 异或运算. NOT 取反. TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果). SHL 逻辑左移. SAL 算术左移.(=SHL) SHR 逻辑右移. SAR 算术右移.(=SHR) ROL 循环左移. ROR 循环右移. RCL 通过进位的循环左移. RCR 通过进位的循环右移. 以上八种移位指令,其移位次数可达255次. 移位一次时, 可直接用操作码. 如 SHL AX,1. 移位&gt;1次时, 则由寄存器CL给出移位次数. 如 MOV CL,04 SHL AX,CL四、串指令─────────────────────────────────────── DS:SI 源串段寄存器 :源串变址. ES:DI 目标串段寄存器:目标串变址. CX 重复次数计数器. AL/AX 扫描值. D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量. Z标志 用来控制扫描或比较操作的结束. MOVS 串传送. ( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. ) CMPS 串比较. ( CMPSB 比较字符. CMPSW 比较字. ) SCAS 串扫描. 把AL或AX的内容与目标串作比较,比较结果反映在标志位. LODS 装入串. 把源串中的元素(字或字节)逐一装入AL或AX中. ( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. ) STOS 保存串. 是LODS的逆过程. REP 当CX/ECX&lt;&gt;0时重复. REPE/REPZ 当ZF=1或比较结果相等,且CX/ECX&lt;&gt;0时重复. REPNE/REPNZ 当ZF=0或比较结果不相等,且CX/ECX&lt;&gt;0时重复. REPC 当CF=1且CX/ECX&lt;&gt;0时重复. REPNC 当CF=0且CX/ECX&lt;&gt;0时重复.五、程序转移指令─────────────────────────────────────── 1&gt;无条件转移指令 (长转移) JMP 无条件转移指令 CALL 过程调用 RET/RETF过程返回. 2&gt;条件转移指令 (短转移,-128到+127的距离内) ( 当且仅当(SF XOR OF)=1时,OP1&lt;OP2 ) JA/JNBE 不小于或不等于时转移. JAE/JNB 大于或等于转移. JB/JNAE 小于转移. JBE/JNA 小于或等于转移. 以上四条,测试无符号整数运算的结果(标志C和Z). JG/JNLE 大于转移. JGE/JNL 大于或等于转移. JL/JNGE 小于转移. JLE/JNG 小于或等于转移. 以上四条,测试带符号整数运算的结果(标志S,O和Z). JE/JZ 等于转移. JNE/JNZ 不等于时转移. JC 有进位时转移. JNC 无进位时转移. JNO 不溢出时转移. JNP/JPO 奇偶性为奇数时转移. JNS 符号位为 “0” 时转移. JO 溢出转移. JP/JPE 奇偶性为偶数时转移. JS 符号位为 “1” 时转移. 3&gt;循环控制指令(短转移) LOOP CX不为零时循环. LOOPE/LOOPZ CX不为零且标志Z=1时循环. LOOPNE/LOOPNZ CX不为零且标志Z=0时循环. JCXZ CX为零时转移. JECXZ ECX为零时转移. 4&gt;中断指令 INT 中断指令 INTO 溢出中断 IRET 中断返回 5&gt;处理器控制指令 HLT 处理器暂停, 直到出现中断或复位信号才继续. WAIT 当芯片引线TEST为高电平时使CPU进入等待状态. ESC 转换到外处理器. LOCK 封锁总线. NOP 空操作. STC 置进位标志位. CLC 清进位标志位. CMC 进位标志取反. STD 置方向标志位. CLD 清方向标志位. STI 置中断允许位. CLI 清中断允许位.六、伪指令─────────────────────────────────────── DW 定义字(2字节). PROC 定义过程. ENDP 过程结束. SEGMENT 定义段. ASSUME 建立段寄存器寻址. ENDS 段结束. END 程序结束.","text":"汇编语言(assembly language)是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符(Mnemonics)代替机器指令的操作码，用地址符号(Symbol)或标号(Label)代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。普遍地说，特定的汇编语言和特定的机器语言指令集是一一对应的不同平台之间不可直接移植。下面是汇编指令一、数据传输指令─────────────────────────────────────── 它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据. 1. 通用数据传送指令. MOV 传送字或字节. MOVSX 先符号扩展,再传送. MOVZX 先零扩展,再传送. PUSH 把字压入堆栈. POP 把字弹出堆栈. PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈. POPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈. PUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈. POPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈. BSWAP 交换32位寄存器里字节的顺序 XCHG 交换字或字节.( 至少有一个操作数为寄存器,段寄存器不可作为操作数) CMPXCHG 比较并交换操作数.( 第二个操作数必须为累加器AL/AX/EAX ) XADD 先交换再累加.( 结果在第一个操作数里 ) XLAT 字节查表转换. ── BX 指向一张 256 字节的表的起点, AL 为表的索引值 (0-255,即 0-FFH); 返回 AL 为查表结果. ( [BX+AL]-&gt;AL ) 2. 输入输出端口传送指令. IN I/O端口输入. ( 语法: IN 累加器, {端口号│DX} ) OUT I/O端口输出. ( 语法: OUT {端口号│DX},累加器 ) 输入输出端口由立即方式指定时, 其范围是 0-255; 由寄存器 DX 指定时, 其范围是 0-65535. 3. 目的地址传送指令. LEA 装入有效地址. 例: LEA DX,string ;把偏移地址存到DX. LDS 传送目标指针,把指针内容装入DS. 例: LDS SI,string ;把段地址:偏移地址存到DS:SI. LES 传送目标指针,把指针内容装入ES. 例: LES DI,string ;把段地址:偏移地址存到ES:DI. LFS 传送目标指针,把指针内容装入FS. 例: LFS DI,string ;把段地址:偏移地址存到FS:DI. LGS 传送目标指针,把指针内容装入GS. 例: LGS DI,string ;把段地址:偏移地址存到GS:DI. LSS 传送目标指针,把指针内容装入SS. 例: LSS DI,string ;把段地址:偏移地址存到SS:DI. 4. 标志传送指令. LAHF 标志寄存器传送,把标志装入AH. SAHF 标志寄存器传送,把AH内容装入标志寄存器. PUSHF 标志入栈. POPF 标志出栈. PUSHD 32位标志入栈. POPD 32位标志出栈.二、算术运算指令─────────────────────────────────────── ADD 加法. ADC 带进位加法. INC 加 1. AAA 加法的ASCII码调整. DAA 加法的十进制调整. SUB 减法. SBB 带借位减法. DEC 减 1. NEC 求反(以 0 减之). CMP 比较.(两操作数作减法,仅修改标志位,不回送结果). AAS 减法的ASCII码调整. DAS 减法的十进制调整. MUL 无符号乘法. IMUL 整数乘法. 以上两条,结果回送AH和AL(字节运算),或DX和AX(字运算), AAM 乘法的ASCII码调整. DIV 无符号除法. IDIV 整数除法. 以上两条,结果回送: 商回送AL,余数回送AH, (字节运算); 或 商回送AX,余数回送DX, (字运算). AAD 除法的ASCII码调整. CBW 字节转换为字. (把AL中字节的符号扩展到AH中去) CWD 字转换为双字. (把AX中的字的符号扩展到DX中去) CWDE 字转换为双字. (把AX中的字符号扩展到EAX中去) CDQ 双字扩展. (把EAX中的字的符号扩展到EDX中去)三、逻辑运算指令─────────────────────────────────────── AND 与运算. OR 或运算. XOR 异或运算. NOT 取反. TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果). SHL 逻辑左移. SAL 算术左移.(=SHL) SHR 逻辑右移. SAR 算术右移.(=SHR) ROL 循环左移. ROR 循环右移. RCL 通过进位的循环左移. RCR 通过进位的循环右移. 以上八种移位指令,其移位次数可达255次. 移位一次时, 可直接用操作码. 如 SHL AX,1. 移位&gt;1次时, 则由寄存器CL给出移位次数. 如 MOV CL,04 SHL AX,CL四、串指令─────────────────────────────────────── DS:SI 源串段寄存器 :源串变址. ES:DI 目标串段寄存器:目标串变址. CX 重复次数计数器. AL/AX 扫描值. D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量. Z标志 用来控制扫描或比较操作的结束. MOVS 串传送. ( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. ) CMPS 串比较. ( CMPSB 比较字符. CMPSW 比较字. ) SCAS 串扫描. 把AL或AX的内容与目标串作比较,比较结果反映在标志位. LODS 装入串. 把源串中的元素(字或字节)逐一装入AL或AX中. ( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. ) STOS 保存串. 是LODS的逆过程. REP 当CX/ECX&lt;&gt;0时重复. REPE/REPZ 当ZF=1或比较结果相等,且CX/ECX&lt;&gt;0时重复. REPNE/REPNZ 当ZF=0或比较结果不相等,且CX/ECX&lt;&gt;0时重复. REPC 当CF=1且CX/ECX&lt;&gt;0时重复. REPNC 当CF=0且CX/ECX&lt;&gt;0时重复.五、程序转移指令─────────────────────────────────────── 1&gt;无条件转移指令 (长转移) JMP 无条件转移指令 CALL 过程调用 RET/RETF过程返回. 2&gt;条件转移指令 (短转移,-128到+127的距离内) ( 当且仅当(SF XOR OF)=1时,OP1&lt;OP2 ) JA/JNBE 不小于或不等于时转移. JAE/JNB 大于或等于转移. JB/JNAE 小于转移. JBE/JNA 小于或等于转移. 以上四条,测试无符号整数运算的结果(标志C和Z). JG/JNLE 大于转移. JGE/JNL 大于或等于转移. JL/JNGE 小于转移. JLE/JNG 小于或等于转移. 以上四条,测试带符号整数运算的结果(标志S,O和Z). JE/JZ 等于转移. JNE/JNZ 不等于时转移. JC 有进位时转移. JNC 无进位时转移. JNO 不溢出时转移. JNP/JPO 奇偶性为奇数时转移. JNS 符号位为 “0” 时转移. JO 溢出转移. JP/JPE 奇偶性为偶数时转移. JS 符号位为 “1” 时转移. 3&gt;循环控制指令(短转移) LOOP CX不为零时循环. LOOPE/LOOPZ CX不为零且标志Z=1时循环. LOOPNE/LOOPNZ CX不为零且标志Z=0时循环. JCXZ CX为零时转移. JECXZ ECX为零时转移. 4&gt;中断指令 INT 中断指令 INTO 溢出中断 IRET 中断返回 5&gt;处理器控制指令 HLT 处理器暂停, 直到出现中断或复位信号才继续. WAIT 当芯片引线TEST为高电平时使CPU进入等待状态. ESC 转换到外处理器. LOCK 封锁总线. NOP 空操作. STC 置进位标志位. CLC 清进位标志位. CMC 进位标志取反. STD 置方向标志位. CLD 清方向标志位. STI 置中断允许位. CLI 清中断允许位.六、伪指令─────────────────────────────────────── DW 定义字(2字节). PROC 定义过程. ENDP 过程结束. SEGMENT 定义段. ASSUME 建立段寄存器寻址. ENDS 段结束. END 程序结束.","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"汇编使用方法","slug":"汇编使用方法","permalink":"https://goodhelp.gitee.io/tags/%E6%B1%87%E7%BC%96%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"}]},{"title":"dos的debug命令详解","slug":"article/dos的debug命令详解","date":"2017-11-07T15:27:29.000Z","updated":"2021-09-16T23:39:40.401Z","comments":true,"path":"page/2104750721/","link":"","permalink":"https://goodhelp.gitee.io/page/2104750721/","excerpt":"DEBUG是DOS中的一个外部命令，从DOS 1.0起就带有此命令，因此可见此命令的重要性了。虽然此命令的功能非常强大，可以解决许多问题，可是对许多人来说，尤其是初学者来说，却非常不易掌握。因此，现将DEBUG的命令详细介绍一番，以让大家知道它的使用。Debug:A（汇编）直接将 8086/8087/8088 记忆码合并到内存。该命令从汇编语言语句创建可执行的机器码。所有数值都是十六进制格式，必须按一到四个字符输入这些数值。在引用的操作代码（操作码）前指定前缀记忆码。a [address]参数address指定键入汇编语言指令的位置。对 address 使用十六进制值，并键入不以“h”字符结尾的每个值。如果不指定地址，a 将在它上次停止处开始汇编。有关将数据输入到指定字节中的信息，请单击“相关主题”列表中的 Debug E（键入）。有关反汇编字节的信息，请单击“相关主题”列表中的 Debug U（反汇编）。说明使用记忆码段的替代记忆码为 cs:、ds:、es: 和 ss:。远程返回的记忆码是 retf。字符串处理的记忆码必须明确声明字符串大小。例如，使用 movsw 可以移动 16 位的字串，使用 movsb 可以移动 8 位字节串。汇编跳转和调用汇编程序根据字节替换自动将短、近和远的跳转及调用汇编到目标地址。通过使用 near 或 far 前缀可以替代这样的跳转或调用，如下例所示： 1234-a0100:05000100:0500 jmp 502 ; a 2-byte short jump0100:0502 jmp near 505 ; a 3-byte near jump0100:0505 jmp far 50a ; a 5-byte far jump 可以将 near 前缀缩写为 ne。区分字和字节内存位置当某个操作数可以引用某个字内存位置或者字节内存位置时，必须用前缀 word ptr 或者前缀 byte ptr 指定数据类型。可接受的缩写分别是 wo 和 by。以下范例显示两种格式： 12dec wo [si]neg byte ptr [128] 指定操作数Debug 使用包括在中括号 ([ ]) 的操作数引用内存地址的习惯用法。这是因为另一方面 Debug 不能区分立即操作数和内存地址的操作数。以下范例显示两种格式： 1234mov ax,21 ; load AX with 21hmov ax,[21] ; load AX with the; contents of; memory location 21h 使用伪指令使用 a 命令提供两个常用的伪指令：db 操作码，将字节值直接汇编到内存，dw 操作码，将字值直接汇编到内存。以下是两个伪指令的范例： 1234db 1,2,3,4,”THIS IS AN EXAMPLE”db ‘THIS IS A QUOTATION MARK:”‘db “THIS IS A QUOTATION MARK:&#x27;”dw 1000,2000,3000,”BACH” 范例a 命令支持所有形式的间接注册命令，如下例所示： 123add bx,34[bp+2].[si-1]pop [bp+di]push [si] )","text":"DEBUG是DOS中的一个外部命令，从DOS 1.0起就带有此命令，因此可见此命令的重要性了。虽然此命令的功能非常强大，可以解决许多问题，可是对许多人来说，尤其是初学者来说，却非常不易掌握。因此，现将DEBUG的命令详细介绍一番，以让大家知道它的使用。Debug:A（汇编）直接将 8086/8087/8088 记忆码合并到内存。该命令从汇编语言语句创建可执行的机器码。所有数值都是十六进制格式，必须按一到四个字符输入这些数值。在引用的操作代码（操作码）前指定前缀记忆码。a [address]参数address指定键入汇编语言指令的位置。对 address 使用十六进制值，并键入不以“h”字符结尾的每个值。如果不指定地址，a 将在它上次停止处开始汇编。有关将数据输入到指定字节中的信息，请单击“相关主题”列表中的 Debug E（键入）。有关反汇编字节的信息，请单击“相关主题”列表中的 Debug U（反汇编）。说明使用记忆码段的替代记忆码为 cs:、ds:、es: 和 ss:。远程返回的记忆码是 retf。字符串处理的记忆码必须明确声明字符串大小。例如，使用 movsw 可以移动 16 位的字串，使用 movsb 可以移动 8 位字节串。汇编跳转和调用汇编程序根据字节替换自动将短、近和远的跳转及调用汇编到目标地址。通过使用 near 或 far 前缀可以替代这样的跳转或调用，如下例所示： 1234-a0100:05000100:0500 jmp 502 ; a 2-byte short jump0100:0502 jmp near 505 ; a 3-byte near jump0100:0505 jmp far 50a ; a 5-byte far jump 可以将 near 前缀缩写为 ne。区分字和字节内存位置当某个操作数可以引用某个字内存位置或者字节内存位置时，必须用前缀 word ptr 或者前缀 byte ptr 指定数据类型。可接受的缩写分别是 wo 和 by。以下范例显示两种格式： 12dec wo [si]neg byte ptr [128] 指定操作数Debug 使用包括在中括号 ([ ]) 的操作数引用内存地址的习惯用法。这是因为另一方面 Debug 不能区分立即操作数和内存地址的操作数。以下范例显示两种格式： 1234mov ax,21 ; load AX with 21hmov ax,[21] ; load AX with the; contents of; memory location 21h 使用伪指令使用 a 命令提供两个常用的伪指令：db 操作码，将字节值直接汇编到内存，dw 操作码，将字值直接汇编到内存。以下是两个伪指令的范例： 1234db 1,2,3,4,”THIS IS AN EXAMPLE”db ‘THIS IS A QUOTATION MARK:”‘db “THIS IS A QUOTATION MARK:&#x27;”dw 1000,2000,3000,”BACH” 范例a 命令支持所有形式的间接注册命令，如下例所示： 123add bx,34[bp+2].[si-1]pop [bp+di]push [si] ) 还支持所有操作码同义词，如下例所示： 1234loopz 100loope 100ja 200jnbe 200 对于 8087 操作码，必须指定 wait 或 fwait 前缀，如下例所示： 12fwait fadd st,st(3) ; this line assembles; an fwait prefix Debug:C（比较）比较内存的两个部分。c range address参数range指定要比较的内存第一个区域的起始和结束地址，或起始地址和长度。有关有效的 range 值的信息，请单击“相关主题”列表中的“Debug 说明”。address指定要比较的第二个内存区域的起始地址。有关有效 address 值的信息，请单击“相关主题”列表中的“Debug 说明”。说明如果 range 和 address 内存区域相同，Debug 将不显示任何内容而直接返回到 Debug 提示符。如果有差异，Debug 将按如下格式显示：address1 byte1 byte2 addess2范例以下命令具有相同效果： 12c100,10f 300c100l10 300 每个命令都对 100h 到 10Fh 的内存数据块与 300h 到 30Fh 的内存数据块进行比较。Debug 响应前面的命令并显示如下信息（假定 DS = 197F）： 123456789101112131415197F:0100 4D E4 197F:0300197F:0101 67 99 197F:0301197F:0102 A3 27 197F:0302197F:0103 35 F3 197F:0303197F:0104 97 BD 197F:0304197F:0105 04 35 197F:0305197F:0107 76 71 197F:0307197F:0108 E6 11 197F:0308197F:0109 19 2C 197F:0309197F:010A 80 0A 197F:030A197F:010B 36 7F 197F:030B197F:010C BE 22 197F:030C197F:010D 83 93 197F:030D197F:010E 49 77 197F:030E197F:010F 4F 8A 197F:030F 注意列表中缺少地址 197F:0106 和 197F:0306。这表明那些地址中的值是相同的。Debug:D（转储）显示一定范围内存地址的内容。d [range]参数range指定要显示其内容的内存区域的起始和结束地址，或起始地址和长度。有关有效的 range 值的信息，请单击“相关主题”列表中的“Debug 说明”。如果不指定 range，Debug 程序将从以前 d 命令中所指定的地址范围的末尾开始显示 128 个字节的内容。有关显示寄存器内容的信息，请单击“相关主题”列表中的 Debug R（寄存器）。说明当使用 d 命令时，Debug 以两个部分显示内存内容：十六进制部分（每个字节的值都用十六进制格式表示）和 ASCII 码部分（每个字节的值都用 ASCII 码字符表示)。每个非打印字符在显示的 ASCII 部分由句号 (.) 表示。每个显示行显示 16 字节的内容，第 8 字节和第 9 字节之间有一个连字符。每个显示行从 16 字节的边界上开始。范例假定键入以下命令：dcs:100 10fDebug 按以下格式显示范围中的内容：04BA:0100 54 4F 4D 00 53 41 57 59-45 52 00 00 00 00 00 00 TOM.SAWYER……如果在没有参数的情况下键入 d 命令，Debug 按以前范例中所描述的内容来编排显示格式。显示的每行以比前一行的地址大 16 个字节（如果是显示 40 列的屏幕，则为 8 个字节）的地址开头。对于后面键入的每个不带参数的 d 命令，Debug 将紧接在最后显示的命令后立即显示字节内容。如果键入以下命令，Debug 将从 CS:100 开始显示 20h 个字节的内容：dcs:100 l 20如果键入以下命令，Debug 将显示范围从 CS 段的 100h 到 115h 中所有字节的内容：dcs:100 115Debug:E（键入）将数据输入到内存中指定的地址。可以按十六进制或 ASCII 格式键入数据。以前存储在指定位置的任何数据全部丢失。e address参数address指定输入数据的第一个内存位置。list指定要输入到内存的连续字节中的数据。有关集成记忆码的信息，请单击“相关主题”列表中的 Debug A（汇编）。有关显示内存部分内容的信息，请单击“相关主题”列表中的 Debug D （转储）。说明使用 address 参数如果在没有指定可选的 list 参数的值情况下指定 address 的值，Debug 将显示地址和内容，在下一行重复地址，并等待您的输入。此时，您可以执行下列操作之一：替换字节值。为此，请在当前值后键入新值。如果您键入的值不是有效的十六进制值，或该值包含两个以上的数字，则 Debug 不会回显无效或额外的字符。进入下一个字节。为此，请按 SPACEBAR（空格键）。要更改该字节中的值，请在当前值后键入新值。如果按 SPACEBAR（空格键）时，移动超过了 8 位界限，Debug 程序将显示新的一行并在行首显示新地址。返回到前一个字节。为此，请按 HYPHEN 键 (-)。可以反复按 HYPHEN 键 (-) 向后移动超过多个字节。在按 HYPHEN 时，Debug 开始新行并显示当前地址和字节值。停止执行 e 命令。为此，请按 ENTER 键。在任何字节位置都可以按 ENTER。使用 list 参数如果指定 list 参数的值，随后的 e 命令将使用列表中的值替换现有的字节值。如果发生错误，将不更改任何字节值。List 值可以是十六进制字节或字符串。使用空格、逗号或制表符来分隔值。必须将字符串包括在单或双引号中。范例假定键入以下命令：ecs:100Debug 按下面的格式显示第一个字节的内容：04BA:0100 EB.要将该值更改为 41，请在插入点键入 41，如下所示：04BA:0100 EB.41_可以用一个 e 命令键入连续的字节值。在键入新值后按 SPACEBAR（空格键），而不是按 ENTER 键。Debug 显示下一个值。在此范例中，如果按三次 SPACEBAR（空格键），Debug 将显示下面的值：04BA:0100 EB.41 10. 00. BC._要将十六进制值 BC 更改为 42，请在插入点键入 42，如下所示：04BA:0100 EB.41 10. 00. BC.42_假定决定值 10 应该是 6F。要纠正该值，请按 HYPHEN 键两次以返回到地址 0101（值 10）。Debug 显示以下内容： 12304BA:0100 EB.41 10. 00. BC.42-04BA:0102 00.-04BA:0101 10._ 在插入点键入 6f 更改值，如下所示：04BA:0101 10.6f_按 ENTER 停止 e 命令并返回到 Debug 提示符下。以下是字符串项的范例：eds:100 “This is the text example”该字符串将从 DS:100 开始填充 24 个字节Debug:F（填充）使用指定的值填充指定内存区域中的地址。可以指定十六进制或 ASCII 格式表示的数据。任何以前存储在指定位置的数据将会丢失。参数range指定要填充内存区域的起始和结束地址，或起始地址和长度。关于有效的 range 值的信息，请单击“相关主题”列表中的“Debug 说明”。list指定要输入的数据。List 可以由十六进制数或引号包括起来的字符串组成。说明使用 range 参数如果 range 包含的字节数比 list 中的数值大，Debug 将在 list 中反复指派值，直到 range 中的所有字节全部填充。如果在 range 中的任何内存损坏或不存在，Debug 将显示错误消息并停止 f 命令。使用 list 参数如果 list 包含的数值多于 range 中的字节数，Debug 将忽略 list 中额外的值。范例假定键入以下命令：f04ba:100l100 42 45 52 54 41作为响应，Debug 使用指定的值填充从 04BA:100 到 04BA:1FF 的内存位置。Debug 重复这五个值直到 100h 个字节全部填满为止。Debug:G（转向）运行当前在内存中的程序。g [=address] [breakpoints]参数=address指定当前在内存中要开始执行的程序地址。如果不指定 address，Windows 2000 将从 CS:IP 寄存器中的当前地址开始执行程序。breakpoints指定可以设置为 g 命令的部分的 1 到 10 个临时断点。有关执行循环、重复的字符串指令、软件中断或子程序的信息，请单击“相关主题”列表中的 Debug P（执行）。有关执行指令的信息，请单击“相关主题”列表中的 Debug T（跟踪）。Debug:H（十六进制）对指定的两个参数执行十六进制运算。h value1 value2参数value1代表从 0 到 FFFFh 范围内的任何十六进制数字。value2代表从 0 到 FFFFh 范围内第二个十六进制数字。说明Debug 首先将指定的两个参数相加，然后从第一个参数中减去第二个参数。这些计算的结果显示在一行中：先计算和，然后计算差。范例假定键入以下命令：h19f 10aDebug 执行运算并显示以下结果。02A9 0095Debug:I（输入）从指定的端口读取并显示一个字节值。i port参数port按地址指定输入端口。地址可以是 16 位的值。有关将字节值发送到输出端口的信息，请单击“相关主题”列表中的 Debug O（输出）。范例假定键入以下命令：i2f8同时假定端口的字节值是 42h。Debug 读取该字节，并将其值显示如下：42Debug:L（加载）将某个文件或特定磁盘扇区的内容加载到内存。要从磁盘文件加载 BX:CX 寄存器中指定的字节数内容，请使用以下语法：l [address]要略过 Windows 2000 文件系统并直接加载特定的扇区，请使用以下语法：l address drive start number参数address指定要在其中加载文件或扇区内容的内存位置。如果不指定 address，Debug 将使用 CS 寄存器中的当前地址。drive指定包含读取指定扇区的磁盘的驱动器。该值是数值型：0 = A, 1 = B, 2 = C 等。start指定要加载其内容的第一个扇区的十六进制数。number指定要加载其内容的连续扇区的十六进制数。只有要加载特定扇区的内容而不是加载 debug 命令行或最近的 Debug n（名称）命令中指定的文件时，才能使用 drive、start 和 number 参数。有关指定用于 l 命令的文件的信息，请单击“相关主题”列表中的 Debug n（名称）。有关写入调试到磁盘的文件的信息，请单击“相关主题”列表中的 Debug w（写入）。注意使用不带参数的 l 命令当使用不带参数的 l 命令时，在 debug 命令行上指定的文件将加载到内存中，从地址 CS:100 开始。Debug 同时将 BX 和 CX 寄存器设置为加载的字节数。如果不在 debug 命令行指定文件，所装入的文件将是最近使用 n 命令经常指定的文件。使用具有 address 参数的 1 命令如果使用带 address 参数的 l 命令，Debug 将从内存位置 address 开始加载文件或指定扇区的内容。使用带全部参数的 l 命令如果使用带所有参数的 l 命令，Debug 将加载指定磁盘扇区的内容而不是加载文件。加载特定扇区的内容指定范围内的每个扇区均从 drive 读取。Debug 从 start 开始加载，直到在 number 中指定的扇区数中的内容全部被加载。加载 .exe 文件Debug 忽略 .exe 文件的地址 address 参数。如果指定 .exe 文件，Debug 将文件重新定位到 .exe 文件的标题中指定的加载地址。在 .exe 文件被加载到内存前，标题自身从 .exe 文件脱离，因此磁盘上的 .exe 文件大小与内存中的不同。如果要检查整个 .exe 文件，请使用不同的扩展名重命名文件。打开十六进制文件Debug 将具有 .hex 扩展名的文件认为十六进制格式文件。键入不带参数的 l 命令，可以加载从十六进制文件中指定的地址处开始的十六进制文件。如果键入的 l 命令包含 address 参数，Debug 将把指定的地址加到在十六进制文件中找到的地址上，以确定起始地址。范例假定启动 Debug 并键入以下命令：nfile.com现在可以键入 l 命令以加载 File.com。Debug 将加载文件并显示 Debug 提示符。假定需要从驱动器 C 将起始逻辑扇区为 15 (0Fh) 的 109 (6Dh) 个扇区的内容加载到起始地址为 04BA:0100 的内存中。为此，请键入以下命令：l04ba:100 2 0f 6dDebug:M（移动）将一个内存块中的内容复制到另一个内存块中。m range address参数range指定要复制内容的内存区域的起始和结束地址，或起始地址和长度。address指定要将 range 内容复制到该位置的起始地址。说明复制操作对现有数据的影响如果新数据没有写入正在被复制的数据块中的地址，则源数据将保持不变。但是，如果目标块已经包含数据(就象它在覆盖副本操作中一样)，则将改写该数据。（覆盖复制操作是指那些目标数据块部分内容覆盖原数据块部分内容的操作。）执行覆盖复制操作m 命令执行目标地址的覆盖复制操作，而不丢失数据。将改写的地址内容首先复制。因此，如果将较高位地址的数据复制到较低位地址，则复制操作从原块的最低位地址开始并向最高位地址进行。反之，如果要将数据从低地址复制到高地址，复制操作从原块的最高地址开始，向最低地址进行。范例假定键入以下命令：mcs:100 110 cs:500Debug 首先将 CS:110 地址中的内容复制到地址 CS:510 中，然后将 CS:10F 地址中的内容复制到 CS:50F 中，如此操作直至将 CS:100 地址中的内容复制到地址 CS:500 中。要查看结果，请使用 Debug d（转储）命令，并使用 m 命令指定目标地址Debug:N（名称）指定 Debug l（加载）或 w（写入）命令的可执行文件的名称，或者指定正在调试的可执行文件的参数。n [drive:][path] filename要指定测试的可执行文件的参数，请使用以下语法：n file-parameters参数如果在没有参数的情况下使用，则 n 命令清除当前规范。[drive:][path] filename指定要测试的可执行文件的位置和名称。file-parameters为正在测试的可执行文件指定参数和开关。有关将文件或指定磁盘扇区的内容加载到内存中的信息，请单击“相关主题”列表中的 Debug L（加载）。有关写入调试到磁盘的文件的信息，请单击“相关主题”列表中的 Debug W（写入）。说明n 命令的两个用途可以按两种方式使用 n 命令。首先，您可以使用它以指定后面的 l（加载）或 w（写入）命令所使用的文件。如果在没有命名所调试文件的情况下启动 Debug，必须在使用 l 命令加载文件之前使用命令 nfilename。在 CS:5C 为文件控制块 (FCB) 正确编排文件名的格式。其次，可以使用 n 命令指定被调试文件的命令行参数和开关。内存区域以下四个内存区域都会受到 n 命令的影响：内存位置内容CS:5C文件 1 的文件控制数据块 (FCB)CS:6C文件 2 的文件控制数据块 (FCB)CS:80n 命令行的长度（以字符表示）CS:81n 命令行字符的开头为 n 命令指定的第一个文件名被放在 CS:5C 的 FCB 中。如果指定第二个文件名，此名称将放置到 CS:6C 的 FCB 中。n 命令行上键入的字符数（除第一个字符之外，n）存储在位置 CS:80。n 命令行上的实际字符（再次，除了字母 n 之外）存储在以 CS:81 开头的位置。注意这些字符可以是在 Windows 2000 命令提示符下键入的命令中有效的任何开关和分隔符。范例假定已经启动 Debug，并加载了正在调试的程序 Prog.com。接着您决定为 Prog.com 指定两个参数并运行此程序。以下是此范例的命令序列：debug prog.comnparam1 param2g在这种情况下，Debug g（转向）命令会运行该程序，就好像您已在 Windows 2000 命令提示符后键入了如下命令：prog param1 param2所以，测试和调试反映 Prog.com 通常的运行时间环境。在下面的命令序列中，第一个 n 命令将 File1.exe 指定为后接的 l（加载）命令的文件，该命令将 File1.exe 加载到内存。第二个 n 命令指定 File1.exe 将使用的参数。最后，g 命令将运行 File1.exe 文件，就好像您在 Windows 2000 命令行中键入了 File1 File2.dat File2.dat 一样。nfile1.exelnfile2.dat file3.datg注意不要在 n 命令的第二种形式后使用 l 命令。还要注意，如果现在使用 w（写入）命令，Windows 2000 将使用名称 File2.dat 保存正在调试的文件 File1.exe。为避免出现此结果，应该总是在 l 或 w 命令之前立即使用 n 命令的第一种形式。Debug:O（输出）将字节值发送到输出端口。o port byte-value参数port通过地址指定输出端口。端口地址可以是 16 位值。byte-value指定要指向 port 的字节值。有关从输入端口读取字节值的信息，请单击“相关主题”列表中的 Debug I（输入）。范例要将字节值 4Fh 发送到地址为 2F8h 的输出端口，请键入以下命令：o2f8 4fDebug:P（执行）执行循环、重复的字符串指令、软件中断或子例程；或通过任何其他指令跟踪。参数=address指定第一个要执行指令的位置。如果不指定地址，则默认地址是在 CS:IP 寄存器中指定的当前地址。number指定在将控制返回给 Debug 之前要执行的指令数。默认值为 1。有关运行当前在内存中程序的信息，请单击“相关主题”列表中的 Debug G（转向）。有关执行指令的信息，请单击“相关主题”列表中的 Debug T（跟踪）。说明控制传送到要测试的程序当 p 命令将控制从 Debug 传送到要测试的程序时，该程序不间断运行，直到循环、重复字符串指令、软件中断或者完成了指定地址的子例程为止，或者直到执行了指定数量的机器指令为止。控制返回到 Debug。地址参数的限制如果 address 参数没有指定段，Debug 将使用被测试程序的 CS 寄存器。如果省略 address，程序将从 CS:IP 寄存器所指定的地址开始执行。必须在 address 参数之前使用等号 (=) 以便将它与 number 参数区分。如果在指定地址处的指令不是循环、重复的字符串指令、软件中断或子例程，则 p 命令与 Debug t（跟踪）命令的作用相同。使用 p 命令显示的邮件当 p 执行完一段说明后，Debug 显示出程序的寄存器内容、标志的状态以及下一段将要被执行的指令的解码形式。警告不能使用 p 命令跟踪只读内存 (ROM)。范例假定正在测试的程序在地址 CS:143F 处包含一个 call 指令。要运行 call 目标位置的子程序然后将控制返回到 Debug，请键入以下命令：p=143fDebug 按以下格式显示结果： 1234AX=0000 BX=0000 CX=0000 DX=0000 SP=FFEE BP=0000 SI=0000 DI=0000DS=2246 ES=2246 SS=2246 CS=2246 IP=1443 NV UP EI PL NZ AC PO NC2246:1442 7505 JNZ 144ADebug:Q（退出） 停止 Debug 会话，不保存当前测试的文件。当您键入 q 以后，控制返回到 Windows 2000 的命令提示符。q参数该命令不带参数。有关保存文件的信息，请单击“相关主题”列表中的 Debug W（写入）。Debug:R（寄存器）显示或改变一个或多个 CPU 寄存器的内容。r [register-name]参数无如果在没有参数的情况下使用，则 r 命令显示所有寄存器的内容以及寄存器存储区域中的标志。register-name指定要显示其内容的寄存器名。有关显示内存部分内容的信息，请单击“相关主题”列表中的 Debug D（转储）。有关反汇编字节的信息，请单击“相关主题”列表中的 Debug U（反汇编）。说明使用 r 命令如果指定了寄存器名称，Windows 2000 将显示以十六进制标记表示的寄存器的 16 位值，并将冒号显示为提示符。如果要更改包含在寄存器中的值，除非键入新值并按 ENTER 键；否则，请按 ENTER 键返回 Debug 提示符。有效寄存器名以下是 register-name 的有效值：ax、bx、cx、dx、sp、bp、si、di、ds、es、ss、cs、ip、pc 及 f。ip 和 pc 都引用指令指针。如果指定寄存器名称，而不是从前面的列表中指定，Windows 2000 将显示以下消息：br error使用 f 字符而不是寄存器名如果键入 f 字符代替寄存器名，Debug 将每个标记的当前设置显示为两字母代码，然后显示 Debug 提示符。要更改标志的设置，请从下表中键入适当的两字母代码：标志名设置清除溢出ovnv方向dn（减）up（增）中断ei（启用）di（禁用）正负ng（负）pl（正）零zrnz辅助进位acna奇偶校验pe（偶校验）po（奇校验）进位cync可以按任何顺序键入新的标志值。不需要在这些值之间留出空格。要停止 r 命令，请按 ENTER 键。任何没有指定新值的标志保持不变。用 r 命令显示的邮件如果为标记指定了多个值，Debug 将显示以下消息：df error如果指定没有在前面的表中列出的标志代码，Debug 将显示以下消息：bf error在这两种情况下，Debug 将忽略所有在无效项目之后指定的设置。Debug 的默认设置在启动 Debug 时，会将段寄存器设置到空闲内存的低端，指令指针设置为 0100h，清除所有标志，并且将其余寄存器设置为零，除了被设置为 FFEEh 的 sp 之外。Debug:R范例要查看所有寄存器的内容、所有标记的状态和当前位置的指令解码表，请键入以下命令：r如果当前位置是 CS:11A，显示外观将类似于以下内容：AX=0E00 BX=00FF CX=0007 DX=01FF SP=039D BP=0000 SI=005C DI=0000DS=04BA ES=04BA SS=04BA CS=O4BA IP=011A NV UP DI NG NZ AC PE NC04BA:011A CD21 INT 21要只查看标志的状态，请键入以下命令：rfDebug 按以下格式显示信息：NV UP DI NG NZ AC PE NC – _现在，您可以按任意顺序键入一个或多个有效的标志值，其中可以有或没有空格，如下所示：nv up di ng nz ac pe nc – pleicyDebug 结束 r 命令并显示 Debug 提示符。要查看更改，请键入 r 或 rf 命令。Debug 将显示以下内容：NV UP EI PL NZ AC PE CY – _按 ENTER 返回到 Debug 提示符。Debug:S（搜索）在某个地址范围搜索一个或多个字节值的模式。s range list参数range指定要搜索范围的开始和结束地址。有关 range 参数有效值的信息，请单击“相关主题”列表中的 Debug。list指定一个或多个字节值的模式，或要搜索的字符串。用空格或逗号分隔每个字节值和下一个字节值。将字符串值包括在引号中。说明如果 list 参数包含多个字节值，Debug 将只显示出现字节值的第一个地址。如果 list 只包含一个字节值，Debug 将显示指定范围内出现该值的所有地址。范例假定需要查找包含值 41 并且范围从 CS:100 到 CS:110 的所有地址。为此，请键入以下命令：scs:100 110 41Debug 按以下格式显示结果：04BA:010404BA:010D–以下命令在 CS:100 到 CS:1A0 的范围内搜索字符串“Ph”。scs:100 1a0 “Ph”Debug:U（反汇编）反汇编字节并显示相应的原语句，其中包括地址和字节值。反汇编代码看起来象已汇编文件的列表。u [range]参数无如果在没有参数的情况下使用，则 u 命令分解 20h 字节（默认值），从前面 u 命令所显示地址后的第一个地址开始。range指定要反汇编代码的起始地址和结束地址，或起始地址和长度。有关 range 参数有效值的信息，请单击“相关主题”列表中的 Debug。有关集成记忆码的信息，请单击“相关主题”列表中的 Debug A（汇编）。有关显示内存部分内容的信息，请单击“相关主题”列表中的 Debug D（转储）。范例要反汇编 16 (10h) 字节，从地址 04BA:0100 开始，请键入以下命令： 12345678910111213u04ba:100l10Debug 按以下格式显示结果：04BA:0100 206472 AND [SI+72],AH04BA:0103 69 DB 6904BA:0104 7665 JBE 016B04BA:0106 207370 AND [BP+DI+70],DH04BA:0109 65 DB 6504BA:010A 63 DB 6304BA:010B 69 DB 6904BA:010C 66 DB 6604BA:010D 69 DB 6904BA:010E 63 DB 6304BA:010F 61 DB 61 如果只显示从 04BA:0100 到 04BA:0108 特定地址的信息，请键入以下命令： 1234567u04ba:0100 0108Debug 显示以下内容：04BA:0100 206472 AND [SI+72],AH04BA:0103 69 DB 6904BA:0104 7665 JBE 016B04BA:0106 207370 AND [BP+DI+70],DHDebug:W（写入） 将文件或特定分区写入磁盘。要将在 BX:CX 寄存器中指定字节数的内容写入磁盘文件，请使用以下语法：w [address]要略过 Windows 2000 文件系统并直接写入特定的扇区，请使用以下语法：w address drive start number参数address指定要写到磁盘文件的文件或部分文件的起始内存地址。如果不指定 address，Debug 程序将从 CS:100 开始。关于 address 参数有效值的信息，请在“相关主题”列表中单击 Debug。drive指定包含目标盘的驱动器。该值是数值型：0 = A, 1 = B, 2 = C,等等。start指定要写入第一个扇区的十六进制数。number指定要写入的扇区数。有关指定用于 w 命令的文件的信息，请单击“相关主题”列表中的 Debug N（名称）。有关将文件或文件扇区内容加载到内存中的信息，请单击“相关主题”列表中的 Debug L（加载）。说明必须在启动 Debug 时或者在最近的 Debug n（名称）命令中指定磁盘文件的名字。这两种方法都可以将地址 CS:5C 处文件控制块的文件名正确地编排格式。在使用不带参数的 w 命令之前重新设置 BX:CX如果使用了 Debug g（转向）、t（跟踪）、p（执行）或 r（寄存器）命令，必须在使用无参数的 w 命令之前，将 BX:CX 寄存器复位。将修改后的文件写入磁盘如果修改文件但不更改文件名、长度或起始地址，Debug 仍然可以正确地将文件写入源磁盘位置。w 命令的限制不能用该命令写入 .exe 或 .hex 文件。警告因为略过 Windows 2000 文件句柄，所以写入特定的分区非常危险。如果键入错误的值，则磁盘文件结构很容易被损坏。范例假定要将起始地址为 CS:100 的内存内容写入到驱动器 B 的磁盘中。需要将数据从磁盘的逻辑扇区号 37h 开始并持续 2Bh 个扇区。为此，键入以下命令：wcs:100 1 37 2b当写操作完成时，Debug 再次显示 Debug 提示符。Debug:XA（分配扩展内存）分配扩展内存的指定页面数。要使用扩展内存，必须安装符合 4.0 版的 Lotus/Intel/Microsoft 扩展内存规范 (LIM EMS) 的扩展内存设备驱动程序。xa [count]参数count指定要分配的扩展内存的 16KB 页数。有关使用扩展内存的其他 Debug 命令的信息，请单击“相关主题”列表中的 XD（释放扩展内存）、XM（映射扩展内存页）或 XS（显示扩展内存状态）。说明如果指定的页面数可用，则 Debug 将显示消息，此消息表明所创建的句柄的十六进制数；否则，Debug 将显示错误消息。Debug:XA范例要分配扩展内存的 8 个页面，请键入以下命令：xa8如果命令成功，Debug 将显示类似的以下消息：Handle created=0003Debug:XD（释放扩展内存）释放指向扩展内存的句柄。要使用扩展内存，必须安装符合 4.0 版的 Lotus/Intel/Microsoft 扩展内存规范 (LIM EMS) 的扩展内存设备驱动程序。xd [handle]参数handle指定要释放的句柄。有关使用扩展内存的其他 Debug 命令的信息，请单击“相关主题”列表中 XA（分配扩展内存）、XM（映射扩展内存页） 或 XS（显示扩展内存状态）。范例要释放句柄 0003，请键入以下命令：xd 0003如果命令成功，Debug 将显示下列消息：Hdle 0003 deallocatedDebug:XM（映射扩展内存页）将属于指定句柄的扩展内存逻辑页映射到扩展内存的物理页。要使用扩展内存，必须安装符合 4.0 版的 Lotus/Intel/Microsoft 扩展内存规范 (LIM EMS) 的扩展内存设备驱动程序。xm [lpage] [ppage] [handle]参数lpage指定要映射到物理页 ppage 的扩展内存的逻辑页面号。ppage指定将 lpage 映射到的物理页面号。handle指定句柄。有关使用扩展内存的其他 Debug 命令的信息，请单击“相关主题”列表中的 XA（分配扩展内存）、XD（释放扩展内存）或 XS（显示扩展内存）。范例要将句柄 0003 的逻辑页 5 映射到物理页 2，请键入以下命令：xm 5 2 0003如果命令成功，Debug 将显示下列消息：Logical page 05 mapped to physical page 02Debug:XS（显示扩展内存状态）显示有关扩展内存状态的信息。要使用扩展内存，必须安装符合 4.0 版的 Lotus/Intel/Microsoft 扩展内存规范 (LIM EMS) 的扩展内存设备驱动程序。xs参数该命令不带参数。有关使用扩展内存的其他 Debug 命令的信息，请单击“相关主题”列表中的 XA（分配扩展内存）、XD（释放扩展内存）或 XM（映射扩展内存页）。说明Debug 显示的信息有如下格式： 1234Handle xx has xx pages allocatedPhysical page xx = Frame segment xxxx of a total xx EMS pages have been allocatedxx of a total xx EMS handles have been allocated 范例要显示扩展内存信息，请键入以下命令：xsDebug 显示与以下类似的信息： 12345678Handle 0000 has 0000 pages allocatedHandle 0001 has 0002 pages allocatedPhysical page 00 = Frame segment C000Physical page 01 = Frame segment C400Physical page 02 = Frame segment C800Physical page 03 = Frame segment CC002 of a total 80 EMS pages have been allocated2 of a total FF EMS handles have been allocated","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"debug使用方法","slug":"debug使用方法","permalink":"https://goodhelp.gitee.io/tags/debug%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"}]},{"title":"如何查看分析蓝屏代码dmp文件?","slug":"article/如何查看分析蓝屏代码dmp文件","date":"2017-11-07T15:14:53.000Z","updated":"2021-09-11T16:39:52.201Z","comments":true,"path":"page/2367243845/","link":"","permalink":"https://goodhelp.gitee.io/page/2367243845/","excerpt":"当您在运行Microsoft Windows 2000/XP/Server 2003、Microsoft Windows Vista/Server 2008、Microsoft Windows 7操作系统时，Windows可能会突然停止正常运行，并显示一副含有下述字样的蓝色背景错误信息画面： 1234A problem has been detected and Windows has been shut down to prevent damage to your computer.…… 此蓝色背景错误信息画面一般简称为“蓝屏（Blue Screen）”或“停止屏（Stop Error Screen）”，它可能会长时间停留在显示屏；也可能会在短时间显示之后自动重新启动计算机。windows蓝屏分析的方法是什么，遇到windows蓝屏如何查找原因，下面就进行说明! 一.原因分析：如果Windows因系统设置故障、软件故障、硬件故障、驱动程序故障、网络故障等各种类型的故障产生了严重的错误，引起Windows无法继续维持正常运行，Windows出于避免用户数据丢失及损坏计算机的考虑，将自动停止运行并显示“蓝屏”错误信息。 在默认的系统设置中，Windows 2000遇到“蓝屏”故障后“蓝屏”错误信息将长时间停留在显示屏，直到您关闭或重新启动计算机；Windows XP及后续版本的Windows遇到“蓝屏”故障后“蓝屏”错误信息将在短时间显示之后自动重新启动计算机。“蓝屏”故障发生后是否自动重新启动计算机取决于“启动与故障恢复”设置。您可以在“控制面板”中打开“系统”属性，切换至“高级”选项卡（如果是Windows Vista及以上版本的Windows请在“系统”属性左上方的工具栏中选择“高级系统设置”，确认用户帐户控制（UAC）安全提示，然后再切换至“高级”选项卡），在“高级”选项卡中打开“启动与故障恢复”。您可以在“启动与故障恢复”的选项中找到“自动重新启动”复选框，如果此复选框没有选中，Windows遇到“蓝屏”故障后“蓝屏”错误信息就将长时间停留在显示屏（Windows 2000的默认设置）；如果此复选框被选中，“蓝屏”错误信息就将在短时间显示之后自动重新启动计算机（Windows XP及后续版本的Windows的默认设置）。 二.蓝屏DMP故障文件在哪儿？有盘环境，如上图所示，蓝屏dmp就存放在%SystemRoot%\\Minidump 目录中 即 c:\\windows\\Minidump 如果上图中的设置为%SystemRoot%\\Minidump.dmp，那么蓝屏故障dmp文件就在c:\\windows中的Minidump.dmp文件. 无盘环境，dmp文件就在无盘服务端软件的相关目录中！根据无盘系统不同，存放位置不同，一般就在无盘软件的dmp目录中! WINdbg是什么，我们需要它做什么？","text":"当您在运行Microsoft Windows 2000/XP/Server 2003、Microsoft Windows Vista/Server 2008、Microsoft Windows 7操作系统时，Windows可能会突然停止正常运行，并显示一副含有下述字样的蓝色背景错误信息画面： 1234A problem has been detected and Windows has been shut down to prevent damage to your computer.…… 此蓝色背景错误信息画面一般简称为“蓝屏（Blue Screen）”或“停止屏（Stop Error Screen）”，它可能会长时间停留在显示屏；也可能会在短时间显示之后自动重新启动计算机。windows蓝屏分析的方法是什么，遇到windows蓝屏如何查找原因，下面就进行说明! 一.原因分析：如果Windows因系统设置故障、软件故障、硬件故障、驱动程序故障、网络故障等各种类型的故障产生了严重的错误，引起Windows无法继续维持正常运行，Windows出于避免用户数据丢失及损坏计算机的考虑，将自动停止运行并显示“蓝屏”错误信息。 在默认的系统设置中，Windows 2000遇到“蓝屏”故障后“蓝屏”错误信息将长时间停留在显示屏，直到您关闭或重新启动计算机；Windows XP及后续版本的Windows遇到“蓝屏”故障后“蓝屏”错误信息将在短时间显示之后自动重新启动计算机。“蓝屏”故障发生后是否自动重新启动计算机取决于“启动与故障恢复”设置。您可以在“控制面板”中打开“系统”属性，切换至“高级”选项卡（如果是Windows Vista及以上版本的Windows请在“系统”属性左上方的工具栏中选择“高级系统设置”，确认用户帐户控制（UAC）安全提示，然后再切换至“高级”选项卡），在“高级”选项卡中打开“启动与故障恢复”。您可以在“启动与故障恢复”的选项中找到“自动重新启动”复选框，如果此复选框没有选中，Windows遇到“蓝屏”故障后“蓝屏”错误信息就将长时间停留在显示屏（Windows 2000的默认设置）；如果此复选框被选中，“蓝屏”错误信息就将在短时间显示之后自动重新启动计算机（Windows XP及后续版本的Windows的默认设置）。 二.蓝屏DMP故障文件在哪儿？有盘环境，如上图所示，蓝屏dmp就存放在%SystemRoot%\\Minidump 目录中 即 c:\\windows\\Minidump 如果上图中的设置为%SystemRoot%\\Minidump.dmp，那么蓝屏故障dmp文件就在c:\\windows中的Minidump.dmp文件. 无盘环境，dmp文件就在无盘服务端软件的相关目录中！根据无盘系统不同，存放位置不同，一般就在无盘软件的dmp目录中! WINdbg是什么，我们需要它做什么？ windbg是在windows平台下，强大的用户态和内核态调试工具。通过windbg工具的分析，我们可以从复杂的代码中找到蓝屏的驱动，文件，进程等来更准确的分析每次蓝屏背后的真凶。 三，windbg使用方法和技巧。 运行WinDbg软件，然后按【Ctrl+S】，在弹出的符号表设置窗里面输入SRVC:\\Symbolshttp://msdl.microsoft.com/download/symbols，然后点OK即可。如下图所示 按【Ctrl+D】，选择相对应的dmp文件，然后确定。如出下图所示，请选择NO跳过。当想打开第二个dmp文件时，需要先按【Shift+F5】来清除上一个dmp分析记录。 刚开始加载dmp文件可能较慢，等完全加完完毕后（如下图所示），大家对这些信息可能会眼花缭乱，不过没有关系，我们只需要关注几个重要的信息。 System Uptime（系统正常运行时间），如图所示，我们可以看出，这个顾客开机后7分15秒钟就蓝屏了，下面我们具体分析下这场蓝屏的因素 Probably caused by（可能蓝屏的原因），如下图所示，Probably caused by : nv4_disp.dll ( nv4_disp+2cacb )，我们可以这次蓝屏可能是 nv4_disp.dll这个文件引起的，让我们继续深入下去。 !analyze -v命令解析，在下面的对话框输入!analyze -v或点击!analyze -v命令会出现如下图所示，BUGCHECK_STR: 0x8E是指蓝屏代码为8E，PROCESS_NAME: mir2.dat，这个是指这次蓝屏引起的应用程序。 ！process命令验证，在下面的对话框输入！process命令，会出现如下图所示，基本上可以确定就是mir2.dat了。 通过上面7个步骤我们得知了2个重要的信息分别是是nv4_disp.dll和mir2.dat，那么这这2个文件是哪里的？那我们就要去客户机找相关信息了，最后得知 nv4_disp.dllNvidia显卡驱动的一个文件，mir2.dat是传奇世界的文件，由此我们可以判断此次蓝屏是由于显卡驱动的问题导致顾客在玩传奇世界时出问题了，后来果断更新显卡驱动解决了这次蓝屏的问题。 最后给大家一些分析dmp文件的建议： 我们知道，电脑蓝屏的因素很多，比如现在进入夏天了，由于天气过热温度过高等的原因也是很有可能导致机器蓝屏，并不是每次dmp文件都能准确的分析出有用的结论，这个还需要大家通过多分析，多总结而获得这方面的经验来对症下药。如果你网吧有200台机器，每天有接近四分之一的机器蓝屏，你可以通过我们软件获取的dmp文件来观察其代码是不是一致，如果是一样或者大多数都一样的代码，可以使用windbg工具按照上面的步骤来分析一下。 下面提供windbg下载地址：windbg 10：https://tool.pediy.com/index-detail-5.htmwindbg 6汉化版：点击下载","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"蓝屏代码","slug":"蓝屏代码","permalink":"https://goodhelp.gitee.io/tags/%E8%93%9D%E5%B1%8F%E4%BB%A3%E7%A0%81/"}]},{"title":"phpcms整合hdwiki接口文件使用说明及下载","slug":"code/phpcms整合hdwiki接口文件使用说明及下载","date":"2017-11-06T04:38:57.000Z","updated":"2021-09-16T23:32:26.637Z","comments":true,"path":"page/3400538132/","link":"","permalink":"https://goodhelp.gitee.io/page/3400538132/","excerpt":"HDwiki是专为中文用户设计和开发，程序源代码100%完全开放的一个采用 PHP 和 MySQL 数据库构建的高效的中文百科建站解决方案。官方网站为http://kaiyuan.hudong.com，下载，演示及使用请查看官方网站。本接口提供时互动百科系统版本为HDWiki5.1 正式版 发布日期：2011-09-27主域名为www.bnwin.com hdwiki域名为baike.bnwin.com均采用utf-8编码,phpcms v9域名和hdwiki域名应同属不同的子域名，不能采用不用的域名!因为cookie不允许跨域! 1.在phpcms v9后台的phpsso中添加应用应用名:hdwiki应用地址:http://baike.bnwin.com/api/通信密钥:(点击自动生成)类型:其他应用IP：(保持为空)通信文件：phpsso.php字符集:utf-8同步登录:是 添加应用后，查看应用ID号，并且复制自动生成的 通信密钥 2.打开接口文件中的phpssoconfig.php文件，修改define(‘APPID’, 3);中的3为上一步中查看的应用ID号,修改$ps_api_url的地址为phpsso的web地址，修改$ps_auth_key为上一步中自动生成的通信密钥。 phpssoconfig.php文件中无中文，如果加入中文，需要保存格式为utf-8无bom编码，不加中文可以使用记事本编辑，加入中文就不能使用记事本编辑，可以使用Notepad++编辑。 保存后把phpssoconfig.php phpsso.php client.class.php复制到hdwiki的api目录下，这三个文件是新增，没有修改hdwiki任何文件。 覆盖文件后，进入phpcms v9的应用管理，通信状态应该为通信成功。不成功请检查上面的步骤。 3.修改hdwiki的wiki_user表(安装时采用的默认前缀wiki)，添加字段phpssouid 类型bigint 长度20 小数点0 不允许空值，默认值为0 4.登录hdwiki后台 全局-&gt;扩展设置-&gt;通行证设置开启通行证:是通行证类型：phpcms通行证方式：客户端client通行证密钥：点击后面生成一个KEY连接程序地址：写phpcms v9主域名如http://www.bnwin.com会员注册地址：/index.php?m=member&amp;c=index&amp;a=register&amp;siteid=1会员登录地址：/index.php?m=member&amp;c=index&amp;a=login&amp;siteid=1会员退出地址：/index.php?m=member&amp;c=index&amp;a=logout&amp;siteid=1 hdwiki的后台对通行证的整合已经做了预置，只要把hdwiki做为客户端，那么hdwiki中的注册，登录，退出链接都会自动跳到你设置的主域名的注册,登录,退出链接地址。","text":"HDwiki是专为中文用户设计和开发，程序源代码100%完全开放的一个采用 PHP 和 MySQL 数据库构建的高效的中文百科建站解决方案。官方网站为http://kaiyuan.hudong.com，下载，演示及使用请查看官方网站。本接口提供时互动百科系统版本为HDWiki5.1 正式版 发布日期：2011-09-27主域名为www.bnwin.com hdwiki域名为baike.bnwin.com均采用utf-8编码,phpcms v9域名和hdwiki域名应同属不同的子域名，不能采用不用的域名!因为cookie不允许跨域! 1.在phpcms v9后台的phpsso中添加应用应用名:hdwiki应用地址:http://baike.bnwin.com/api/通信密钥:(点击自动生成)类型:其他应用IP：(保持为空)通信文件：phpsso.php字符集:utf-8同步登录:是 添加应用后，查看应用ID号，并且复制自动生成的 通信密钥 2.打开接口文件中的phpssoconfig.php文件，修改define(‘APPID’, 3);中的3为上一步中查看的应用ID号,修改$ps_api_url的地址为phpsso的web地址，修改$ps_auth_key为上一步中自动生成的通信密钥。 phpssoconfig.php文件中无中文，如果加入中文，需要保存格式为utf-8无bom编码，不加中文可以使用记事本编辑，加入中文就不能使用记事本编辑，可以使用Notepad++编辑。 保存后把phpssoconfig.php phpsso.php client.class.php复制到hdwiki的api目录下，这三个文件是新增，没有修改hdwiki任何文件。 覆盖文件后，进入phpcms v9的应用管理，通信状态应该为通信成功。不成功请检查上面的步骤。 3.修改hdwiki的wiki_user表(安装时采用的默认前缀wiki)，添加字段phpssouid 类型bigint 长度20 小数点0 不允许空值，默认值为0 4.登录hdwiki后台 全局-&gt;扩展设置-&gt;通行证设置开启通行证:是通行证类型：phpcms通行证方式：客户端client通行证密钥：点击后面生成一个KEY连接程序地址：写phpcms v9主域名如http://www.bnwin.com会员注册地址：/index.php?m=member&amp;c=index&amp;a=register&amp;siteid=1会员登录地址：/index.php?m=member&amp;c=index&amp;a=login&amp;siteid=1会员退出地址：/index.php?m=member&amp;c=index&amp;a=logout&amp;siteid=1 hdwiki的后台对通行证的整合已经做了预置，只要把hdwiki做为客户端，那么hdwiki中的注册，登录，退出链接都会自动跳到你设置的主域名的注册,登录,退出链接地址。 因为整合的目的，是让用户认为全部系统是完美结合在一起的一个系统。所以用户注册，用户登录，用户修改，用户退出全部系统都应该指向相同的文件。 下载地址：链接: https://pan.baidu.com/s/15ioEadpZ7XpW-5yrnfnZSg 提取码: b954 复制这段内容后打开百度网盘手机App，操作更方便哦","categories":[{"name":"源码","slug":"code","permalink":"https://goodhelp.gitee.io/categories/code/"}],"tags":[{"name":"php源码","slug":"php源码","permalink":"https://goodhelp.gitee.io/tags/php%E6%BA%90%E7%A0%81/"}]},{"title":"phpcms整合最土团购接口文件使用说明及下载","slug":"code/phpcms整合最土团购接口文件使用说明及下载","date":"2017-11-06T04:35:07.000Z","updated":"2021-09-16T23:32:10.081Z","comments":true,"path":"page/928002874/","link":"","permalink":"https://goodhelp.gitee.io/page/928002874/","excerpt":"最土团购系统官方网站http://www.zuitu.com，使用，下载，演示请到官方网站。本接口发布时 最土团购系统 版本编号： ZuituGo_CV2.0_20120502 商业版 主域名为www.bnwin.com zuitu团购域名为zuitu.bnwin.com均采用utf-8编码,phpcms v9域名和zuitu团购域名应同属不同的子域名，不能采用不用的域名!因为cookie不允许跨域! 1.在phpcms v9后台的phpsso中添加应用应用名:最土团购应用地址:http://zuitu.bnwin.com/account/通信密钥:(点击自动生成)类型:其他应用IP：(保持为空)通信文件：phpsso.php字符集:utf-8同步登录:是 添加应用后，查看应用ID号，并且复制自动生成的 通信密钥 2.打开接口文件中的account/phpssoconfig.php文件，修改define(‘APPID’, 4);中的7为上一步中查看的应用ID号,修改$ps_api_url的地址为phpsso的web地址，修改$ps_auth_key为上一步中自动生成的通信密钥。 phpssoconfig.php文件中无中文，如果加入中文，需要保存格式为utf-8无bom编码，不加中文可以使用记事本编辑，加入中文就不能使用记事本编辑，可以使用Notepad++编辑。 保存后把account目录复制到最土团购根目录覆盖。接口文件的login.php logout.php对原系统有所修改，你可以事先对团购系统account目录中的这两个文件进行备份,目录中的其他三个文件是新增的。 覆盖文件后，进入phpcms v9的应用管理，通信状态应该为通信成功。不成功请检查上面的步骤。 3.修改团购系统的user表，添加字段phpssouid 类型bigint 长度20 小数点0 不允许空值，默认值为0 建议去掉直接在团购系统注册，因为团购系统注册的密码不能直接保存在phpcms v9中，会出现以phpcmsv9登录时，不能同步登录团购系统。","text":"最土团购系统官方网站http://www.zuitu.com，使用，下载，演示请到官方网站。本接口发布时 最土团购系统 版本编号： ZuituGo_CV2.0_20120502 商业版 主域名为www.bnwin.com zuitu团购域名为zuitu.bnwin.com均采用utf-8编码,phpcms v9域名和zuitu团购域名应同属不同的子域名，不能采用不用的域名!因为cookie不允许跨域! 1.在phpcms v9后台的phpsso中添加应用应用名:最土团购应用地址:http://zuitu.bnwin.com/account/通信密钥:(点击自动生成)类型:其他应用IP：(保持为空)通信文件：phpsso.php字符集:utf-8同步登录:是 添加应用后，查看应用ID号，并且复制自动生成的 通信密钥 2.打开接口文件中的account/phpssoconfig.php文件，修改define(‘APPID’, 4);中的7为上一步中查看的应用ID号,修改$ps_api_url的地址为phpsso的web地址，修改$ps_auth_key为上一步中自动生成的通信密钥。 phpssoconfig.php文件中无中文，如果加入中文，需要保存格式为utf-8无bom编码，不加中文可以使用记事本编辑，加入中文就不能使用记事本编辑，可以使用Notepad++编辑。 保存后把account目录复制到最土团购根目录覆盖。接口文件的login.php logout.php对原系统有所修改，你可以事先对团购系统account目录中的这两个文件进行备份,目录中的其他三个文件是新增的。 覆盖文件后，进入phpcms v9的应用管理，通信状态应该为通信成功。不成功请检查上面的步骤。 3.修改团购系统的user表，添加字段phpssouid 类型bigint 长度20 小数点0 不允许空值，默认值为0 建议去掉直接在团购系统注册，因为团购系统注册的密码不能直接保存在phpcms v9中，会出现以phpcmsv9登录时，不能同步登录团购系统。 因为整合的目的，是让用户认为全部系统是完美结合在一起的一个系统。所以建议，所有整合系统的用户注册，用户登录，用户修改，用户退出全部系统都指向phpcms v9的文件链接,同时去掉被整合系统模板中的修改密码。 下载地址：链接: https://pan.baidu.com/s/1SJHbfEbGUdwf2SSIgs9INQ 提取码: kbqy 复制这段内容后打开百度网盘手机App，操作更方便哦 部份代码 12&lt;?php require_once(dirname(dirname(__FILE__)) . &#x27;/app.php&#x27;); require (&#x27;phpssoconfig.php&#x27;); $code = $_REQUEST[&#x27;code&#x27;]; parse_str($client-&gt;sys_auth($code, &#x27;DECODE&#x27;), $arr); if(isset($arr[&#x27;action&#x27;])) &#123; $action = $arr[&#x27;action&#x27;]; &#125; else &#123; exit(&#x27;0&#x27;); &#125; switch($action) &#123; case &#x27;check_status&#x27;: exit(&#x27;1&#x27;); break; case &#x27;member_add&#x27;: $username = isset($arr[&#x27;username&#x27;]) ? $arr[&#x27;username&#x27;] : exit(&#x27;0&#x27;); $password = isset($arr[&#x27;password&#x27;]) ? $arr[&#x27;password&#x27;] : exit(&#x27;0&#x27;); $email = isset($arr[&#x27;email&#x27;]) ? $arr[&#x27;email&#x27;] : exit(&#x27;0&#x27;); $uid = isset($arr[&#x27;uid&#x27;]) ? $arr[&#x27;uid&#x27;] : exit(&#x27;0&#x27;); $u = array(); $u[&#x27;username&#x27;] = $username; $u[&#x27;password&#x27;] = $password; $u[&#x27;email&#x27;] = $email; $u[&#x27;city_id&#x27;]=0; $u[&#x27;phpssouid&#x27;]=$uid; if($user_id = ZUser::Create($u))&#123; ZCredit::Register($user_id); exit(&#x27;1&#x27;); &#125; else &#123; exit(&#x27;0&#x27;); &#125; break; case &#x27;member_delete&#x27;: $uidarr = $arr[&#x27;uids&#x27;]; foreach($uidarr as $k=&gt;$v)&#123; $uid=$v; $ids = Table::Fetch(&#x27;user&#x27;, $uid,&#x27;phpssouid&#x27;); $id=$ids[&#x27;id&#x27;];","categories":[{"name":"源码","slug":"code","permalink":"https://goodhelp.gitee.io/categories/code/"}],"tags":[{"name":"php源码","slug":"php源码","permalink":"https://goodhelp.gitee.io/tags/php%E6%BA%90%E7%A0%81/"}]},{"title":"ae模板-央视级震撼大气纪念胜利片头","slug":"material/ae模板-央视级震撼大气纪念胜利片头","date":"2017-11-04T03:28:32.000Z","updated":"2021-09-11T16:42:51.451Z","comments":true,"path":"page/3610687905/","link":"","permalink":"https://goodhelp.gitee.io/page/3610687905/","excerpt":"Adobe After Effects简称“AE”是Adobe公司推出的一款图形视频处理软件，适用于从事设计和视频特技的机构，包括电视台、动画制作公司、个人后期制作工作室以及多媒体工作室。属于层类型后期软件。 模板，是指作图或设计方案的固定格式，有时也指DNA复制或转录时，用来产生互补链的核苷酸序列。模板是将一个事物的结构规律予以固定化、标准化的成果，它体现的是结构形式的标准化。 此模板为:ae模板-央视级震撼大气纪念片头 要求软件 :AfterEffects CS 6【模板尺寸】1920*1080【时间长度】32秒【文件大小】239M视频预览:您的浏览器不支持HTML5的 video 标签，无法为您播放！ae模板-央视级震撼大气纪念片头，片头图片截图如下： 下载地址:https://pan.baidu.com/s/1wjdPDQ9SQAlyboVr3CwvPw 密码：ch3a","text":"Adobe After Effects简称“AE”是Adobe公司推出的一款图形视频处理软件，适用于从事设计和视频特技的机构，包括电视台、动画制作公司、个人后期制作工作室以及多媒体工作室。属于层类型后期软件。 模板，是指作图或设计方案的固定格式，有时也指DNA复制或转录时，用来产生互补链的核苷酸序列。模板是将一个事物的结构规律予以固定化、标准化的成果，它体现的是结构形式的标准化。 此模板为:ae模板-央视级震撼大气纪念片头 要求软件 :AfterEffects CS 6【模板尺寸】1920*1080【时间长度】32秒【文件大小】239M视频预览:您的浏览器不支持HTML5的 video 标签，无法为您播放！ae模板-央视级震撼大气纪念片头，片头图片截图如下： 下载地址:https://pan.baidu.com/s/1wjdPDQ9SQAlyboVr3CwvPw 密码：ch3a","categories":[{"name":"素材","slug":"material","permalink":"https://goodhelp.gitee.io/categories/material/"}],"tags":[{"name":"ae模板","slug":"ae模板","permalink":"https://goodhelp.gitee.io/tags/ae%E6%A8%A1%E6%9D%BF/"}]},{"title":"phpcms整合iWebIM接口文件及使用说明","slug":"code/phpcms整合iWebIM接口文件及使用说明","date":"2017-11-03T04:32:52.000Z","updated":"2021-09-16T23:32:19.945Z","comments":true,"path":"page/2283263265/","link":"","permalink":"https://goodhelp.gitee.io/page/2283263265/","excerpt":"iWebIM作为一款以解决大型站点高并发高负载问题为主要任务的开源webIM软件，iWebIM功能强大，易于集成。主动易用的可嵌入式设计使他可以方便的和现有所有社区系统集成在一起。演示，下载，使用说明见官方网站http://www.jooyea.cn/ PHPCMS V9（后面简称V9）采用PHP5+MYSQL做为技术基础进行开发。V9采用OOP（面向对象）方式进行基础运行框架搭建。模块化开发方式做为功能开发形式。框架易于功能扩展，代码维护，优秀的二次开发能力，可满足所有网站的应用需求。 5年开发经验的优秀团队，在掌握了丰富的WEB开发经验和CMS产品开发经验的同时，勇于创新追求完美的设计理念，为全球多达10万网站提供助力，并被更多的政府机构、教育机构、事业单位、商业企业、个人站长所认可。 本接口提供时iWebIM版本为 iweb IM v1.0 Beta2，phpcms整合iwebim，让phpcms也有类似于QQ的有在线聊天功能! 1.下载iWebIM，在phpcms v9的根目录下建立im目录，把iWebIM解压后的全部文件复制到im目录。 2.在phpcms v9的数据库上执行iWebIM的install.sql，添加iWebIM需要的数据表到phpcm v9的数据库中。 3.用Notepad++修改接口文件中的iweb_mini_lib/conf/dbconf.php中的数据库名，密码和phpcms v9的数据库名。 4.用notepad++修改接口文件中的configuration.php文件，$siteDomain值改为你的phpcms v9域名末尾加/ 5.接口文件中的plugins/plugin_for_phpcms.php文件的phpcms_key值为 phpcms v9的\\caches\\configs\\system.php文件中auth_key的值,$cookiepre的值，$cookiepre的值为\\caches\\configs\\system.php文件中cookie_pre的值，注意此文件是两个_ 而不是一个_ 6.把修改好的接口文件全部复制到phpcms v9根目录建的im目录中覆盖。 7.在需要phpcms v9需要显示iwebim的网页中加入","text":"iWebIM作为一款以解决大型站点高并发高负载问题为主要任务的开源webIM软件，iWebIM功能强大，易于集成。主动易用的可嵌入式设计使他可以方便的和现有所有社区系统集成在一起。演示，下载，使用说明见官方网站http://www.jooyea.cn/ PHPCMS V9（后面简称V9）采用PHP5+MYSQL做为技术基础进行开发。V9采用OOP（面向对象）方式进行基础运行框架搭建。模块化开发方式做为功能开发形式。框架易于功能扩展，代码维护，优秀的二次开发能力，可满足所有网站的应用需求。 5年开发经验的优秀团队，在掌握了丰富的WEB开发经验和CMS产品开发经验的同时，勇于创新追求完美的设计理念，为全球多达10万网站提供助力，并被更多的政府机构、教育机构、事业单位、商业企业、个人站长所认可。 本接口提供时iWebIM版本为 iweb IM v1.0 Beta2，phpcms整合iwebim，让phpcms也有类似于QQ的有在线聊天功能! 1.下载iWebIM，在phpcms v9的根目录下建立im目录，把iWebIM解压后的全部文件复制到im目录。 2.在phpcms v9的数据库上执行iWebIM的install.sql，添加iWebIM需要的数据表到phpcm v9的数据库中。 3.用Notepad++修改接口文件中的iweb_mini_lib/conf/dbconf.php中的数据库名，密码和phpcms v9的数据库名。 4.用notepad++修改接口文件中的configuration.php文件，$siteDomain值改为你的phpcms v9域名末尾加/ 5.接口文件中的plugins/plugin_for_phpcms.php文件的phpcms_key值为 phpcms v9的\\caches\\configs\\system.php文件中auth_key的值,$cookiepre的值，$cookiepre的值为\\caches\\configs\\system.php文件中cookie_pre的值，注意此文件是两个_ 而不是一个_ 6.把修改好的接口文件全部复制到phpcms v9根目录建的im目录中覆盖。 7.在需要phpcms v9需要显示iwebim的网页中加入 需要注意im/configuration.php文件中设置的域名，才能添加iwebim，其他子域名不能使用iwebim，仍然是cookie不能跨域问题. 接口文件下载地址:链接: https://pan.baidu.com/s/1JTiviDgWFu6m8ep4xDWaiA 提取码: 1gnp 复制这段内容后打开百度网盘手机App，操作更方便哦","categories":[{"name":"源码","slug":"code","permalink":"https://goodhelp.gitee.io/categories/code/"}],"tags":[{"name":"php源码","slug":"php源码","permalink":"https://goodhelp.gitee.io/tags/php%E6%BA%90%E7%A0%81/"}]},{"title":"句柄精灵ViewWizard获得窗口句柄等信息和属性","slug":"soft/句柄精灵ViewWizard获得窗口句柄等信息和属性","date":"2017-11-03T03:47:49.000Z","updated":"2021-09-11T16:45:26.125Z","comments":true,"path":"page/1479143853/","link":"","permalink":"https://goodhelp.gitee.io/page/1479143853/","excerpt":"ViewWizard 3.5 句柄精灵是一个窗口辅助工具，用于获得窗口或控件的句柄等各种信息和属性。其中包括窗口类，大小，样式，状态，字体等相关内容。此外，它可以控制一个窗口的状态，比如显示或隐藏，置顶，透明，更改样式等等。 具体介绍： 窗口样式编辑器：用于修改窗口样式和扩展样式。窗口创建监视器：监视顶层窗口的创建和销毁。系统窗口列表：查看系统所有窗口，其中包括不可见的Message窗口以及内核挂钩的隐藏窗口。自动显示隐藏控件：选择该项后，当前活动窗口中的隐藏的控件（子窗口）会全部显示出来。自动激活无效控件：选择该项后，当前活动窗口中的无效的控件（呈灰色）会变为有效。取色器：功能强大的屏幕取色器。屏幕抓图工具：可抓取桌面、窗口和区域图像。 软件设置： 搜索隐藏窗口：搜索隐藏的控件，不包括顶层窗口。搜索透明窗口：搜索穿透的窗口，这种窗口不接受鼠标点击。搜索挂起窗口：搜索被挂起线程的窗口，容易死锁，除非特殊情况，否则不要选择。暴力搜索窗口：强制遍历系统所有窗口透视搜索窗口：搜索前先把自己设为穿透，以便能够看到下面的窗口。Shift键搜索：按下Shift键自动捕获窗口。搜索模式：精确搜索将搜索最内层的可见的子窗口，标准Z序搜索将搜索最上层的窗口。 其它选项： 鼠标链接：关系一栏所列出的相关窗口以及文件路径栏，单击以便快速捕获窗口或定位文件。附加栏：列出基本控件的专项信息。窗口文本查看功能：该项会列出窗口的标题或控件的文字内容，对于特殊类型的窗口，比如ListView，则会列出它的列表项数据。窗口菜单查看功能：列出窗口包含的菜单内容。*内容：代表该项不可用或者获取失败。终极模式：拖动搜索屏幕上能看到的所有窗口 3.5增加搜索挂起窗口增加暴力搜索窗口及暴力模式密码框判断不对加强总在最前问题通过数值编辑窗口样式 3.4.8总在最前后不再被Win+D最小化 3.4.6加强总在最前时右键菜单无法弹出 3.4.5增加设置还原密码框字符增加加强总在最前密码掩码有时获取不对 3.4：窗口列表图标换掉增加进程部分信息增加设置窗口视界修正系统窗口列表功能增加窗口最大化坐标/最小最大尺寸增加窗口透明度显示修正设置窗口透明/穿透功能光标和画刷描述 3.3：增加ListView修改器，可编辑任意ListView控件内容增加部分热键样式窗口选定项高亮显示 3.2：增加查看进程窗口功能win8以上无法获取消息窗口问题菜单布局等其它问题 3.1.1：控件显示状态不正确问题，不再随父窗口的状态而改变 3.1更新：1.增加窗口坐标功能2.修复窗口坐标显示不准确问题3.修复编辑窗口坐标窗口4.增加智能调整窗口大小5.增加直接复制句柄6.非标准类不能保存问题 下载地址：链接: https://pan.baidu.com/s/1ChWSUHr-rAljhOR4cnXH0Q 提取码: hnkn 复制这段内容后打开百度网盘手机App，操作更方便哦","text":"ViewWizard 3.5 句柄精灵是一个窗口辅助工具，用于获得窗口或控件的句柄等各种信息和属性。其中包括窗口类，大小，样式，状态，字体等相关内容。此外，它可以控制一个窗口的状态，比如显示或隐藏，置顶，透明，更改样式等等。 具体介绍： 窗口样式编辑器：用于修改窗口样式和扩展样式。窗口创建监视器：监视顶层窗口的创建和销毁。系统窗口列表：查看系统所有窗口，其中包括不可见的Message窗口以及内核挂钩的隐藏窗口。自动显示隐藏控件：选择该项后，当前活动窗口中的隐藏的控件（子窗口）会全部显示出来。自动激活无效控件：选择该项后，当前活动窗口中的无效的控件（呈灰色）会变为有效。取色器：功能强大的屏幕取色器。屏幕抓图工具：可抓取桌面、窗口和区域图像。 软件设置： 搜索隐藏窗口：搜索隐藏的控件，不包括顶层窗口。搜索透明窗口：搜索穿透的窗口，这种窗口不接受鼠标点击。搜索挂起窗口：搜索被挂起线程的窗口，容易死锁，除非特殊情况，否则不要选择。暴力搜索窗口：强制遍历系统所有窗口透视搜索窗口：搜索前先把自己设为穿透，以便能够看到下面的窗口。Shift键搜索：按下Shift键自动捕获窗口。搜索模式：精确搜索将搜索最内层的可见的子窗口，标准Z序搜索将搜索最上层的窗口。 其它选项： 鼠标链接：关系一栏所列出的相关窗口以及文件路径栏，单击以便快速捕获窗口或定位文件。附加栏：列出基本控件的专项信息。窗口文本查看功能：该项会列出窗口的标题或控件的文字内容，对于特殊类型的窗口，比如ListView，则会列出它的列表项数据。窗口菜单查看功能：列出窗口包含的菜单内容。*内容：代表该项不可用或者获取失败。终极模式：拖动搜索屏幕上能看到的所有窗口 3.5增加搜索挂起窗口增加暴力搜索窗口及暴力模式密码框判断不对加强总在最前问题通过数值编辑窗口样式 3.4.8总在最前后不再被Win+D最小化 3.4.6加强总在最前时右键菜单无法弹出 3.4.5增加设置还原密码框字符增加加强总在最前密码掩码有时获取不对 3.4：窗口列表图标换掉增加进程部分信息增加设置窗口视界修正系统窗口列表功能增加窗口最大化坐标/最小最大尺寸增加窗口透明度显示修正设置窗口透明/穿透功能光标和画刷描述 3.3：增加ListView修改器，可编辑任意ListView控件内容增加部分热键样式窗口选定项高亮显示 3.2：增加查看进程窗口功能win8以上无法获取消息窗口问题菜单布局等其它问题 3.1.1：控件显示状态不正确问题，不再随父窗口的状态而改变 3.1更新：1.增加窗口坐标功能2.修复窗口坐标显示不准确问题3.修复编辑窗口坐标窗口4.增加智能调整窗口大小5.增加直接复制句柄6.非标准类不能保存问题 下载地址：链接: https://pan.baidu.com/s/1ChWSUHr-rAljhOR4cnXH0Q 提取码: hnkn 复制这段内容后打开百度网盘手机App，操作更方便哦","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"精品软件","slug":"精品软件","permalink":"https://goodhelp.gitee.io/tags/%E7%B2%BE%E5%93%81%E8%BD%AF%E4%BB%B6/"}]},{"title":"ikeeper爱克吧上网卡磁条信息算法分析","slug":"code/ikeeper爱克吧上网卡磁条信息算法分析","date":"2017-11-02T04:24:05.000Z","updated":"2021-09-16T23:32:39.086Z","comments":true,"path":"page/1725108992/","link":"","permalink":"https://goodhelp.gitee.io/page/1725108992/","excerpt":"ikeeper爱克吧上网卡现在早已退出了历史舞台，不过对于学习，把当时分析的爱克吧上网卡磁条信息算法归纳整理一下，算做温故而知新吧!本文属原创，百脑问bnwin.com首发! ikeeper爱克吧是什么?【Ikeeper计费管理系统】是重庆智多信息发展有限公司继【实名上网管理系统】后全新开发的计费管理版本。主要用于网吧，学校及各种收费机房的管理，是一款真正全方位从各网吧老板及各种营业性收费机房业主经营管理角度出发，设计体贴入微的经营管理软件。经过我公司不断的升级完善，目前已经得到了广大用户广泛认可。在重庆地区拥有百分之九十以上的市场占有率，目前公司正在积极拓展四川、海南、内蒙等市场并取得了巨大的成就，充分显示了【Ikeeper计费管理系统】与其他同类产品比较所具备的明显技术优势。简而言之爱克吧就是公安网监强制要求网吧安装的网吧安全及计费实名管理系统! 上网卡是什么？上网卡是爱克吧系统为实现实名制而采用的一种磁卡，上网卡根据身份证信息注册后使用，和银行的磁卡形状及使用方法一样！上网卡有10位数字（如0231466248)，但磁条信息并不是只记录了10位数字，而是这种;200329902314662482=500999000113801? 记录了相关信息。看看上网卡的实物上网卡磁条信息算法解析 本文本着学习的思想，当前已经不能使用上网卡，所以发布上网卡磁条信息算法，仅供学习使用，费话不多说，下面入正题，正式分析上网卡磁条信息内容： 先设置一个常量 常量表493806291608186256487098521453479841593425669412557213331214712906201512413249919383758208612080780228491236189833979289217766495864839471398976449709001708631663736696479153718969090756731903064662430102993165969185690184619921373013471 然后我们举一个例，如上网卡号 7474747474磁条信息为;200391774747474742=500999000151993? 分解为;200 3917 7474747474 2 =5009990001 51993 ?1234 5 67890 算法及分析此1-10位的算法而;200 =5009990001和末尾的?为常量，无需要计算。中间为卡号也无需计算，需要计算的就是上图标识的1-10位的数的由来 以下是上网卡磁条信息的delphi的源代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586function getnumtotal(firstnum:Integer;jsstring:string;ys:Boolean):Integer; //字符串acsii相加减 var ls,x:integer; ls1:string; begin x:=firstnum; for ls:=1 to Length(jsstring) do begin if ys then x:=x+ord(jsstring[ls]) else x:=x-ord(jsstring[ls]); ls1:=&#x27;$&#x27;+inttohex(x,2); if Length(ls1)&gt;3 then x:=strtoint(&#x27;$&#x27;+rightstr(ls1,2)); end; result:=x; end;function fullcard(numcard:string):string; //取得完整磁卡编码 var mycont,mycont1,mycont2,mycont3,mycont4,mycont5:string; mystr1,mystr2,lsstring:string; a1,a2,a3,a4,a5,a6,a7,a8,a9,a10:integer; b1,b2,b3,b4,b5,b6,b7,b8,b9,b10:string; ls1,ls2:integer; begin //常量表 mycont:=&#x27;493806291608186256487098521453479841593425669412557213331214712906201512413249919383758208612080780228491236189833979289217766495864839471398976449709001708631663736696479153718969090756731903064662430102993165969185690184619921373013471&#x27;; mystr1:=Trim(numcard); //上网卡号 mystr2:=&#x27;5009990001&#x27;; //常数 mycont1:=mystr1+mystr2; //形成 74747474745009990001 mycont2:=LeftStr(mystr1,5)+rightstr(mystr2,5); //形成7474790001 mycont3:=RightStr(mystr1,5)+leftstr(mystr2,5); //形成4747450099 //第一位 a1:=getnumtotal($35,mycont1,true)*getnumtotal($0C,mycont1,false); a1:=a1 mod $D7; b1:=mycont[a1+1]; //第二位 a2:=(a1 shl 2)*3 ; a2:=a2 mod $93; b2:=mycont[a2+1]; //第四位 a4:=(a2+a1) shl 3; a4:=a4 mod $DA; b4:=mycont[a4+1]; //第七位 a7:=(a1 shl 5)+a4; a7:=a7*$20 mod $DA; b7:=mycont[a7+1]; //第八位 a8:=((a1 shl 5)+a1+a7)*$21; a8:=a8 mod $DA; b8:=mycont[a8+1]; //第九位 a9:=((a1 shl 5)+a1+a1+a8)*$22; a9:=a9 mod $DA; b9:=mycont[a9+1]; //第三位 a3:=getnumtotal($7,mycont2,True)+a1; a3:=(a3 shl 3)-getnumtotal($7,mycont2,True)-a1; a3:=a3 mod $93; b3:=mycont[a3+1]; //第十位 a10:=getnumtotal($11,mycont3,false)+a1; a10:=(a10 shl 3)-getnumtotal($11,mycont3,false)-a1; a10:=a10+(a10 shl 2); a10:=a10 mod $93; b10:=mycont[a10+1]; //第五位 mycont4:=&#x27;;=200&#x27;+b1+b2+b3+b4+mystr1; //;=20039177474747474 ls1:=getnumtotal(a1,mycont4,False); lsstring:=&#x27;=&#x27;+mystr2; ls2:=getnumtotal(ls1,lsstring,True); a5:=getnumtotal(ls2,b7+b8+b9+b10,False)+a1; a5:=a5+(a5+(a5 shl 3))*2; a5:=a5 mod $93; b5:=mycont[a5+1]; //第六位 mycont5:=mycont4+b5+&#x27;=&#x27;+mystr2; a6:=getnumtotal(getnumtotal(a1,mycont5,True),b7+b8+b9+b10,False)+a1; a6:=(a6 shl 5)-a6; a6:=a6 mod $93; b6:=mycont[a6+1]; result:=&#x27;200&#x27;+b1+b2+b3+b4+mystr1+b5+&#x27;=&#x27;+mystr2+b6+b7+b8+b9+b10; end;","text":"ikeeper爱克吧上网卡现在早已退出了历史舞台，不过对于学习，把当时分析的爱克吧上网卡磁条信息算法归纳整理一下，算做温故而知新吧!本文属原创，百脑问bnwin.com首发! ikeeper爱克吧是什么?【Ikeeper计费管理系统】是重庆智多信息发展有限公司继【实名上网管理系统】后全新开发的计费管理版本。主要用于网吧，学校及各种收费机房的管理，是一款真正全方位从各网吧老板及各种营业性收费机房业主经营管理角度出发，设计体贴入微的经营管理软件。经过我公司不断的升级完善，目前已经得到了广大用户广泛认可。在重庆地区拥有百分之九十以上的市场占有率，目前公司正在积极拓展四川、海南、内蒙等市场并取得了巨大的成就，充分显示了【Ikeeper计费管理系统】与其他同类产品比较所具备的明显技术优势。简而言之爱克吧就是公安网监强制要求网吧安装的网吧安全及计费实名管理系统! 上网卡是什么？上网卡是爱克吧系统为实现实名制而采用的一种磁卡，上网卡根据身份证信息注册后使用，和银行的磁卡形状及使用方法一样！上网卡有10位数字（如0231466248)，但磁条信息并不是只记录了10位数字，而是这种;200329902314662482=500999000113801? 记录了相关信息。看看上网卡的实物上网卡磁条信息算法解析 本文本着学习的思想，当前已经不能使用上网卡，所以发布上网卡磁条信息算法，仅供学习使用，费话不多说，下面入正题，正式分析上网卡磁条信息内容： 先设置一个常量 常量表493806291608186256487098521453479841593425669412557213331214712906201512413249919383758208612080780228491236189833979289217766495864839471398976449709001708631663736696479153718969090756731903064662430102993165969185690184619921373013471 然后我们举一个例，如上网卡号 7474747474磁条信息为;200391774747474742=500999000151993? 分解为;200 3917 7474747474 2 =5009990001 51993 ?1234 5 67890 算法及分析此1-10位的算法而;200 =5009990001和末尾的?为常量，无需要计算。中间为卡号也无需计算，需要计算的就是上图标识的1-10位的数的由来 以下是上网卡磁条信息的delphi的源代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586function getnumtotal(firstnum:Integer;jsstring:string;ys:Boolean):Integer; //字符串acsii相加减 var ls,x:integer; ls1:string; begin x:=firstnum; for ls:=1 to Length(jsstring) do begin if ys then x:=x+ord(jsstring[ls]) else x:=x-ord(jsstring[ls]); ls1:=&#x27;$&#x27;+inttohex(x,2); if Length(ls1)&gt;3 then x:=strtoint(&#x27;$&#x27;+rightstr(ls1,2)); end; result:=x; end;function fullcard(numcard:string):string; //取得完整磁卡编码 var mycont,mycont1,mycont2,mycont3,mycont4,mycont5:string; mystr1,mystr2,lsstring:string; a1,a2,a3,a4,a5,a6,a7,a8,a9,a10:integer; b1,b2,b3,b4,b5,b6,b7,b8,b9,b10:string; ls1,ls2:integer; begin //常量表 mycont:=&#x27;493806291608186256487098521453479841593425669412557213331214712906201512413249919383758208612080780228491236189833979289217766495864839471398976449709001708631663736696479153718969090756731903064662430102993165969185690184619921373013471&#x27;; mystr1:=Trim(numcard); //上网卡号 mystr2:=&#x27;5009990001&#x27;; //常数 mycont1:=mystr1+mystr2; //形成 74747474745009990001 mycont2:=LeftStr(mystr1,5)+rightstr(mystr2,5); //形成7474790001 mycont3:=RightStr(mystr1,5)+leftstr(mystr2,5); //形成4747450099 //第一位 a1:=getnumtotal($35,mycont1,true)*getnumtotal($0C,mycont1,false); a1:=a1 mod $D7; b1:=mycont[a1+1]; //第二位 a2:=(a1 shl 2)*3 ; a2:=a2 mod $93; b2:=mycont[a2+1]; //第四位 a4:=(a2+a1) shl 3; a4:=a4 mod $DA; b4:=mycont[a4+1]; //第七位 a7:=(a1 shl 5)+a4; a7:=a7*$20 mod $DA; b7:=mycont[a7+1]; //第八位 a8:=((a1 shl 5)+a1+a7)*$21; a8:=a8 mod $DA; b8:=mycont[a8+1]; //第九位 a9:=((a1 shl 5)+a1+a1+a8)*$22; a9:=a9 mod $DA; b9:=mycont[a9+1]; //第三位 a3:=getnumtotal($7,mycont2,True)+a1; a3:=(a3 shl 3)-getnumtotal($7,mycont2,True)-a1; a3:=a3 mod $93; b3:=mycont[a3+1]; //第十位 a10:=getnumtotal($11,mycont3,false)+a1; a10:=(a10 shl 3)-getnumtotal($11,mycont3,false)-a1; a10:=a10+(a10 shl 2); a10:=a10 mod $93; b10:=mycont[a10+1]; //第五位 mycont4:=&#x27;;=200&#x27;+b1+b2+b3+b4+mystr1; //;=20039177474747474 ls1:=getnumtotal(a1,mycont4,False); lsstring:=&#x27;=&#x27;+mystr2; ls2:=getnumtotal(ls1,lsstring,True); a5:=getnumtotal(ls2,b7+b8+b9+b10,False)+a1; a5:=a5+(a5+(a5 shl 3))*2; a5:=a5 mod $93; b5:=mycont[a5+1]; //第六位 mycont5:=mycont4+b5+&#x27;=&#x27;+mystr2; a6:=getnumtotal(getnumtotal(a1,mycont5,True),b7+b8+b9+b10,False)+a1; a6:=(a6 shl 5)-a6; a6:=a6 mod $93; b6:=mycont[a6+1]; result:=&#x27;200&#x27;+b1+b2+b3+b4+mystr1+b5+&#x27;=&#x27;+mystr2+b6+b7+b8+b9+b10; end; 12345678910110058C14B . 8D55 9C lea edx, [ebp-64] 0058C14E . 8B86 00030000 mov eax, [esi+300] 0058C154 . E8 F7DCEDFF call 00469E50 0058C159 . 8B55 9C mov edx, [ebp-64] ;输入的卡号 0058C15C . A1 64355900 mov eax, [593564] 0058C161 . 8B00 mov eax, [eax] 0058C163 . 59 pop ecx 0058C164 . E8 7360FFFF call 005821DC ;磁条完整信息生成函数 0058C169 . A1 64645900 mov eax, [596464] 0058C16E . 50 push eax 0058C16F . 8B45 FC mov eax, [ebp-4] ;完整的磁条信息 15=200 0847 A 5=5009990001 89124 常量表493806291608186256487098521453479841593425669412557213331214712906201512413249919383758208612080780228491236189833979289217766495864839471398976449709001708631663736696479153718969090756731903064662430102993165969185690184619921373013471 例 ;200 3917 7474747474 2 =5009990001 51993?1234 5 67890;200 (35+74747474745009990001)(0C-74747474745009990001) MOD D7=4DF4 mod d7=18788 mod D7=53——-[ebp-$68]——-&gt;3 53 shl 2=14C (14c+14c*2) MOD 93=3E4 MOD 93=72—————————————-[ebp-$6C]———–&gt;9 4 (72+53)=C5 shl 3=628 MOD DA=32———————————————————-[ebp-$70]————&gt;7 7 53 shl 5=A60 (A60+32)*20(常量) MOD DA=2E———————————————-[ebp-$74]————-&gt;1 8 53 shl 5=A60 ((A60+53)+2E)*21(常量) mod DA=7F—————————————–[ebp-$78]————-&gt;9 9 ((53 shl 5)+53+53+7F)*22(常量) MOD Da=CC ————————————————[ebp-$7C]——————-&gt;9 (7+7474790001)=0E+53=61左移三位 (308-0E-53=2A7) mod 93=5B——————————[ebp-$80]————–&gt;1 10 (11-4747450099)=00+53=53左移三位 (298-00-53=245+(245左移两位914))=B59 mod 93=70——-[ebp+$FFFFFF7C]——-&gt;3 5 (53-;=20039177474747474=5E)+(=5009990001)=9C-(最后四位即7+8+9+10位)1993=C6+53=119左移三位 8C8+119=9E1 9E1+9E1+119=14DB MOD 93=2F—&gt;2 开始拼凑前面的部分 [ebp+$FFFFFF78] 6 [(53+;=200391774747474742=5009990001=B8)-(最后四位即7+8+9+10位)1993]=E2+53=135左移5位 26A0-135=256B Mod 93=18—-[ebp+$FFFFFF74]–&gt;5","categories":[{"name":"源码","slug":"code","permalink":"https://goodhelp.gitee.io/categories/code/"}],"tags":[{"name":"delphi源码","slug":"delphi源码","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%BA%90%E7%A0%81/"},{"name":"爱克吧","slug":"爱克吧","permalink":"https://goodhelp.gitee.io/tags/%E7%88%B1%E5%85%8B%E5%90%A7/"}]},{"title":"phpcms整合DESTOONB2B接口文件及使用说明","slug":"code/phpcms整合DESTOONB2B接口文件及使用说明","date":"2017-10-31T04:22:26.000Z","updated":"2021-09-16T23:32:32.565Z","comments":true,"path":"page/415747762/","link":"","permalink":"https://goodhelp.gitee.io/page/415747762/","excerpt":"DESTOON B2B是一套基于PHP+MySQL的开源B2B电子商务行业门户网站解决方案。官方网站为http://www.destoon.com，下载，演示及使用请查看官方网站。实际就是仿阿里巴巴的php系统。—本接口提供时destoon版本为 最新版本：V4.0 更新时间：2012-04-28 phpcms如何整合destoon？destoon如何整合phpcms呢？本文就会介绍具体方法和提供接口文件! 至于为什么phpcms需要整合destoon,因为phpcms的黄页功能不全，destoon功能全！ 主域名为www.bnwin.com destoon域名为b2b.bnwin.com均采用utf-8编码,phpcms v9域名和destoon域名应同属不同的子域名，不能采用不用的域名!因为cookie不允许跨域! 1.在phpcms v9后台的phpsso中添加应用应用名:destoonB2B应用地址:http://b2b.bnwin.com/member/通信密钥:(点击自动生成)类型:其他应用IP：(保持为空)通信文件：phpsso.php字符集:utf-8同步登录:是 添加应用后，查看应用ID号，并且复制自动生成的 通信密钥 2.打开接口文件中的memeber/phpssoconfig.php文件，修改define(‘APPID’, 2);中的2为上一步中查看的应用ID号,修改$ps_api_url的地址为phpsso的web地址，修改$ps_auth_key为上一步中自动生成的通信密钥。 phpssoconfig.php文件中无中文，如果加入中文，需要保存格式为utf-8无bom编码，不加中文可以使用记事本编辑，加入中文就不能使用记事本编辑，可以使用Notepad++编辑。 保存后把member和module两个目录复制到destoon根目录覆盖。接口文件的member目录中的三个文件是新增的，module\\member目录的文件是修改的destoon文件，作用是destoon登录或退出和phpcms v9同步。你可以事先对destoon的module\\member中的相应的文件进行备份。 覆盖文件后，进入phpcms v9的应用管理，通信状态应该为通信成功。不成功请检查上面的步骤。","text":"DESTOON B2B是一套基于PHP+MySQL的开源B2B电子商务行业门户网站解决方案。官方网站为http://www.destoon.com，下载，演示及使用请查看官方网站。实际就是仿阿里巴巴的php系统。—本接口提供时destoon版本为 最新版本：V4.0 更新时间：2012-04-28 phpcms如何整合destoon？destoon如何整合phpcms呢？本文就会介绍具体方法和提供接口文件! 至于为什么phpcms需要整合destoon,因为phpcms的黄页功能不全，destoon功能全！ 主域名为www.bnwin.com destoon域名为b2b.bnwin.com均采用utf-8编码,phpcms v9域名和destoon域名应同属不同的子域名，不能采用不用的域名!因为cookie不允许跨域! 1.在phpcms v9后台的phpsso中添加应用应用名:destoonB2B应用地址:http://b2b.bnwin.com/member/通信密钥:(点击自动生成)类型:其他应用IP：(保持为空)通信文件：phpsso.php字符集:utf-8同步登录:是 添加应用后，查看应用ID号，并且复制自动生成的 通信密钥 2.打开接口文件中的memeber/phpssoconfig.php文件，修改define(‘APPID’, 2);中的2为上一步中查看的应用ID号,修改$ps_api_url的地址为phpsso的web地址，修改$ps_auth_key为上一步中自动生成的通信密钥。 phpssoconfig.php文件中无中文，如果加入中文，需要保存格式为utf-8无bom编码，不加中文可以使用记事本编辑，加入中文就不能使用记事本编辑，可以使用Notepad++编辑。 保存后把member和module两个目录复制到destoon根目录覆盖。接口文件的member目录中的三个文件是新增的，module\\member目录的文件是修改的destoon文件，作用是destoon登录或退出和phpcms v9同步。你可以事先对destoon的module\\member中的相应的文件进行备份。 覆盖文件后，进入phpcms v9的应用管理，通信状态应该为通信成功。不成功请检查上面的步骤。 3.修改destoon的destoon_member表(安装时采用的默认前缀destoon)，添加字段phpssouid 类型bigint 长度20 小数点0 不允许空值，默认值为0 接口文件phpcms v9和destoon双向同步登录，同步退出，注册以phpcms v9为注册口，注册后自动同步到destoon。由于两个系统对密码的加密不一致，在destoon注册也能同步到phpcms v9，但在destoon注册的用户就达不到同步登录和登录退出，因为密码加密不致。这也是一些系统整合后，需要激活的原因。本接口不需要激活过程，但不能双向注册。 建议去掉直接在destoon注册，因为destoon注册的密码不能直接保存在phpcms v9中，会出现以phpcmsv9登录时，不能同步登录destoon，去掉destoon同步注册修改方法为：把member目录下的register.php文件内容改为(把www.bnwin.com改为你自己的域名siteid的值改为你的站点的id) 因为整合的目的，是让用户认为全部系统是完美结合在一起的一个系统。所以建议，用户注册，用户登录，用户修改，用户退出全部系统都指向相同的文件。 接口文件及整合视频下载地址:链接: https://pan.baidu.com/s/1bpJFPVL 密码: uq4d","categories":[{"name":"源码","slug":"code","permalink":"https://goodhelp.gitee.io/categories/code/"}],"tags":[{"name":"php源码","slug":"php源码","permalink":"https://goodhelp.gitee.io/tags/php%E6%BA%90%E7%A0%81/"}]},{"title":"“春宵一刻值千金”古代的优美情诗","slug":"other/“春宵一刻值千金”古代的优美情诗","date":"2017-10-30T15:11:10.000Z","updated":"2021-09-16T23:48:40.644Z","comments":true,"path":"page/2134220563/","link":"","permalink":"https://goodhelp.gitee.io/page/2134220563/","excerpt":"——《江城子》 苏轼十年生死两茫茫，不思量，自难忘。千里孤坟，无处话凄凉。纵使相逢应不识，尘满面，鬓如霜。夜来幽梦忽还乡，小轩窗，正梳妆。相顾无言，惟有泪千行。料得年年肠断处，明月夜，短松冈。 ——纳兰性德《木兰词·拟古决绝词柬友》 人生若只如初见，何事秋风悲画扇； 等闲变却故人心，却道故人心易变。 骊山语罢清宵半，泪雨霖铃终不怨； 何如薄幸锦衣郎，比翼连枝当日愿。 ——《花月痕》 多情自古空余恨，好梦由来最易醒。 岂是拈花难解脱，可怜飞絮太飘零。 ——元稹《遣悲怀•其二》","text":"——《江城子》 苏轼十年生死两茫茫，不思量，自难忘。千里孤坟，无处话凄凉。纵使相逢应不识，尘满面，鬓如霜。夜来幽梦忽还乡，小轩窗，正梳妆。相顾无言，惟有泪千行。料得年年肠断处，明月夜，短松冈。 ——纳兰性德《木兰词·拟古决绝词柬友》 人生若只如初见，何事秋风悲画扇； 等闲变却故人心，却道故人心易变。 骊山语罢清宵半，泪雨霖铃终不怨； 何如薄幸锦衣郎，比翼连枝当日愿。 ——《花月痕》 多情自古空余恨，好梦由来最易醒。 岂是拈花难解脱，可怜飞絮太飘零。 ——元稹《遣悲怀•其二》 昔日戏言身后事，今朝都到眼前来。 衣裳已施行看尽，针线犹存未忍开。 尚想旧情怜婢仆，也曾因梦送钱财。 诚知此恨人人有，贫贱夫妻百事哀。 ——黄増《集杭州俗语诗》 色不迷人人自迷，情人眼里出西施。 有缘千里来相会，三笑徒然当一痴。 ——李贺《金铜仙人辞汉歌》 茂陵刘郎秋风客，夜闻马嘶晓无迹。 画栏桂树悬秋香，三十六宫土花碧。 魏官牵车指千里，东关酸风射眸子。 空将汉月出宫门，忆君清泪如铅水。 衰兰送客咸阳道，天若有情天亦老。 携盘独出月荒凉，渭城已远波声小。 ——杜甫《前出塞·其六》 挽弓当挽强，用箭当用长。 射人先射马，擒贼先擒王。 杀人亦有限，列国自有疆。 苟能制侵陵，岂在多杀伤。 ——黄景仁《杂感》 仙佛茫茫两未成，只知独夜不平鸣。 风蓬飘尽悲歌气，泥絮沾来薄幸名。 十有九人堪白眼，百无一用是书生。 莫因诗卷愁成谶，春鸟秋虫自作声。 ——龚自珍《夜作》 沉沉心事北南东，一睨人材海内空。 壮岁始参周史席，髫年惜堕晋贤风。 功高拜将成仙外，才尽回肠荡气中。 万一禅关砉然破，美人如玉剑如虹。 ——罗隐《自遣》 得即高歌失即休，多愁多恨亦悠悠。 今朝有酒今朝醉，明日愁来明日愁。 ——夏元鼎《绝句》 崆峒访道至湘湖，万卷诗书看转愚。 踏破铁鞋无觅处，得来全不费工夫。 ——苏轼《戏张先》 十八新娘八十郎，苍苍白发对红妆。 鸳鸯被里成双夜，一树梨花压海棠。 ——黄蘖禅师《上堂开示颂》 尘劳回脱事非常，紧把绳头做一场。 不经一番寒彻骨，那得梅花扑鼻香。 ——陈于之《题桃花扇》 玉树歌残声已陈，南朝宫殿柳条新； 福王少小风流惯，不爱江山爱美人。 ——俞文豹《清夜录》 近水楼台先得月，向阳花木易为春。 ——苏轼《蝶恋花·春景》 花褪残红青杏小。燕子飞时，绿水人家绕。 枝上柳绵吹又少。天涯何处无芳草。 墙里秋千墙外道。墙外行人，墙里佳人笑。 笑渐不闻声渐悄，多情却被无情恼。 ——白居易《长恨歌》 临别殷勤重寄词，词中有誓两心知。 七月七日长生殿，夜半无人私语时。 在天愿作比翼鸟，在地愿为连理枝。 天长地久有时尽，此恨绵绵无绝期。 ——曹松《己亥岁》 泽国江山入战图，生民何计乐樵苏。 凭君莫话封侯事，一将功成万骨枯。 ——苏轼《春宵》 春宵一刻值千金，花有清香月有阴。 歌管楼台声细细，秋千院落夜沉沉。","categories":[{"name":"其他","slug":"其他","permalink":"https://goodhelp.gitee.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"文章","slug":"文章","permalink":"https://goodhelp.gitee.io/tags/%E6%96%87%E7%AB%A0/"},{"name":"情诗","slug":"情诗","permalink":"https://goodhelp.gitee.io/tags/%E6%83%85%E8%AF%97/"}]},{"title":"ikeeper爱克吧去广告方法","slug":"article/ikeeper爱克吧去广告方法","date":"2017-10-26T15:04:51.000Z","updated":"2021-09-16T23:39:32.026Z","comments":true,"path":"page/2202525941/","link":"","permalink":"https://goodhelp.gitee.io/page/2202525941/","excerpt":"ikeeper爱克吧为网吧实名管理系统 官网http://www.echina110.com如何去掉ikeeper爱克吧的桌面广告呢？这儿介绍两种方种，虽然ikeeper爱克吧已经开始下线，开始使用ikeeper 8圈管理系统，在这儿仍然记录一下如何去掉ikeeper爱克吧广告的方法，至于ikeeper 8圈去广告方法，后续我们会放上相应的文章，8圈去广告已经没有爱克吧简单了!方法一自定义广告使用说明 爱克吧的广告地址为 http://activedesktop.echina110.com/advertises/desktopx.asp?id=5001030050 desktopx.asp的内容为: Http://你的站点的IP/advertises/adv/ad.cab 123 只要把activedesktop.echina110.com域名屏蔽，就可以去广告，只要把这个域名重定向，然后自定义cab的内容就可以显示自定义的广告!至于怎么屏蔽，可以使用路由器中的域名过滤和重定向就ＯＫ了。 其中desktopx.asp的内容说明如下：第一项指向你的站点中的ad.cab（文件可以为任何，但必须是cab压缩包，不能是zip或rar或7z等其他压缩包，制作cab压缩包，可以使用xp自带的IEXPRESS.EXE) 路径不一定是在advertises/adv可以改为其他路径,但该路径下必须有ad.cab,这个文件名不能变 其后的123可以为任意数字! 同时请注意desktopx.asp的路径不能变,只能在http://你的站点IP/advertises/desktopx.asp确保打开此 asp页面在浏览器中返回的应该为Http://你的ad.cab路径/ad.cab 123","text":"ikeeper爱克吧为网吧实名管理系统 官网http://www.echina110.com如何去掉ikeeper爱克吧的桌面广告呢？这儿介绍两种方种，虽然ikeeper爱克吧已经开始下线，开始使用ikeeper 8圈管理系统，在这儿仍然记录一下如何去掉ikeeper爱克吧广告的方法，至于ikeeper 8圈去广告方法，后续我们会放上相应的文章，8圈去广告已经没有爱克吧简单了!方法一自定义广告使用说明 爱克吧的广告地址为 http://activedesktop.echina110.com/advertises/desktopx.asp?id=5001030050 desktopx.asp的内容为: Http://你的站点的IP/advertises/adv/ad.cab 123 只要把activedesktop.echina110.com域名屏蔽，就可以去广告，只要把这个域名重定向，然后自定义cab的内容就可以显示自定义的广告!至于怎么屏蔽，可以使用路由器中的域名过滤和重定向就ＯＫ了。 其中desktopx.asp的内容说明如下：第一项指向你的站点中的ad.cab（文件可以为任何，但必须是cab压缩包，不能是zip或rar或7z等其他压缩包，制作cab压缩包，可以使用xp自带的IEXPRESS.EXE) 路径不一定是在advertises/adv可以改为其他路径,但该路径下必须有ad.cab,这个文件名不能变 其后的123可以为任意数字! 同时请注意desktopx.asp的路径不能变,只能在http://你的站点IP/advertises/desktopx.asp确保打开此 asp页面在浏览器中返回的应该为Http://你的ad.cab路径/ad.cab 123 方法二 1.用UltraEdit等编辑二进制工具打开C:\\Program Files (x86)\\Client\\entry.exe(如果是xp是C:\\Program Files\\Client\\entry.exe)，点击编辑中查找.lib。2.把.lib修改为.sib或其他的字符（其实就是修改cab广告包中的可执行文件的数据扩展名，修改后ikeeper爱克吧就不会执行cab广告包中广告文件，客户机也就不会有随机文件运行了，但桌面锁屏广告是存在的，其实去广告的最终目的是不能让广告影响到客户机性能或影响到用户的体验！）","categories":[{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"}],"tags":[{"name":"去广告方法","slug":"去广告方法","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%BB%E5%B9%BF%E5%91%8A%E6%96%B9%E6%B3%95/"}]},{"title":"关闭8圈桌面侧边栏工具","slug":"soft/关闭8圈桌面侧边栏工具","date":"2017-10-26T13:31:46.000Z","updated":"2021-09-12T00:09:23.039Z","comments":true,"path":"page/3211467574/","link":"","permalink":"https://goodhelp.gitee.io/page/3211467574/","excerpt":"关闭8圈桌面侧边栏工具-适用于八圈9.5以下版本此页面工具仅适用于八圈9.5以下版本，不适用于八圈9.5及以上版本，9.5版本请查看本站其他页面 8圈网管平台(8圈计费系统)是专门针对新型网吧网咖会所开发的一款全新网管服务软件!官方网站:http://www.8quan.com 网吧计费系统8圈，会在桌面右侧显示一个窗口，无法修改，无法控制是否显示！如何关闭8圈计费系统桌面上的窗口呢？本工具可以自由控制显示或隐藏，或销毁，还你桌面一个自由!本程序可以加参数运行 加 1 隐藏 加 0 显示 加 2 销毁 销毁就是彻底关闭，窗体是不存在了，隐藏只是不显示出来，实际是存在的! 如何添加参数，请参照这儿 https://goodhelp.gitee.io/page/576111441/ 下载地址： 关闭八圈9.5版工具下载地址 https://goodhelp.gitee.io/page/3043345977/","text":"关闭8圈桌面侧边栏工具-适用于八圈9.5以下版本此页面工具仅适用于八圈9.5以下版本，不适用于八圈9.5及以上版本，9.5版本请查看本站其他页面 8圈网管平台(8圈计费系统)是专门针对新型网吧网咖会所开发的一款全新网管服务软件!官方网站:http://www.8quan.com 网吧计费系统8圈，会在桌面右侧显示一个窗口，无法修改，无法控制是否显示！如何关闭8圈计费系统桌面上的窗口呢？本工具可以自由控制显示或隐藏，或销毁，还你桌面一个自由!本程序可以加参数运行 加 1 隐藏 加 0 显示 加 2 销毁 销毁就是彻底关闭，窗体是不存在了，隐藏只是不显示出来，实际是存在的! 如何添加参数，请参照这儿 https://goodhelp.gitee.io/page/576111441/ 下载地址： 关闭八圈9.5版工具下载地址 https://goodhelp.gitee.io/page/3043345977/ 此版本只适用于八圈9.5以下 V0.33版本 链接: https://pan.baidu.com/s/1gbsO1id1CM3obMiGRVUXNw 提取码: 5qyk V0.32版本 链接: https://pan.baidu.com/s/1Im3iRntYOLnMgg-9yfM_MQ 提取码: aaax V0.31版本 链接：https://pan.baidu.com/s/1kVSqDtd 密码：nxxq V0.3版本 链接: https://pan.baidu.com/s/1kV7WTMZ 密码: 3m1t 解压密码 bnwin.com 2018 09-22 V0.33修改判断8圈侧边栏是否存在的方法，更具有通用性! 2018 09-21 V0.32修改了9.4.4.15022版本发现不了侧边栏的问题，新版隐藏方式三即参数5 经测是可以使用在9.4.4.15510版本上的 2018 01-03 V0.31使用命令行参数运行时，在没有发现8圈侧边栏时，会一直等待，8圈侧边栏出现，隐藏后，本程序自动退出!这样就可以开机直接运行本工具，而不用怕本工具启动时8圈侧边栏没出来，而隐藏不了侧边栏的问题! 运动方式 直接运行，手工操作界面参数运行0 旧版显示8圈侧边栏1 旧版关闭8圈侧边栏2 旧版销毁8圈侧边栏3 新版隐藏方式一4 新版隐藏方式二5 新版隐藏方式三(适用于9.4.4版本) 自己先手工测试哪种方式能用，就选择哪种方式！旧版指8圈9.4.3以前，新版指8圈9.4.3及以后版本 什么是运行参数？比如解压文件c8.exe在C盘根目录，那么直接运行命令就是c:\\c8.exe参数运行就是这样c:\\c8.exe 5后面的数字5就是参数，参数和前面的执行程序之前加一个空格，如果你的执行程序解压到有空格的目录，那么前面的运行程序要加引号如“c:\\空格 目录\\c8.exe” 5 控制的就是桌面这一块当前版本V0.32 查看8圈相关软件 独立的8圈挂机锁 https://goodhelp.gitee.io/page/576111441/ 如果你觉得关闭8圈侧边栏对你的操作系统稳定性有影响，你可以查看自定义8圈桌面侧边栏的软件http://www.bnwin.com/page/1077583104/","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"八圈","slug":"八圈","permalink":"https://goodhelp.gitee.io/tags/%E5%85%AB%E5%9C%88/"},{"name":"原创软件","slug":"原创软件","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%9F%E5%88%9B%E8%BD%AF%E4%BB%B6/"}]},{"title":"中止非驱动保护进程的工具","slug":"soft/中止非驱动保护进程的工具","date":"2017-10-26T13:28:36.000Z","updated":"2021-09-12T00:16:32.445Z","comments":true,"path":"page/1213995227/","link":"","permalink":"https://goodhelp.gitee.io/page/1213995227/","excerpt":"本程序可以中止非驱动保护（驱动保护的进程无法结束）的绝大部份进程,对于一些广告进程无法通过任务管理器结束的，本工具可以结束，以及删除一些非驱动保护的文件。本程序设置好配置文件后运行就可以自动结束，完全自动化! 需要中止的进程和删除的文件以及需要隐藏的文件添加到setup.ini中，格式如下 [中止进程];结束任务管理器中无法结束的进程;名称=进程的完整路径wwbizsrv=C:\\Program Files (x86)\\Alibaba\\wwbizsrv\\wwbizsrv.exe [删除文件];删除普通无法删除的文件;名称=文件完整路径删无权限文件=C:\\Users\\Administrator\\Desktop\\删无权限文件.txt [隐藏文件];不删除，仅隐藏文件;名称=文件完整路径1=C:\\Users\\Administrator\\Desktop\\0.url本程序运行会自动结束setup.ini配置中的进程，结束后自动退出程序，无运行界面!可以先用任务管理器试一下无法结束的进程，然后把此进程配置在setup.ini，即可结束，可以测试csrss.exe或winlogin.exe，不过结束这些系统核心进程会蓝屏! 中止任务管理器无法中止的进程 删除普通无法删除的文件 删除没有权限的文件 下载地址： 链接: https://pan.baidu.com/s/1OY8tgGx5D8puJ8mPHAgjkw 提取码: vrjx 复制这段内容后打开百度网盘手机App，操作更方便哦","text":"本程序可以中止非驱动保护（驱动保护的进程无法结束）的绝大部份进程,对于一些广告进程无法通过任务管理器结束的，本工具可以结束，以及删除一些非驱动保护的文件。本程序设置好配置文件后运行就可以自动结束，完全自动化! 需要中止的进程和删除的文件以及需要隐藏的文件添加到setup.ini中，格式如下 [中止进程];结束任务管理器中无法结束的进程;名称=进程的完整路径wwbizsrv=C:\\Program Files (x86)\\Alibaba\\wwbizsrv\\wwbizsrv.exe [删除文件];删除普通无法删除的文件;名称=文件完整路径删无权限文件=C:\\Users\\Administrator\\Desktop\\删无权限文件.txt [隐藏文件];不删除，仅隐藏文件;名称=文件完整路径1=C:\\Users\\Administrator\\Desktop\\0.url本程序运行会自动结束setup.ini配置中的进程，结束后自动退出程序，无运行界面!可以先用任务管理器试一下无法结束的进程，然后把此进程配置在setup.ini，即可结束，可以测试csrss.exe或winlogin.exe，不过结束这些系统核心进程会蓝屏! 中止任务管理器无法中止的进程 删除普通无法删除的文件 删除没有权限的文件 下载地址： 链接: https://pan.baidu.com/s/1OY8tgGx5D8puJ8mPHAgjkw 提取码: vrjx 复制这段内容后打开百度网盘手机App，操作更方便哦","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"八圈","slug":"八圈","permalink":"https://goodhelp.gitee.io/tags/%E5%85%AB%E5%9C%88/"},{"name":"原创软件","slug":"原创软件","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%9F%E5%88%9B%E8%BD%AF%E4%BB%B6/"}]},{"title":"根据标题关键字禁止窗口的工具","slug":"soft/根据标题关键字禁止窗口的工具","date":"2017-10-26T13:27:27.000Z","updated":"2021-09-11T16:45:37.854Z","comments":true,"path":"page/3617424847/","link":"","permalink":"https://goodhelp.gitee.io/page/3617424847/","excerpt":"很多维护工具中都带有这个功能，本工具就是单一的功能，根据设置的关键字，自动关闭窗口，也许有些地方只需要这单一功能，比如给家里的孩子电脑中安装这个工具反黄! 下载地址 链接: https://pan.baidu.com/s/1i5rISLJ 密码: wad7","text":"很多维护工具中都带有这个功能，本工具就是单一的功能，根据设置的关键字，自动关闭窗口，也许有些地方只需要这单一功能，比如给家里的孩子电脑中安装这个工具反黄! 下载地址 链接: https://pan.baidu.com/s/1i5rISLJ 密码: wad7","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"原创软件","slug":"原创软件","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%9F%E5%88%9B%E8%BD%AF%E4%BB%B6/"}]},{"title":"显示器亮度调节工具","slug":"soft/显示器亮度调节工具","date":"2017-10-26T13:24:29.000Z","updated":"2021-09-11T16:44:44.663Z","comments":true,"path":"page/1271703987/","link":"","permalink":"https://goodhelp.gitee.io/page/1271703987/","excerpt":"显示器亮度调节工具，虽然有其他的，但我写的这个软件，包括显示器亮度调节，声音调节，鼠标调节和自定义程序启动，也许可以为你带来方便!看看效果 下载地址 链接: https://pan.baidu.com/s/1nuUAioT 密码: 1mx2","text":"显示器亮度调节工具，虽然有其他的，但我写的这个软件，包括显示器亮度调节，声音调节，鼠标调节和自定义程序启动，也许可以为你带来方便!看看效果 下载地址 链接: https://pan.baidu.com/s/1nuUAioT 密码: 1mx2","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"原创软件","slug":"原创软件","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%9F%E5%88%9B%E8%BD%AF%E4%BB%B6/"}]},{"title":"简单的聊天菜单","slug":"soft/简单的聊天菜单","date":"2017-10-26T13:20:45.000Z","updated":"2021-09-11T16:45:30.800Z","comments":true,"path":"page/2499358455/","link":"","permalink":"https://goodhelp.gitee.io/page/2499358455/","excerpt":"这是一个分类菜单，比如显示聊天菜单等几个程序的工具，此菜单可以定义命令行参数 第一个参数是每一行显示几个图标第二个参数是标题名称第三个参数是配置文件名第四个参数是背景图片 比如参数写为 4 办公软件 bgmenu.ini skin.jpg 那么这表示使用bgmenu.ini配置文件，skin.jpg做为背景图片，每行显示4个图标，标题为 办公软件 的菜单 效果看一下，仿QQ界面，是很漂亮的 下载地址： 链接: https://pan.baidu.com/s/1bY8gEHz2-k2I7DskKW1eJQ 提取码: yrtq 复制这段内容后打开百度网盘手机App，操作更方便哦","text":"这是一个分类菜单，比如显示聊天菜单等几个程序的工具，此菜单可以定义命令行参数 第一个参数是每一行显示几个图标第二个参数是标题名称第三个参数是配置文件名第四个参数是背景图片 比如参数写为 4 办公软件 bgmenu.ini skin.jpg 那么这表示使用bgmenu.ini配置文件，skin.jpg做为背景图片，每行显示4个图标，标题为 办公软件 的菜单 效果看一下，仿QQ界面，是很漂亮的 下载地址： 链接: https://pan.baidu.com/s/1bY8gEHz2-k2I7DskKW1eJQ 提取码: yrtq 复制这段内容后打开百度网盘手机App，操作更方便哦","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"原创软件","slug":"原创软件","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%9F%E5%88%9B%E8%BD%AF%E4%BB%B6/"}]},{"title":"锐起CGO2043服务端出盘源码","slug":"code/锐起CGO2043服务端出盘源码","date":"2017-10-26T04:20:26.000Z","updated":"2021-09-16T23:55:57.331Z","comments":true,"path":"page/2734958200/","link":"","permalink":"https://goodhelp.gitee.io/page/2734958200/","excerpt":"曾经的锐起CGO2043是以IMG包的形式存放游戏的，但服务端又不能自动出盘进行更新，当时就写了这个工具，开机可以自动开IMG包，达到自动更新游戏的目的!源码为delphi，如果需要的可以下载! 下载地址 链接: https://pan.baidu.com/s/1nuNi8hr 密码: r7g6 解压密码 bnwin.com 其中部份源码 12345678910111213141516171819202122232425262728s3:^Integer; begin GSGW32_LoadDriver; s1:=dname; s2:=(dsize*1024)*1024; s2:=s2*1024; asm lea eax,s2; mov edx,s1; mov al,[edx]; mov s3,eax; end; GSGW32_Mount(sn,s3,@s2,PChar(dimg)); end;function TService1.diskgo(diskname:string):Boolean; var d2:string; n,i:Integer; begin d2:=UpperCase(Trim(diskname)); for i:=1 to Length(d2) do begin n:=Ord(d2[i]); GSGW32_Umount(n); end; GSGW32_UnloadDriver; end;","text":"曾经的锐起CGO2043是以IMG包的形式存放游戏的，但服务端又不能自动出盘进行更新，当时就写了这个工具，开机可以自动开IMG包，达到自动更新游戏的目的!源码为delphi，如果需要的可以下载! 下载地址 链接: https://pan.baidu.com/s/1nuNi8hr 密码: r7g6 解压密码 bnwin.com 其中部份源码 12345678910111213141516171819202122232425262728s3:^Integer; begin GSGW32_LoadDriver; s1:=dname; s2:=(dsize*1024)*1024; s2:=s2*1024; asm lea eax,s2; mov edx,s1; mov al,[edx]; mov s3,eax; end; GSGW32_Mount(sn,s3,@s2,PChar(dimg)); end;function TService1.diskgo(diskname:string):Boolean; var d2:string; n,i:Integer; begin d2:=UpperCase(Trim(diskname)); for i:=1 to Length(d2) do begin n:=Ord(d2[i]); GSGW32_Umount(n); end; GSGW32_UnloadDriver; end;","categories":[{"name":"源码","slug":"code","permalink":"https://goodhelp.gitee.io/categories/code/"}],"tags":[{"name":"delphi源码","slug":"delphi源码","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%BA%90%E7%A0%81/"},{"name":"锐起使用方法","slug":"锐起使用方法","permalink":"https://goodhelp.gitee.io/tags/%E9%94%90%E8%B5%B7%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"}]},{"title":"370safe安全管理软件","slug":"soft/370safe安全管理软件","date":"2017-10-26T03:45:40.000Z","updated":"2021-09-16T23:53:33.537Z","comments":true,"path":"page/278292559/","link":"","permalink":"https://goodhelp.gitee.io/page/278292559/","excerpt":"网吧经常出现很多人投诉网吧，老是自动弹出广告，以前还只是游戏结束自动弹出游戏网页，现在直接小窗口带声音了。打开网页多了还要慢慢找。我想知道怎么屏蔽这一类的广告，因为现在已经有很多人投诉了，但是我们上面的合作公司竟然无力解决! 进程里面结束网吧系统的游戏管理软件就不会出现广告！网吧为了管理游戏方便，不可避免的需要这种管理软件，所以广告不可避免，这也是网吧系统管理方赚钱的一种手段。 这就是现在网吧广告的现状，网吧现在绝大部份采用无盘系统，无盘系统比如网维大师等，会不断投放广告，网吧采用实名制系统，比如pubwin等公安实名制系统，也会不断投放广告，文化监管软件，比如任子行等，也会不断投放广告!网吧使用的营销软件，比如网吧营销大师、领航等，同时会不断投放广告,只要看到网吧市场的，都会投放广告，广告这么多，网吧客户机不成了垃圾系统了吗？拖慢系统，游戏中弹出桌面，烦人的弹窗，还有烦人的挖矿，不断的消耗客户机软硬件资源，网吧体验怎么办？370safe等类软件应运而生，还你网吧桌面自由！ 370Safe只是个安全防御工具, 提供防御功能, 不提供任何内置规则 . 在默认情况下, 软件安装后 , 不会拦截任何软件的任何操作.用户应合理,合法,灵活使用软件提供的一切功能 . 因用户自行配置的规则导致的一切问题,用户自行承担相应的责任.用户应仅将本工具用于防御病毒木马,不得破坏其他软件正常功能. 370服务端运行界面此下载地址包括370safe 2.0内网版和以前的370safe 1.02版 370safe 1.03版升级补丁等! 370safe 2.0内网版及1.02 1.03下载地址 链接: https://pan.baidu.com/s/1i4QE2TR 密码: 6jvb","text":"网吧经常出现很多人投诉网吧，老是自动弹出广告，以前还只是游戏结束自动弹出游戏网页，现在直接小窗口带声音了。打开网页多了还要慢慢找。我想知道怎么屏蔽这一类的广告，因为现在已经有很多人投诉了，但是我们上面的合作公司竟然无力解决! 进程里面结束网吧系统的游戏管理软件就不会出现广告！网吧为了管理游戏方便，不可避免的需要这种管理软件，所以广告不可避免，这也是网吧系统管理方赚钱的一种手段。 这就是现在网吧广告的现状，网吧现在绝大部份采用无盘系统，无盘系统比如网维大师等，会不断投放广告，网吧采用实名制系统，比如pubwin等公安实名制系统，也会不断投放广告，文化监管软件，比如任子行等，也会不断投放广告!网吧使用的营销软件，比如网吧营销大师、领航等，同时会不断投放广告,只要看到网吧市场的，都会投放广告，广告这么多，网吧客户机不成了垃圾系统了吗？拖慢系统，游戏中弹出桌面，烦人的弹窗，还有烦人的挖矿，不断的消耗客户机软硬件资源，网吧体验怎么办？370safe等类软件应运而生，还你网吧桌面自由！ 370Safe只是个安全防御工具, 提供防御功能, 不提供任何内置规则 . 在默认情况下, 软件安装后 , 不会拦截任何软件的任何操作.用户应合理,合法,灵活使用软件提供的一切功能 . 因用户自行配置的规则导致的一切问题,用户自行承担相应的责任.用户应仅将本工具用于防御病毒木马,不得破坏其他软件正常功能. 370服务端运行界面此下载地址包括370safe 2.0内网版和以前的370safe 1.02版 370safe 1.03版升级补丁等! 370safe 2.0内网版及1.02 1.03下载地址 链接: https://pan.baidu.com/s/1i4QE2TR 密码: 6jvb","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"去广告方法","slug":"去广告方法","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%BB%E5%B9%BF%E5%91%8A%E6%96%B9%E6%B3%95/"},{"name":"精品软件","slug":"精品软件","permalink":"https://goodhelp.gitee.io/tags/%E7%B2%BE%E5%93%81%E8%BD%AF%E4%BB%B6/"}]},{"title":"锐起CGO2043客户端绿色出盘源码","slug":"code/锐起CGO2043客户端绿色出盘源码","date":"2017-10-26T01:37:00.000Z","updated":"2021-09-16T23:55:51.507Z","comments":true,"path":"page/589247647/","link":"","permalink":"https://goodhelp.gitee.io/page/589247647/","excerpt":"锐起CGO2043客户端绿色出盘源码,可以在服务端查看到客户端的状态 源码为delphi,如果需要源码可以下载 下载地址链接: https://pan.baidu.com/s/1i5gn1i9 密码: nnhu 解压密码 bnwin.com 其中部份源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172MutexHandle: Longword; mainip,subip,mystr,syspath:string; reg:TRegistry; thand:THandle; RTGSGLogonEvent:TPluginName; myini:TIniFile; myname,cgoip:string; begin syspath:=gtsyspath; if not fileexists(syspath+&#x27;\\system32\\drivers\\GAMESGXP.sys&#x27;) then begin ExtractRes(&#x27;exefile&#x27;,&#x27;RNDINTER&#x27;,syspath+&#x27;\\system32\\RNDINTER.dll&#x27;); ExtractRes(&#x27;exefile&#x27;,&#x27;RTGSGENG&#x27;,syspath+&#x27;\\system32\\RTGSGENG.dll&#x27;); ExtractRes(&#x27;exefile&#x27;,&#x27;udt&#x27;,syspath+&#x27;\\system32\\udt.dll&#x27;); ExtractRes(&#x27;exefile&#x27;,&#x27;GAMESGXP&#x27;,syspath+&#x27;\\system32\\drivers\\GAMESGXP.sys&#x27;); ExtractRes(&#x27;exefile&#x27;,&#x27;RTFLTDSK&#x27;,syspath+&#x27;\\system32\\drivers\\RTFLTDSK.sys&#x27;); ExtractRes(&#x27;exefile&#x27;,&#x27;RTWRESXP&#x27;,syspath+&#x27;\\system32\\drivers\\RTWRESXP.sys&#x27;); end; myini:=TIniFile.Create(ExtractFilePath(ParamStr(0))+&#x27;setup.ini&#x27;); mainip:= myini.ReadString(&#x27;配置&#x27;,&#x27;主服务器&#x27;,&#x27;&#x27;);//主服务器IP subip:= myini.ReadString(&#x27;配置&#x27;,&#x27;副服务器&#x27;,&#x27;&#x27;);//副服务器IP if subip=&#x27;&#x27; then subip:=mainip; mystr:= uppercase(myini.ReadString(&#x27;配置&#x27;,&#x27;副分流机器&#x27;,&#x27;&#x27;));//副服务器分流机器名 myini.Free; myname:=gtcomputername; if Pos(myname,mystr)&gt;0 then begin if ScanTCPPort(subip,7499) then cgoip:=subip else cgoip:=mainip; end else begin if ScanTCPPort(mainip,7499) then cgoip:=mainip else begin if ScanTCPPort(subip,7499) then cgoip:=subip else cgoip:=mainip; end; end; if cgoip&lt;&gt;&#x27;&#x27; then begin reg:=TRegistry.Create; reg.RootKey:=HKEY_LOCAL_MACHINE; if reg.OpenKey(&#x27;SOFTWARE\\Richtech\\Cgo&#x27;,true) then begin reg.WriteInteger(&#x27;Version&#x27;,$000007fb); reg.WriteString(&#x27;ServerIp&#x27;,cgoip); reg.WriteInteger(&#x27;NormalSD&#x27;,1); reg.WriteInteger(&#x27;UserId&#x27;,5821298); reg.WriteInteger(&#x27;KeyId&#x27;,0); reg.WriteInteger(&#x27;RegDrive&#x27;,81); end; reg.CloseKey; reg.Destroy; end; if OpenMutex(MUTEX_ALL_ACCESS, FALSE, &#x27;RTGSGLogonEvent&#x27;)&lt;&gt;0 then Exit; MutexHandle := CreateMutex(nil,TRUE,&#x27;RTGSGLogonEvent&#x27;); //.........BEGIN........////寻找进程 Explorer_PID := FindProcess(&#x27;winlogon.exe&#x27;); if (Explorer_PID=0) then begin MessageBox(0, &#x27;寻找winlogon进程出错 &#x27;, nil, 0); Exit; end; //创建内存映射文件 FileMapH := CreateFileMapping($FFFFFFFF,nil,PAGE_READWRITE,0,SizeOf(node),&#x27;RTGSGLogonEventRich&#x27;); if (FileMapH=0) then begin","text":"锐起CGO2043客户端绿色出盘源码,可以在服务端查看到客户端的状态 源码为delphi,如果需要源码可以下载 下载地址链接: https://pan.baidu.com/s/1i5gn1i9 密码: nnhu 解压密码 bnwin.com 其中部份源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172MutexHandle: Longword; mainip,subip,mystr,syspath:string; reg:TRegistry; thand:THandle; RTGSGLogonEvent:TPluginName; myini:TIniFile; myname,cgoip:string; begin syspath:=gtsyspath; if not fileexists(syspath+&#x27;\\system32\\drivers\\GAMESGXP.sys&#x27;) then begin ExtractRes(&#x27;exefile&#x27;,&#x27;RNDINTER&#x27;,syspath+&#x27;\\system32\\RNDINTER.dll&#x27;); ExtractRes(&#x27;exefile&#x27;,&#x27;RTGSGENG&#x27;,syspath+&#x27;\\system32\\RTGSGENG.dll&#x27;); ExtractRes(&#x27;exefile&#x27;,&#x27;udt&#x27;,syspath+&#x27;\\system32\\udt.dll&#x27;); ExtractRes(&#x27;exefile&#x27;,&#x27;GAMESGXP&#x27;,syspath+&#x27;\\system32\\drivers\\GAMESGXP.sys&#x27;); ExtractRes(&#x27;exefile&#x27;,&#x27;RTFLTDSK&#x27;,syspath+&#x27;\\system32\\drivers\\RTFLTDSK.sys&#x27;); ExtractRes(&#x27;exefile&#x27;,&#x27;RTWRESXP&#x27;,syspath+&#x27;\\system32\\drivers\\RTWRESXP.sys&#x27;); end; myini:=TIniFile.Create(ExtractFilePath(ParamStr(0))+&#x27;setup.ini&#x27;); mainip:= myini.ReadString(&#x27;配置&#x27;,&#x27;主服务器&#x27;,&#x27;&#x27;);//主服务器IP subip:= myini.ReadString(&#x27;配置&#x27;,&#x27;副服务器&#x27;,&#x27;&#x27;);//副服务器IP if subip=&#x27;&#x27; then subip:=mainip; mystr:= uppercase(myini.ReadString(&#x27;配置&#x27;,&#x27;副分流机器&#x27;,&#x27;&#x27;));//副服务器分流机器名 myini.Free; myname:=gtcomputername; if Pos(myname,mystr)&gt;0 then begin if ScanTCPPort(subip,7499) then cgoip:=subip else cgoip:=mainip; end else begin if ScanTCPPort(mainip,7499) then cgoip:=mainip else begin if ScanTCPPort(subip,7499) then cgoip:=subip else cgoip:=mainip; end; end; if cgoip&lt;&gt;&#x27;&#x27; then begin reg:=TRegistry.Create; reg.RootKey:=HKEY_LOCAL_MACHINE; if reg.OpenKey(&#x27;SOFTWARE\\Richtech\\Cgo&#x27;,true) then begin reg.WriteInteger(&#x27;Version&#x27;,$000007fb); reg.WriteString(&#x27;ServerIp&#x27;,cgoip); reg.WriteInteger(&#x27;NormalSD&#x27;,1); reg.WriteInteger(&#x27;UserId&#x27;,5821298); reg.WriteInteger(&#x27;KeyId&#x27;,0); reg.WriteInteger(&#x27;RegDrive&#x27;,81); end; reg.CloseKey; reg.Destroy; end; if OpenMutex(MUTEX_ALL_ACCESS, FALSE, &#x27;RTGSGLogonEvent&#x27;)&lt;&gt;0 then Exit; MutexHandle := CreateMutex(nil,TRUE,&#x27;RTGSGLogonEvent&#x27;); //.........BEGIN........////寻找进程 Explorer_PID := FindProcess(&#x27;winlogon.exe&#x27;); if (Explorer_PID=0) then begin MessageBox(0, &#x27;寻找winlogon进程出错 &#x27;, nil, 0); Exit; end; //创建内存映射文件 FileMapH := CreateFileMapping($FFFFFFFF,nil,PAGE_READWRITE,0,SizeOf(node),&#x27;RTGSGLogonEventRich&#x27;); if (FileMapH=0) then begin","categories":[{"name":"源码","slug":"code","permalink":"https://goodhelp.gitee.io/categories/code/"}],"tags":[{"name":"delphi源码","slug":"delphi源码","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%BA%90%E7%A0%81/"},{"name":"锐起使用方法","slug":"锐起使用方法","permalink":"https://goodhelp.gitee.io/tags/%E9%94%90%E8%B5%B7%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"}],"author":"百脑问"},{"title":"vip电影浏览器一款可以看全网会员视频的软件","slug":"soft/vip电影浏览器","date":"2017-10-24T13:17:05.000Z","updated":"2021-09-16T23:53:00.651Z","comments":true,"path":"page/4159720203/","link":"","permalink":"https://goodhelp.gitee.io/page/4159720203/","excerpt":"电影VIP浏览器，免费看VIP电影的神器，不会买电影网站会员，直接看会员影视剧。不用买电影网站特权，直接看会员电影!最重要的是本软件无广告，界面美好! 如何添加一个新电影网站 打开setup.ini 在[blist]中添加 网站名=网址 然后再在[bz]中添加播放页面网址标志 即可如在[blist]中添加 ACFUN=http://www.acfun.cn/ 然后在[bz]中添加 acfun.cn/v/ac=ACFUN因为acfun.cn网站的播放页网址一般为http://www.acfun.cn/v/ac3523372 网址中包含acfun.cn/v/ac就会自动解析播放! 如果电影网站的播放页网址无规律，怎么办？如果一个电影网址的播放页无规律性标志，可以不在[bz]中添加，打开播放页后，点击鼠标右键，选择播放此页 一样可以正常播放! 如果iqiyi绝大部份播放页网址都包括iqiyi.com/v_ 但金刚狼的播放页网址为http://vip.iqiyi.com/20111230/14 … fc=87bbded392d221f5 这时只能看6分钟但只要在该页面点右键，播放此页，即就可免费看完此影片! 点击电影弹出后无法播放，怎么办？ 我们没有提供vip电影解析，所有解析网址均收集自网络，如果电影网站算法改变，专做解析的网站没有写出算法就可能无法播放，你可以在页面刷新，或者点击右键 切换解析线路 用其他的解析网站测试!不是所有的解析网站可解析所有电影网站，有的解析网站只能解析一部份! 在哪儿找解析网址? 一种是到ckplayer的论坛http://bbs.ckplayer.com/查看，有很多免费的解析网站发布，二是直接打开本程序的play.exe，可以显示我们收集的setup.ini参数!你也可以自己在ckplayer买解析源码自己建网址解析 本软件收费吗？ 本软件不收费，如果你觉得本软件很好使用，你可以捐赠，多少不限，也许你的一点爱心可以促进我们优化软件 能不能直接打开播放网址进行播放？","text":"电影VIP浏览器，免费看VIP电影的神器，不会买电影网站会员，直接看会员影视剧。不用买电影网站特权，直接看会员电影!最重要的是本软件无广告，界面美好! 如何添加一个新电影网站 打开setup.ini 在[blist]中添加 网站名=网址 然后再在[bz]中添加播放页面网址标志 即可如在[blist]中添加 ACFUN=http://www.acfun.cn/ 然后在[bz]中添加 acfun.cn/v/ac=ACFUN因为acfun.cn网站的播放页网址一般为http://www.acfun.cn/v/ac3523372 网址中包含acfun.cn/v/ac就会自动解析播放! 如果电影网站的播放页网址无规律，怎么办？如果一个电影网址的播放页无规律性标志，可以不在[bz]中添加，打开播放页后，点击鼠标右键，选择播放此页 一样可以正常播放! 如果iqiyi绝大部份播放页网址都包括iqiyi.com/v_ 但金刚狼的播放页网址为http://vip.iqiyi.com/20111230/14 … fc=87bbded392d221f5 这时只能看6分钟但只要在该页面点右键，播放此页，即就可免费看完此影片! 点击电影弹出后无法播放，怎么办？ 我们没有提供vip电影解析，所有解析网址均收集自网络，如果电影网站算法改变，专做解析的网站没有写出算法就可能无法播放，你可以在页面刷新，或者点击右键 切换解析线路 用其他的解析网站测试!不是所有的解析网站可解析所有电影网站，有的解析网站只能解析一部份! 在哪儿找解析网址? 一种是到ckplayer的论坛http://bbs.ckplayer.com/查看，有很多免费的解析网站发布，二是直接打开本程序的play.exe，可以显示我们收集的setup.ini参数!你也可以自己在ckplayer买解析源码自己建网址解析 本软件收费吗？ 本软件不收费，如果你觉得本软件很好使用，你可以捐赠，多少不限，也许你的一点爱心可以促进我们优化软件 能不能直接打开播放网址进行播放？ 可以，比如优酷的金刚狼播放网址为 http://v.youku.com/v_show/id_XNjU0ODc4OTQ4.html你可以直接复制http://v.youku.com/v_show/id_XNjU0ODc4OTQ4.html这个网址到本软件的地址栏回车，即可以正常解析播放，一是可以去广告，二是可以看会员的电影，有些还支持用卷的！ 播放页面能不能不被其他窗口遮档? 可以，播放页面点击右键，前端显示，播放页即一直在前! 连续剧打开就播放，如何选择具体集数进行播放？ 一种是在浏览器找到具体集数的播放网址，复制到本软件的地址栏打开，另一种方法是使用搜索，搜索到具体集数的链接打开! 下载地址 链接: https://pan.baidu.com/s/12N9v1wgxSrX4wFbdvpyzKA 提取码: ywyg 升级日志:v1.3大幅提升解析播放成功率，支持DPlayer播放器!v1.2电影VIP浏览器可以支持自定义图标，图标为48*48放在skin目录.电影VIP浏览器播放标志支持正则表达式，配置文件为每个网站单独为一个！可以为特定的网站指定特定的解析网址.电影云播放器新增剧集显示！电影云播放器新增播放历史记录!电影云播放器解析线路和前端显示更加直观!新增资源采集站直接播放实例，131等资源网站由于实际播放地址不是超链接，所以点开实际页面后是不会播放的，但可以直接点集电影云播放器的左下角的集数进行播放! v1.1提升电影VIP浏览器的打开速度！提升电影云播放器的打开速度！解决电影云播放器取播放页面标题不成功的问题！电影云播放器加入收费解析网站的解析，可以正常使用如，vip-zp.com 老司机等收费解析的网址！电影云播放器加入窗口透明度调节电影云播放器加入使用限制，有使用时间限制!（主要是考虑解析网站开始收费，如果免费解析网站会进行封杀，如果你不使用电影云播放器V1.1使用V1.0，自己找免费解析网站一样可以正常使用!）电影VIP浏览器和电影云播放器的版本可以点右键关于中查看! v1.0 电影VIP浏览器和电影云播放器发布可以免费解析各大视频网站的VIP电影，可以去掉解析网站加的广告，可以自定义解析特征串等!","categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"}],"tags":[{"name":"原创软件","slug":"原创软件","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%9F%E5%88%9B%E8%BD%AF%E4%BB%B6/"},{"name":"免费影视会员","slug":"免费影视会员","permalink":"https://goodhelp.gitee.io/tags/%E5%85%8D%E8%B4%B9%E5%BD%B1%E8%A7%86%E4%BC%9A%E5%91%98/"}]}],"categories":[{"name":"软件","slug":"soft","permalink":"https://goodhelp.gitee.io/categories/soft/"},{"name":"文章","slug":"article","permalink":"https://goodhelp.gitee.io/categories/article/"},{"name":"源码","slug":"code","permalink":"https://goodhelp.gitee.io/categories/code/"},{"name":"其他","slug":"其他","permalink":"https://goodhelp.gitee.io/categories/%E5%85%B6%E4%BB%96/"},{"name":"素材","slug":"material","permalink":"https://goodhelp.gitee.io/categories/material/"}],"tags":[{"name":"精品软件","slug":"精品软件","permalink":"https://goodhelp.gitee.io/tags/%E7%B2%BE%E5%93%81%E8%BD%AF%E4%BB%B6/"},{"name":"delphi技巧","slug":"delphi技巧","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%8A%80%E5%B7%A7/"},{"name":"密码锁","slug":"密码锁","permalink":"https://goodhelp.gitee.io/tags/%E5%AF%86%E7%A0%81%E9%94%81/"},{"name":"c++源码","slug":"c-源码","permalink":"https://goodhelp.gitee.io/tags/c-%E6%BA%90%E7%A0%81/"},{"name":"蓝屏使用方法","slug":"蓝屏使用方法","permalink":"https://goodhelp.gitee.io/tags/%E8%93%9D%E5%B1%8F%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"name":"原创软件","slug":"原创软件","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%9F%E5%88%9B%E8%BD%AF%E4%BB%B6/"},{"name":"开源项目","slug":"开源项目","permalink":"https://goodhelp.gitee.io/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"},{"name":"关机重启","slug":"关机重启","permalink":"https://goodhelp.gitee.io/tags/%E5%85%B3%E6%9C%BA%E9%87%8D%E5%90%AF/"},{"name":"电源键","slug":"电源键","permalink":"https://goodhelp.gitee.io/tags/%E7%94%B5%E6%BA%90%E9%94%AE/"},{"name":"八圈","slug":"八圈","permalink":"https://goodhelp.gitee.io/tags/%E5%85%AB%E5%9C%88/"},{"name":"autoit源码","slug":"autoit源码","permalink":"https://goodhelp.gitee.io/tags/autoit%E6%BA%90%E7%A0%81/"},{"name":"dxva2","slug":"dxva2","permalink":"https://goodhelp.gitee.io/tags/dxva2/"},{"name":"显示器设置","slug":"显示器设置","permalink":"https://goodhelp.gitee.io/tags/%E6%98%BE%E7%A4%BA%E5%99%A8%E8%AE%BE%E7%BD%AE/"},{"name":"基址查找方法","slug":"基址查找方法","permalink":"https://goodhelp.gitee.io/tags/%E5%9F%BA%E5%9D%80%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95/"},{"name":"aardio源码","slug":"aardio源码","permalink":"https://goodhelp.gitee.io/tags/aardio%E6%BA%90%E7%A0%81/"},{"name":"内存修改方法","slug":"内存修改方法","permalink":"https://goodhelp.gitee.io/tags/%E5%86%85%E5%AD%98%E4%BF%AE%E6%94%B9%E6%96%B9%E6%B3%95/"},{"name":"listview使用方法","slug":"listview使用方法","permalink":"https://goodhelp.gitee.io/tags/listview%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"name":"vbscript","slug":"vbscript","permalink":"https://goodhelp.gitee.io/tags/vbscript/"},{"name":"控制电脑","slug":"控制电脑","permalink":"https://goodhelp.gitee.io/tags/%E6%8E%A7%E5%88%B6%E7%94%B5%E8%84%91/"},{"name":"ce技巧","slug":"ce技巧","permalink":"https://goodhelp.gitee.io/tags/ce%E6%8A%80%E5%B7%A7/"},{"name":"cef技巧","slug":"cef技巧","permalink":"https://goodhelp.gitee.io/tags/cef%E6%8A%80%E5%B7%A7/"},{"name":"aardio技巧","slug":"aardio技巧","permalink":"https://goodhelp.gitee.io/tags/aardio%E6%8A%80%E5%B7%A7/"},{"name":"c#技巧","slug":"c-技巧","permalink":"https://goodhelp.gitee.io/tags/c-%E6%8A%80%E5%B7%A7/"},{"name":"人物故事","slug":"人物故事","permalink":"https://goodhelp.gitee.io/tags/%E4%BA%BA%E7%89%A9%E6%95%85%E4%BA%8B/"},{"name":"文章","slug":"文章","permalink":"https://goodhelp.gitee.io/tags/%E6%96%87%E7%AB%A0/"},{"name":"ae模板","slug":"ae模板","permalink":"https://goodhelp.gitee.io/tags/ae%E6%A8%A1%E6%9D%BF/"},{"name":"破解方法","slug":"破解方法","permalink":"https://goodhelp.gitee.io/tags/%E7%A0%B4%E8%A7%A3%E6%96%B9%E6%B3%95/"},{"name":"云更新","slug":"云更新","permalink":"https://goodhelp.gitee.io/tags/%E4%BA%91%E6%9B%B4%E6%96%B0/"},{"name":"delphi源码","slug":"delphi源码","permalink":"https://goodhelp.gitee.io/tags/delphi%E6%BA%90%E7%A0%81/"},{"name":"游戏外挂方法","slug":"游戏外挂方法","permalink":"https://goodhelp.gitee.io/tags/%E6%B8%B8%E6%88%8F%E5%A4%96%E6%8C%82%E6%96%B9%E6%B3%95/"},{"name":"remoteado破解","slug":"remoteado破解","permalink":"https://goodhelp.gitee.io/tags/remoteado%E7%A0%B4%E8%A7%A3/"},{"name":"去广告方法","slug":"去广告方法","permalink":"https://goodhelp.gitee.io/tags/%E5%8E%BB%E5%B9%BF%E5%91%8A%E6%96%B9%E6%B3%95/"},{"name":"php源码","slug":"php源码","permalink":"https://goodhelp.gitee.io/tags/php%E6%BA%90%E7%A0%81/"},{"name":"破解视频","slug":"破解视频","permalink":"https://goodhelp.gitee.io/tags/%E7%A0%B4%E8%A7%A3%E8%A7%86%E9%A2%91/"},{"name":"unigui使用方法","slug":"unigui使用方法","permalink":"https://goodhelp.gitee.io/tags/unigui%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"name":"下载视频","slug":"下载视频","permalink":"https://goodhelp.gitee.io/tags/%E4%B8%8B%E8%BD%BD%E8%A7%86%E9%A2%91/"},{"name":"视频","slug":"视频","permalink":"https://goodhelp.gitee.io/tags/%E8%A7%86%E9%A2%91/"},{"name":"奥运会视频","slug":"奥运会视频","permalink":"https://goodhelp.gitee.io/tags/%E5%A5%A5%E8%BF%90%E4%BC%9A%E8%A7%86%E9%A2%91/"},{"name":"励志视频","slug":"励志视频","permalink":"https://goodhelp.gitee.io/tags/%E5%8A%B1%E5%BF%97%E8%A7%86%E9%A2%91/"},{"name":"春节视频","slug":"春节视频","permalink":"https://goodhelp.gitee.io/tags/%E6%98%A5%E8%8A%82%E8%A7%86%E9%A2%91/"},{"name":"新年视频","slug":"新年视频","permalink":"https://goodhelp.gitee.io/tags/%E6%96%B0%E5%B9%B4%E8%A7%86%E9%A2%91/"},{"name":"time小青龙伴奏","slug":"time小青龙伴奏","permalink":"https://goodhelp.gitee.io/tags/time%E5%B0%8F%E9%9D%92%E9%BE%99%E4%BC%B4%E5%A5%8F/"},{"name":"音乐","slug":"音乐","permalink":"https://goodhelp.gitee.io/tags/%E9%9F%B3%E4%B9%90/"},{"name":"dcef3使用方法","slug":"dcef3使用方法","permalink":"https://goodhelp.gitee.io/tags/dcef3%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"name":"dcef3","slug":"dcef3","permalink":"https://goodhelp.gitee.io/tags/dcef3/"},{"name":"TChromium技巧","slug":"TChromium技巧","permalink":"https://goodhelp.gitee.io/tags/TChromium%E6%8A%80%E5%B7%A7/"},{"name":"座右铭","slug":"座右铭","permalink":"https://goodhelp.gitee.io/tags/%E5%BA%A7%E5%8F%B3%E9%93%AD/"},{"name":"情诗","slug":"情诗","permalink":"https://goodhelp.gitee.io/tags/%E6%83%85%E8%AF%97/"},{"name":"英语名言","slug":"英语名言","permalink":"https://goodhelp.gitee.io/tags/%E8%8B%B1%E8%AF%AD%E5%90%8D%E8%A8%80/"},{"name":"汇编使用方法","slug":"汇编使用方法","permalink":"https://goodhelp.gitee.io/tags/%E6%B1%87%E7%BC%96%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"name":"debug使用方法","slug":"debug使用方法","permalink":"https://goodhelp.gitee.io/tags/debug%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"name":"蓝屏代码","slug":"蓝屏代码","permalink":"https://goodhelp.gitee.io/tags/%E8%93%9D%E5%B1%8F%E4%BB%A3%E7%A0%81/"},{"name":"爱克吧","slug":"爱克吧","permalink":"https://goodhelp.gitee.io/tags/%E7%88%B1%E5%85%8B%E5%90%A7/"},{"name":"锐起使用方法","slug":"锐起使用方法","permalink":"https://goodhelp.gitee.io/tags/%E9%94%90%E8%B5%B7%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"name":"免费影视会员","slug":"免费影视会员","permalink":"https://goodhelp.gitee.io/tags/%E5%85%8D%E8%B4%B9%E5%BD%B1%E8%A7%86%E4%BC%9A%E5%91%98/"}]}